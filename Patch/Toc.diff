diff --git a/sql/updates/world/2015_10_01_14938_world.sql b/sql/updates/world/2015_10_01_14938_world.sql
new file mode 100644
index 0000000..28c3a51
--- /dev/null
+++ b/sql/updates/world/2015_10_01_14938_world.sql
@@ -0,0 +1,462 @@
+-- Trial of the Champion
+-- by Appled
+-- Thanks to Aokromes for providing sniffs
+
+--
+-- General
+--
+
+-- Disabling mmap for Trial of the Champion instance
+-- creatures are spawned according to sniffs behind an invisible wall and they don't know how to go through it
+-- Edit: Aokromes has pushed this already but disabled whole instance in the same commit
+DELETE FROM `disables` WHERE `entry`=650 AND `sourceType`=2;
+-- DELETE FROM `disables` WHERE `sourceType`='7' AND `entry`='650';
+-- INSERT INTO `disables` (`sourceType`,`entry`) VALUES ('7','650');
+
+-- Spellscript for vehicles' Trample aura
+DELETE FROM `spell_script_names` WHERE `spell_id`=67868 AND `ScriptName`='spell_toc5_trample_aura';
+INSERT INTO `spell_script_names` VALUES (67868,'spell_toc5_trample_aura');
+
+-- Spellscript for Hunter Grand Champion's Lightning Arrows
+DELETE FROM `spell_script_names` WHERE `spell_id`=66083 AND `ScriptName`='spell_toc5_lightning_arrows';
+INSERT INTO `spell_script_names` VALUES (66083,'spell_toc5_lightning_arrows');
+
+-- Spellscript for Paletress' Reflective Shield
+DELETE FROM `spell_script_names` WHERE `spell_id`=66515 AND `ScriptName`='spell_paletress_reflective_shield';
+INSERT INTO `spell_script_names` VALUES (66515,'spell_paletress_reflective_shield');
+
+-- Spellscript for Eadric' Hammer of the Righteous
+DELETE FROM `spell_script_names` WHERE `spell_id`=66867 AND `ScriptName`='spell_eadric_hammer_of_righteous';
+INSERT INTO `spell_script_names` VALUES (66867,'spell_eadric_hammer_of_righteous');
+
+-- Spellscript for Eadric' Hammer of the Righteous - casted by player
+DELETE FROM `spell_script_names` WHERE `spell_id`=66905 AND `ScriptName`='spell_eadric_hammer_of_righteous_faceroller';
+INSERT INTO `spell_script_names` VALUES (66905,'spell_eadric_hammer_of_righteous_faceroller');
+
+-- Spellscript for The Black Knight's Death's Push - casted on announcer
+DELETE FROM `spell_script_names` WHERE `spell_id`=66797 AND `ScriptName`='spell_black_knight_deaths_push';
+INSERT INTO `spell_script_names` VALUES (66797,'spell_black_knight_deaths_push');
+
+-- Spellscript for The Black Knight's Obliterate
+DELETE FROM `spell_script_names` WHERE `spell_id` IN (67725,67883) AND `ScriptName`='spell_black_knight_obliterate';
+INSERT INTO `spell_script_names` VALUES
+(67725,'spell_black_knight_obliterate'),
+(67883,'spell_black_knight_obliterate');
+
+-- Spellscript for The Black Knight's Army of the Dead
+DELETE FROM `spell_script_names` WHERE `spell_id` IN (67761,67874) AND `ScriptName`='spell_black_knight_army_of_the_dead';
+INSERT INTO `spell_script_names` VALUES
+(67761,'spell_black_knight_army_of_the_dead'),
+(67874,'spell_black_knight_army_of_the_dead');
+
+-- Spellscript for The Black Knight's Ghoul Explode
+DELETE FROM `spell_script_names` WHERE `spell_id`=67751 AND `ScriptName`='spell_black_knight_ghoul_explode';
+INSERT INTO `spell_script_names` VALUES (67751,'spell_black_knight_ghoul_explode');
+
+-- Eadric and Paletress should not drop item 47197 in heroic mode
+-- it drops only from Eadric in normal mode
+-- Also item 47947 was missing from Eadric and Paletress in heroic mode
+DELETE FROM `reference_loot_template` WHERE `Entry`=12025 AND `Item` IN (47197,47497);
+INSERT INTO `reference_loot_template` VALUES (12025,47497,0,0,0,1,1,1,1,'');
+
+-- The Black Knight should not drop item 47560 in normal mode
+-- it drops only in heroic mode
+-- Also item 47229 was missing from The Black Knight in normal mode
+DELETE FROM `reference_loot_template` WHERE `Entry`=34170 AND `Item` IN (47229,47560);
+INSERT INTO `reference_loot_template` VALUES (34170,47229,0,0,0,1,1,1,1,'');
+
+--
+-- Vehicles
+--
+
+-- Variables
+SET @ARGENT_WARHORSE_GC := 35644; -- used by Grand Champions in looking for mount phase, cannot be used by players
+SET @ARGENT_WARHORSE := 36557;
+SET @ARGENT_BATTLEWORG := 36558;
+SET @ARGENT_BATTLEWORG_GC := 36559; -- used by Grand Champions in looking for mount phase, cannot be used by players
+
+-- Scriptname for cosmetic vehicles
+UPDATE `creature_template` SET `ScriptName`='generic_vehicleAI_toc5' WHERE `entry` IN (@ARGENT_BATTLEWORG_GC,@ARGENT_WARHORSE_GC);
+
+UPDATE `creature_template` SET `faction`=14, `npcflag`=16777216, `VehicleId`=529, `speed_walk`=2.5/2.5, `speed_run`=11.0/7.0, `unit_flags`=256, `unit_flags2`=0 WHERE `entry` IN (@ARGENT_WARHORSE_GC,@ARGENT_BATTLEWORG_GC);
+UPDATE `creature_template` SET `faction`=35, `npcflag`=16777216, `VehicleId`=486, `speed_walk`=2.5/2.5, `speed_run`=11.0/7.0, `unit_flags`=0, `unit_flags2`=0 WHERE `entry` IN (@ARGENT_WARHORSE,@ARGENT_BATTLEWORG);
+
+UPDATE `creature_template` SET `Spell1`=0, `Spell2`=0, `Spell3`=0, `Spell4`=0 WHERE `entry` IN (@ARGENT_WARHORSE_GC, @ARGENT_BATTLEWORG_GC);
+UPDATE `creature_template` SET `Spell1`=68505, `Spell2`=62575, `Spell3`=68282, `Spell4`=62552 WHERE `entry` IN (@ARGENT_WARHORSE, @ARGENT_BATTLEWORG);
+
+DELETE FROM `npc_spellclick_spells` WHERE `npc_entry` IN (@ARGENT_WARHORSE_GC,@ARGENT_WARHORSE,@ARGENT_BATTLEWORG,@ARGENT_BATTLEWORG_GC);
+INSERT INTO `npc_spellclick_spells` (`npc_entry`, `spell_id`, `cast_flags`, `user_type`) VALUES
+(@ARGENT_WARHORSE,   67830, 1, 0),
+(@ARGENT_BATTLEWORG, 67830, 1, 0);
+
+DELETE FROM `creature_template_addon` WHERE `entry` IN (@ARGENT_WARHORSE_GC,@ARGENT_WARHORSE,@ARGENT_BATTLEWORG,@ARGENT_BATTLEWORG_GC);
+INSERT INTO `creature_template_addon` (`entry`, `mount`, `bytes1`, `bytes2`, `emote`, `auras`) VALUES
+(@ARGENT_WARHORSE_GC,   0, 0,   1, 0, '67870'),
+(@ARGENT_WARHORSE,      0, 0, 257, 0, '67865'),
+(@ARGENT_BATTLEWORG,    0, 0, 257, 0, '67865'),
+(@ARGENT_BATTLEWORG_GC, 0, 0,   1, 0, '67870');
+
+-- You should not be able to mount a vehicle if you don't have Argent Lance equipped
+DELETE FROM `conditions` WHERE `SourceTypeOrReferenceId`=16 AND `SourceGroup`=0 AND `SourceEntry` IN (@ARGENT_BATTLEWORG,@ARGENT_WARHORSE);
+INSERT INTO `conditions` (`SourceTypeOrReferenceId`,`SourceGroup`,`SourceEntry`,`SourceId`,`ElseGroup`,`ConditionTypeOrReference`,`ConditionTarget`,`ConditionValue1`,`ConditionValue2`,`ConditionValue3`,`Comment`) VALUES
+(16,0,@ARGENT_BATTLEWORG,0,0,3,0,46106,0,0,'Argent Lance must be equipped in order to mount a vehicle'),
+(16,0,@ARGENT_WARHORSE,0,0,3,0,46106,0,0,'Argent Lance must be equipped in order to mount a vehicle');
+
+--
+-- Heralds
+--
+
+-- Variables
+SET @HERALD_H := 35004; -- Jaeren Sunsworn
+SET @HERALD_A := 35005; -- Arelas Brightstar
+SET @GOSSIP_MENU := 10614; -- same gossip menu used by both heralds
+
+-- Arelas Brightstar had no gossip menu set in database
+UPDATE `creature_template` SET `gossip_menu_id`=@GOSSIP_MENU WHERE `entry`=@HERALD_A;
+
+--
+-- Text updates
+--
+
+-- Roleplaying event is missing creature_text data
+DELETE FROM `creature_text` WHERE `entry` IN (@HERALD_H,@HERALD_A) AND `groupid` BETWEEN 9 AND 13;
+INSERT INTO `creature_text` (`entry`,`groupid`,`id`,`text`,`type`,`probability`,`sound`,`BroadcastTextId`,`TextRange`,`comment`) VALUES
+(@HERALD_H,9,0,'$n has risen to the ranks of champion in our tournament.  We are proud to present $ghim:her; to you today.',14,100,8574,35304,2,'Jaeren Sunsworn - SAY_JAEREN_INTRODUCE_PLAYER_0'),
+(@HERALD_H,10,0,'Champions on the tournament grounds speak highly of this $c.  Today we present, $n.',14,100,8574,35305,2,'Jaeren Sunsworn - SAY_JAEREN_INTRODUCE_PLAYER_1'),
+(@HERALD_H,11,0,'One would be hard pressed to find a more steadfast champion than this $c.  Today we present, $n. ',14,100,8574,35306,2,'Jaeren Sunsworn - SAY_JAEREN_INTRODUCE_PLAYER_2'),
+(@HERALD_H,12,0,'We offer a mighty champion, a capable $c, an honorable $r.  We present, $n.',14,100,8574,35307,2,'Jaeren Sunsworn - SAY_JAEREN_INTRODUCE_PLAYER_3'),
+(@HERALD_H,13,0,'Many champions have fallen to the skills displayed by $n.  We are proud to present this formidable $c.',14,100,8574,35308,2,'Jaeren Sunsworn - SAY_JAEREN_INTRODUCE_PLAYER_4'),
+(@HERALD_A,9,0,'$n has risen to the ranks of champion in our tournament.  We are proud to present $ghim:her; to you today.',14,100,8574,35304,2,'Arelas Brightstar - SAY_ARELAS_INTRODUCE_PLAYER_0'),
+(@HERALD_A,10,0,'Champions on the tournament grounds speak highly of this $c.  Today we present, $n.',14,100,8574,35305,2,'Arelas Brightstar - SAY_ARELAS_INTRODUCE_PLAYER_1'),
+(@HERALD_A,11,0,'One would be hard pressed to find a more steadfast champion than this $c.  Today we present, $n. ',14,100,8574,35306,2,'Arelas Brightstar - SAY_ARELAS_INTRODUCE_PLAYER_2'),
+(@HERALD_A,12,0,'We offer a mighty champion, a capable $c, an honorable $r.  We present, $n.',14,100,8574,35307,2,'Arelas Brightstar - SAY_ARELAS_INTRODUCE_PLAYER_3'),
+(@HERALD_A,13,0,'Many champions have fallen to the skills displayed by $n.  We are proud to present this formidable $c.',14,100,8574,35308,2,'Arelas Brightstar - SAY_ARELAS_INTRODUCE_PLAYER_4');
+
+-- Jaina Proudmoore is missing her texts
+DELETE FROM `creature_text` WHERE `entry`=34992 AND `groupid` IN (0,1);
+INSERT INTO `creature_text` (`entry`,`groupid`,`id`,`text`,`type`,`probability`,`BroadcastTextId`,`TextRange`,`comment`) VALUES
+(34992,0,0,'Of course they will.',12,100,35323,2,'Lady Jaina Proudmoore - SAY_JAINA_INTRO_1'),
+(34992,1,0,'They''re worthy fighters, you''ll see.',12,100,35329,2,'Lady Jaina Proudmoore - SAY_JAINA_INTRO_2');
+
+-- Two of the texts in instance were 'say' instead of 'yell'
+UPDATE `creature_text` SET `type`=14 WHERE `entry`=@HERALD_A AND `groupid`=0;
+UPDATE `creature_text` SET `type`=14 WHERE `entry`=@HERALD_H AND `groupid`=0;
+
+-- Most of the texts in instance should be zonewide
+UPDATE `creature_text` SET `TextRange`=2 WHERE `entry`=34990 AND `groupid` BETWEEN 50 AND 53;
+UPDATE `creature_text` SET `TextRange`=2 WHERE `entry`=34995 AND `groupid` BETWEEN 50 AND 52;
+UPDATE `creature_text` SET `TextRange`=2 WHERE `entry`=34994;
+UPDATE `creature_text` SET `TextRange`=2 WHERE `entry` BETWEEN 34900 AND 34910 AND `groupid`=0 AND `id`=0;
+UPDATE `creature_text` SET `TextRange`=2 WHERE `entry`=34996 AND `groupid` BETWEEN 50 AND 58 AND `id`=0;
+UPDATE `creature_text` SET `TextRange`=2 WHERE `entry` IN (@HERALD_A,@HERALD_H) AND `groupid` BETWEEN 0 AND 8 AND `id`=0;
+UPDATE `creature_text` SET `TextRange`=2 WHERE `entry` IN (34657,34701,34702,34703,34705,34883,34887,35569,35570,35571,35572,35617) AND `groupid`=0 AND `id`=0;
+UPDATE `creature_text` SET `TextRange`=2 WHERE `entry` IN (34928,35119,35451);
+UPDATE `creature_text` SET `TextRange`=2 WHERE `BroadcastTextId`=35491;
+
+--
+-- Lesser Champions
+--
+
+-- Variables
+SET @ORC_CHAMP := 35314;
+SET @TROLL_CHAMP := 35323;
+SET @TAUREN_CHAMP := 35325;
+SET @BELF_CHAMP := 35326;
+SET @UNDEAD_CHAMP := 35327;
+SET @HUMAN_CHAMP := 35328;
+SET @DWARF_CHAMP := 35329;
+SET @DRAENEI_CHAMP := 35330;
+SET @GNOME_CHAMP := 35331;
+SET @NELF_CHAMP := 35332;
+
+-- Each lesser champion had passiveAI set and had no scriptname assigned in database
+UPDATE `creature_template` SET `AIName`='',`ScriptName`='generic_vehicleAI_toc5' WHERE `entry` IN (@ORC_CHAMP,@TROLL_CHAMP,@TAUREN_CHAMP,@BELF_CHAMP,@UNDEAD_CHAMP,@HUMAN_CHAMP,@DWARF_CHAMP,@DRAENEI_CHAMP,@GNOME_CHAMP,@NELF_CHAMP);
+
+-- Lesser Champions should award reputation on kill
+DELETE FROM `creature_onkill_reputation` WHERE `creature_id` IN (@ORC_CHAMP,@TROLL_CHAMP,@TAUREN_CHAMP,@BELF_CHAMP,@UNDEAD_CHAMP,@HUMAN_CHAMP,@DWARF_CHAMP,@DRAENEI_CHAMP,@GNOME_CHAMP,@NELF_CHAMP);
+INSERT INTO `creature_onkill_reputation` VALUES
+(@ORC_CHAMP,1037,1052,7,0,5,7,0,5,1),
+(@TROLL_CHAMP,1037,1052,7,0,5,7,0,5,1),
+(@TAUREN_CHAMP,1037,1052,7,0,5,7,0,5,1),
+(@BELF_CHAMP,1037,1052,7,0,5,7,0,5,1),
+(@UNDEAD_CHAMP,1037,1052,7,0,5,7,0,5,1),
+(@HUMAN_CHAMP,1037,1052,7,0,5,7,0,5,1),
+(@DWARF_CHAMP,1037,1052,7,0,5,7,0,5,1),
+(@DRAENEI_CHAMP,1037,1052,7,0,5,7,0,5,1),
+(@GNOME_CHAMP,1037,1052,7,0,5,7,0,5,1),
+(@NELF_CHAMP,1037,1052,7,0,5,7,0,5,1);
+
+--
+-- Grand Champions
+--
+
+-- Variables
+-- Normal mode
+SET @MOKRA := 35572;
+SET @ERESSEA := 35569;
+SET @RUNOK := 35571;
+SET @ZULTORE := 35570;
+SET @VISCERI := 35617;
+SET @JACOB := 34705;
+SET @AMBROSE := 34702;
+SET @COLOSOS := 34701;
+SET @JAELYNE := 34657;
+SET @LANA := 34703;
+-- Heroic mode
+SET @MOKRA_H := 36089;
+SET @ERESSEA_H := 36085;
+SET @RUNOK_H := 36090;
+SET @ZULTORE_H := 36091;
+SET @VISCERI_H := 36084;
+SET @JACOB_H := 36088;
+SET @AMBROSE_H := 36082;
+SET @COLOSOS_H := 36083;
+SET @JAELYNE_H := 36086;
+SET @LANA_H := 36087;
+
+-- None of the grand champions had correct unit flags set in database
+UPDATE `creature_template` SET `unit_flags`=33024 WHERE `entry` IN (@MOKRA,@ERESSEA,@RUNOK,@ZULTORE,@VISCERI,@JACOB,@AMBROSE,@COLOSOS,@JAELYNE,@LANA,@MOKRA_H,@ERESSEA_H,@RUNOK_H,@ZULTORE_H,@VISCERI_H,@JACOB_H,@AMBROSE_H,@COLOSOS_H,@JAELYNE_H,@LANA_H);
+
+-- Rogue Champion's Deadly Poison should have 5 second internal cooldown
+DELETE FROM `spell_proc_event` WHERE `entry`=67711;
+INSERT INTO `spell_proc_event` (`entry`,`Cooldown`) VALUES (67711,5);
+-- Rogue Champion's Fan of Knives should also trigger Deadly Poison on each target
+DELETE FROM `spell_linked_spell` WHERE `spell_trigger`=67706;
+INSERT INTO `spell_linked_spell` VALUES (67706,67710,1,'Rogue Champion - Trigger Deadly Poison on Fan of Knives');
+
+-- Achievement criteria data
+-- for achievement IDs 3778, 4018, 4019, 4048, 4049, 4050, 4051, 4052, 4053, 4054, 4055, 4296, 4297, 4298, 
+
+-- Variables
+SET @CRITERIA_JACOB := 11420;
+SET @CRITERIA_LANA := 12298;
+SET @CRITERIA_COLOSOS := 12299;
+SET @CRITERIA_AMBROSE := 12300;
+SET @CRITERIA_JAELYNE := 12301;
+SET @CRITERIA_MOKRA := 12302;
+SET @CRITERIA_VISCERI := 12303;
+SET @CRITERIA_RUNOK := 12304;
+SET @CRITERIA_ERESSEA := 12305;
+SET @CRITERIA_ZULTORE := 12306;
+SET @CRITERIA_JACOB_H := 12310;
+SET @CRITERIA_LANA_H := 12311;
+SET @CRITERIA_COLOSOS_H := 12312;
+SET @CRITERIA_AMBROSE_H := 12313;
+SET @CRITERIA_JAELYNE_H := 12314;
+SET @CRITERIA_MOKRA_H := 12318;
+SET @CRITERIA_VISCERI_H := 12319;
+SET @CRITERIA_RUNOK_H := 12320;
+SET @CRITERIA_ERESSEA_H := 12321;
+SET @CRITERIA_ZULTORE_H := 12322;
+-- Statistics achievements
+SET @CRITERIA_WARRIOR := 12538;
+SET @CRITERIA_HUNTER := 12540;
+SET @CRITERIA_MAGE := 12542;
+SET @CRITERIA_ROGUE := 12544;
+SET @CRITERIA_SHAMAN := 12546;
+SET @CRITERIA_WARRIOR_H := 12539;
+SET @CRITERIA_HUNTER_H := 12541;
+SET @CRITERIA_MAGE_H := 12543;
+SET @CRITERIA_ROGUE_H := 12545;
+SET @CRITERIA_SHAMAN_H := 12547;
+
+-- These criterias are missing creature checks
+DELETE FROM `achievement_criteria_data` WHERE `type`=1 AND `criteria_id` IN (@CRITERIA_JACOB,@CRITERIA_LANA,@CRITERIA_COLOSOS,@CRITERIA_AMBROSE,@CRITERIA_JAELYNE,@CRITERIA_MOKRA,@CRITERIA_VISCERI,@CRITERIA_RUNOK,@CRITERIA_ERESSEA,@CRITERIA_ZULTORE,@CRITERIA_JACOB_H,@CRITERIA_LANA_H,@CRITERIA_COLOSOS_H,@CRITERIA_AMBROSE_H,@CRITERIA_JAELYNE_H,@CRITERIA_MOKRA_H,@CRITERIA_VISCERI_H,@CRITERIA_RUNOK_H,@CRITERIA_ERESSEA_H,@CRITERIA_ZULTORE_H);
+INSERT INTO `achievement_criteria_data` (`criteria_id`,`type`,`value1`) VALUES
+(@CRITERIA_JACOB,1,@JACOB),
+(@CRITERIA_LANA,1,@LANA),
+(@CRITERIA_COLOSOS,1,@COLOSOS),
+(@CRITERIA_AMBROSE,1,@AMBROSE),
+(@CRITERIA_JAELYNE,1,@JAELYNE),
+(@CRITERIA_MOKRA,1,@MOKRA),
+(@CRITERIA_VISCERI,1,@VISCERI),
+(@CRITERIA_RUNOK,1,@RUNOK),
+(@CRITERIA_ERESSEA,1,@ERESSEA),
+(@CRITERIA_ZULTORE,1,@ZULTORE),
+(@CRITERIA_JACOB_H,1,@JACOB),
+(@CRITERIA_LANA_H,1,@LANA),
+(@CRITERIA_COLOSOS_H,1,@COLOSOS),
+(@CRITERIA_AMBROSE_H,1,@AMBROSE),
+(@CRITERIA_JAELYNE_H,1,@JAELYNE),
+(@CRITERIA_MOKRA_H,1,@MOKRA),
+(@CRITERIA_VISCERI_H,1,@VISCERI),
+(@CRITERIA_RUNOK_H,1,@RUNOK),
+(@CRITERIA_ERESSEA_H,1,@ERESSEA),
+(@CRITERIA_ZULTORE_H,1,@ZULTORE);
+
+-- Statistics achievements are also missing creature checks
+-- but as criterias are same on both horde and alliance,
+-- and we can only check for one creature entry,
+-- we must use core script to check for two entries
+-- Also we remove heroic checks from database, they are handled in the script
+DELETE FROM `achievement_criteria_data` WHERE `type`=11 AND `criteria_id` IN (@CRITERIA_WARRIOR,@CRITERIA_HUNTER,@CRITERIA_MAGE,@CRITERIA_ROGUE,@CRITERIA_SHAMAN,@CRITERIA_WARRIOR_H,@CRITERIA_HUNTER_H,@CRITERIA_MAGE_H,@CRITERIA_ROGUE_H,@CRITERIA_SHAMAN_H);
+INSERT INTO `achievement_criteria_data` (`criteria_id`,`type`,`ScriptName`) VALUES
+(@CRITERIA_WARRIOR,11,'achievement_victories_over_war_champion'),
+(@CRITERIA_HUNTER,11,'achievement_victories_over_hun_champion'),
+(@CRITERIA_MAGE,11,'achievement_victories_over_mag_champion'),
+(@CRITERIA_ROGUE,11,'achievement_victories_over_rog_champion'),
+(@CRITERIA_SHAMAN,11,'achievement_victories_over_sha_champion'),
+(@CRITERIA_WARRIOR_H,11,'achievement_victories_over_war_champion_h'),
+(@CRITERIA_HUNTER_H,11,'achievement_victories_over_hun_champion_h'),
+(@CRITERIA_MAGE_H,11,'achievement_victories_over_mag_champion_h'),
+(@CRITERIA_ROGUE_H,11,'achievement_victories_over_rog_champion_h'),
+(@CRITERIA_SHAMAN_H,11,'achievement_victories_over_sha_champion_h');
+
+--
+-- Argent Champion
+--
+
+-- Thrash mobs are missing reputation data and money drop
+
+-- Variables
+SET @ARGENT_MONK := 35305;
+SET @ARGENT_MONK_H := 35306;
+SET @ARGENT_PRIESTESS := 35307;
+SET @ARGENT_PRIESTESS_H := 35308;
+SET @ARGENT_LIGHTWIELDER := 35309;
+SET @ARGENT_LIGHTWIELDER_H := 35310;
+
+UPDATE `creature_template` SET `mingold`=3821,`maxgold`=9521 WHERE `entry` IN (@ARGENT_MONK,@ARGENT_PRIESTESS,@ARGENT_LIGHTWIELDER);
+UPDATE `creature_template` SET `mingold`=11529,`maxgold`=17291 WHERE `entry` IN (@ARGENT_MONK_H,@ARGENT_PRIESTESS_H,@ARGENT_LIGHTWIELDER_H);
+
+DELETE FROM `creature_onkill_reputation` WHERE `creature_id` IN (@ARGENT_MONK,@ARGENT_PRIESTESS,@ARGENT_LIGHTWIELDER,@ARGENT_MONK_H,@ARGENT_PRIESTESS_H,@ARGENT_LIGHTWIELDER_H);
+INSERT INTO `creature_onkill_reputation` VALUES
+(@ARGENT_MONK,1037,1052,7,0,5,7,0,5,1),
+(@ARGENT_PRIESTESS,1037,1052,7,0,5,7,0,5,1),
+(@ARGENT_LIGHTWIELDER,1037,1052,7,0,5,7,0,5,1),
+(@ARGENT_MONK_H,1037,1052,7,0,10,7,0,10,1),
+(@ARGENT_PRIESTESS_H,1037,1052,7,0,10,7,0,10,1),
+(@ARGENT_LIGHTWIELDER_H,1037,1052,7,0,10,7,0,10,1);
+
+-- Scriptname for Argent Priestess' Fountain of Light
+UPDATE `creature_template` SET `ScriptName`='npc_fountain_of_light' WHERE `entry`=35311;
+
+-- Achievement criteria data
+-- for achievement id 3802
+
+-- Variables
+SET @CRITERIA_HOGGER := 11863;
+SET @CRITERIA_VANCLEEF := 11904;
+SET @CRITERIA_MUTANUS := 11905;
+SET @CRITERIA_HEROD := 11906;
+SET @CRITERIA_LUCIFRON := 11907;
+SET @CRITERIA_THUNDERAAN := 11908;
+SET @CRITERIA_CHROMAGGUS := 11909;
+SET @CRITERIA_HAKKAR := 11910;
+SET @CRITERIA_VEKNILASH := 11911;
+SET @CRITERIA_KALITHRESH := 11912;
+SET @CRITERIA_MALCHEZAAR := 11913;
+SET @CRITERIA_GRUUL := 11914;
+SET @CRITERIA_VASHJ := 11915;
+SET @CRITERIA_ARCHIMONDE := 11916;
+SET @CRITERIA_ILLIDAN := 11917;
+SET @CRITERIA_DELRISSA := 11918;
+SET @CRITERIA_MURU := 11919;
+SET @CRITERIA_INGVAR := 11920;
+SET @CRITERIA_CYANIGOSA := 11921;
+SET @CRITERIA_ECK := 11922;
+SET @CRITERIA_ONYXIA := 11923;
+SET @CRITERIA_HEIGAN := 11924;
+SET @CRITERIA_IGNIS := 11925;
+SET @CRITERIA_VEZAX := 11926;
+SET @CRITERIA_ALGALON := 11927;
+
+DELETE FROM `achievement_criteria_data` WHERE `criteria_id` IN (@CRITERIA_HOGGER,@CRITERIA_VANCLEEF,@CRITERIA_MUTANUS,@CRITERIA_HEROD,@CRITERIA_LUCIFRON,@CRITERIA_THUNDERAAN,@CRITERIA_CHROMAGGUS,@CRITERIA_HAKKAR,@CRITERIA_VEKNILASH,@CRITERIA_KALITHRESH,@CRITERIA_MALCHEZAAR,@CRITERIA_GRUUL,@CRITERIA_VASHJ,@CRITERIA_ARCHIMONDE,@CRITERIA_ILLIDAN,@CRITERIA_DELRISSA,@CRITERIA_MURU,@CRITERIA_INGVAR,@CRITERIA_CYANIGOSA,@CRITERIA_ECK,@CRITERIA_ONYXIA,@CRITERIA_HEIGAN,@CRITERIA_IGNIS,@CRITERIA_VEZAX,@CRITERIA_ALGALON);
+INSERT INTO `achievement_criteria_data` (`criteria_id`,`type`,`value1`) VALUES
+(@CRITERIA_HOGGER,1,34942),
+(@CRITERIA_VANCLEEF,1,35028),
+(@CRITERIA_MUTANUS,1,35029),
+(@CRITERIA_HEROD,1,35030),
+(@CRITERIA_LUCIFRON,1,35031),
+(@CRITERIA_THUNDERAAN,1,35032),
+(@CRITERIA_CHROMAGGUS,1,35033),
+(@CRITERIA_HAKKAR,1,35034),
+(@CRITERIA_VEKNILASH,1,35036),
+(@CRITERIA_KALITHRESH,1,35037),
+(@CRITERIA_MALCHEZAAR,1,35038),
+(@CRITERIA_GRUUL,1,35039),
+(@CRITERIA_VASHJ,1,35040),
+(@CRITERIA_ARCHIMONDE,1,35041),
+(@CRITERIA_ILLIDAN,1,35042),
+(@CRITERIA_DELRISSA,1,35043),
+(@CRITERIA_MURU,1,35044),
+(@CRITERIA_INGVAR,1,35045),
+(@CRITERIA_CYANIGOSA,1,35046),
+(@CRITERIA_ECK,1,35047),
+(@CRITERIA_ONYXIA,1,35048),
+(@CRITERIA_HEIGAN,1,35049),
+(@CRITERIA_IGNIS,1,35050),
+(@CRITERIA_VEZAX,1,35051),
+(@CRITERIA_ALGALON,1,35052);
+
+-- Correcting Paletress' speed values on heroic mode
+UPDATE `creature_template` SET `speed_walk`=2,`speed_run`=1.42857 WHERE `entry`=35517;
+
+-- Correcting Paletress' mechanic immunities
+-- she is interruptable
+UPDATE `creature_template` SET `mechanic_immune_mask`=617299839 WHERE `entry` IN (34928,35517);
+
+-- Paletress' Memory adds are missing mechanic immunities
+UPDATE `creature_template` SET `mechanic_immune_mask`=650854271 WHERE `entry`=34942 OR `entry` BETWEEN 35028 AND 35052 OR `entry` BETWEEN 35519 AND 35525 OR `entry` BETWEEN 35527 AND 35544;
+
+-- Correcting Eadric' mechanic immunities
+UPDATE `creature_template` SET `mechanic_immune_mask`=650854271 WHERE `entry` IN (35119,35518);
+
+-- Eadric' Vengeance spell should have internal cooldown and procChance
+-- Proc spell should properly be removed on successful melee crit
+DELETE FROM `spell_proc_event` WHERE `entry` IN (66865,66889);
+INSERT INTO `spell_proc_event` (`entry`,`procFlags`,`procEx`,`CustomChance`,`Cooldown`) VALUES 
+(66865,4,0,20,10),
+(66889,4,2,0,0);
+-- Also the proc spell of Vengeance should not remove original aura
+DELETE FROM `spell_linked_spell` WHERE `spell_trigger`=66889 AND `spell_effect`=-66865;
+
+-- Player casted Hammer of the Righteous to Eadric should remove the dummy aura from player on cast
+DELETE FROM `spell_linked_spell` WHERE `spell_trigger`=66905 AND `spell_effect`=-66904;
+INSERT INTO `spell_linked_spell` VALUES (66905,-66904,0,'Eadric - Remove dummy aura from player on cast');
+
+--
+-- The Black Knight
+--
+
+-- Variables
+SET @KNIGHT := 35451;
+SET @KNIGHT_H := 35490;
+SET @KNIGHT_VEHICLE := 35491;
+SET @RISEN_CHAMP := 35590;
+SET @RISEN_CHAMP_H := 35717;
+
+-- The Black Knight's vehicle must have flight inhabit type
+UPDATE `creature_template` SET `InhabitType`=7 WHERE `entry`=@KNIGHT_VEHICLE;
+
+-- Risen Champion is missing scriptname
+UPDATE `creature_template` SET `ScriptName`='npc_risen_ghoul' WHERE `entry`=@RISEN_CHAMP;
+
+-- Risen Champions (not Risen Herald) and The Black Knight should award reputation on kill
+DELETE FROM `creature_onkill_reputation` WHERE `creature_id` IN (@RISEN_CHAMP,@RISEN_CHAMP_H,@KNIGHT,@KNIGHT_H);
+INSERT INTO `creature_onkill_reputation` VALUES
+(@RISEN_CHAMP,1037,1052,7,0,5,7,0,5,1),
+(@RISEN_CHAMP_H,1037,1052,7,0,10,7,0,10,1),
+(@KNIGHT,1037,1052,7,0,195,7,0,195,1),
+(@KNIGHT_H,1037,1052,7,0,390,7,0,390,1);
+
+-- Correcting The Black Knight's mechanic immunities
+UPDATE `creature_template` SET `mechanic_immune_mask`=650854271 WHERE `entry` IN (@KNIGHT,@KNIGHT_H);
+
+-- The Black Knight should have money drop
+UPDATE `creature_template` SET `mingold`=4921,`maxgold`=10294 WHERE `entry`=@KNIGHT;
+UPDATE `creature_template` SET `mingold`=14691,`maxgold`=21952 WHERE `entry`=@KNIGHT_H;
+
+-- Achievement criteria script for achievement id 3804
+DELETE FROM `achievement_criteria_data` WHERE `type` IN (11, 18) AND `criteria_id`=11789;
+INSERT INTO `achievement_criteria_data` (`criteria_id`,`type`,`ScriptName`) VALUES
+(11789,11,'achievement_ive_had_worse');
+
+
+DELETE FROM `conditions` WHERE `SourceTypeOrReferenceId`=13 AND `SourceEntry` IN (66905, 66798, 67751);
+INSERT INTO `conditions` (`SourceTypeOrReferenceId`, `SourceGroup`, `SourceEntry`, `SourceId`, `ElseGroup`, `ConditionTypeOrReference`, `ConditionTarget`, `ConditionValue1`, `ConditionValue2`, `ConditionValue3`, `NegativeCondition`, `ErrorType`, `ErrorTextId`, `ScriptName`, `Comment`) VALUES 
+(13, 7, 66905, 0, 0, 31, 0, 3, 35119, 0, 0, 0, 0, '', 'Hammer of the Righteous (Eadric the Pure)'),
+(13, 1, 66798, 0, 0, 31, 0, 3, 35004, 0, 0, 0, 0, '', 'Death''s Respite (The Black Knight)'),
+(13, 1, 66798, 0, 1, 31, 0, 3, 35005, 0, 0, 0, 0, '', 'Death''s Respite (The Black Knight)'),
+(13, 7, 67751, 0, 0, 31, 0, 3, 35590, 0, 0, 0, 0, '', 'Ghoul Explode (The Black Knight)'),
+(13, 7, 67751, 0, 0,  1, 0, 67751, 0, 0, 1, 0, 0, '', 'Ghoul Explode (The Black Knight)');
diff --git a/src/server/game/Spells/SpellEffects.cpp b/src/server/game/Spells/SpellEffects.cpp
index 2a9db6f..3eab37b 100644
--- a/src/server/game/Spells/SpellEffects.cpp
+++ b/src/server/game/Spells/SpellEffects.cpp
@@ -4818,7 +4818,10 @@ void Spell::EffectLeapBack(SpellEffIndex effIndex)
     float speedxy = m_spellInfo->Effects[effIndex].MiscValue / 10.f;
     float speedz = damage/ 10.f;
     //1891: Disengage
-    m_caster->JumpTo(speedxy, speedz, m_spellInfo->SpellIconID != 1891);
+    //4022: Rolling Throw
+    m_caster->JumpTo(speedxy, speedz, (m_spellInfo->SpellIconID != 1891 && m_spellInfo->SpellIconID != 4022));
+    if (m_spellInfo->SpellIconID == 4022)
+        unitTarget->JumpTo(speedxy, speedz);
 }
 
 void Spell::EffectQuestClear(SpellEffIndex effIndex)
diff --git a/src/server/game/Spells/SpellMgr.cpp b/src/server/game/Spells/SpellMgr.cpp
index 50f750f..cadb9b2 100644
--- a/src/server/game/Spells/SpellMgr.cpp
+++ b/src/server/game/Spells/SpellMgr.cpp
@@ -84,6 +84,15 @@ DiminishingGroup GetDiminishingReturnsGroupForSpell(SpellInfo const* spellproto,
             // Screams of the Dead (King Ymiron)
             else if (spellproto->Id == 51750)
                 return DIMINISHING_NONE;
+            // Triggered trample aura (ToC 5)
+            else if (spellproto->Id == 67868)
+                return DIMINISHING_NONE;
+            // The Black Knight's Death's Respite (ToC 5)
+            else if (spellproto->Id == 67745)
+                return DIMINISHING_NONE;
+            // The Black Knight's Death's Respite (Heroic ToC 5)
+            else if (spellproto->Id == 68306)
+                return DIMINISHING_NONE;
             break;
         }
         // Event spells
@@ -3346,6 +3355,32 @@ void SpellMgr::LoadSpellInfoCorrections()
                 //! HACK: This spell break quest complete for alliance and on retail not used Â°_O
                 spellInfo->Effects[EFFECT_0].Effect = 0;
                 break;
+            // TRIAL OF THE CHAMPION SPELLS
+            //
+            case 67546: // Warrior Grand Champion - Rolling Throw
+                // Should hit both caster and target
+                spellInfo->Effects[EFFECT_0].TargetB = SpellImplicitTargetInfo(TARGET_UNIT_TARGET_ENEMY);
+                break;
+            case 66797: // The Black Knight - Death's Push (casted on announcer)
+                // The duration is correct otherwise but announcer dies currently in mid-air
+                // this happens because blizzard has 100-200ms delay before applying an aura
+                // so in retail announcer makes it on the ground before dying
+                spellInfo->DurationEntry = sSpellDurationStore.LookupEntry(39); // 2 seconds instead of 1.7 seconds
+                break;
+            case 67779: // The Black Knight - Desecration
+                // According to several videos the desecration players lose the desecration debuff in 12 seconds of cast
+                // There is an invisible stalker triggering every 2 seconds a desecration debuff
+                // so setting 10 second duration is correct
+                // besides the visual desecration on the ground disappears in 10 seconds of cast
+                spellInfo->DurationEntry = sSpellDurationStore.LookupEntry(1); // 10 seconds instead of 15 seconds
+                break;
+            case 67802: // The Black Knight - Desecration Arm
+                // in 3.3.5 there is only one radius in dbc which is 0 yards in this case
+                // use max radius from 4.3.4
+                spellInfo->Effects[EFFECT_0].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_7_YARDS);
+                break;
+            // ENDOF TRIAL OF THE CHAMPION SPELLS
+            //
             // VIOLET HOLD SPELLS
             //
             case 54258: // Water Globule (Ichoron)
diff --git a/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheChampion/boss_argent_challenge.cpp b/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheChampion/boss_argent_challenge.cpp
index 15d1535..3c2deae 100644
--- a/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheChampion/boss_argent_challenge.cpp
+++ b/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheChampion/boss_argent_challenge.cpp
@@ -17,61 +17,115 @@
 
 /* ScriptData
 SDName: Argent Challenge Encounter.
-SD%Complete: 50 %
-SDComment: AI for Argent Soldiers are not implemented. AI from bosses need more improvements.
+SD%Complete: 100%
+SDComment:
 SDCategory: Trial of the Champion
 EndScriptData */
 
+#include "Player.h"
 #include "ScriptMgr.h"
 #include "ScriptedCreature.h"
 #include "SpellScript.h"
 #include "trial_of_the_champion.h"
-#include "ScriptedEscortAI.h"
-/*
+
 enum Yells
 {
     // Eadric the Pure
-    SAY_INTRO                   = 0,
-    SAY_AGGRO                   = 1,
+    SAY_AGGRO_E                 = 1,
     EMOTE_RADIANCE              = 2,
     EMOTE_HAMMER_RIGHTEOUS      = 3,
     SAY_HAMMER_RIGHTEOUS        = 4,
-    SAY_KILL_PLAYER             = 5,
-    SAY_DEFEATED                = 6,
+    SAY_KILL_UNIT_E             = 5,
+    SAY_DEFEATED_E              = 6,
 
     // Argent Confessor Paletress
-    SAY_INTRO_1                 = 0,
-    SAY_INTRO_2                 = 1,
-    SAY_AGGRO                   = 2,
+    SAY_AGGRO_P                 = 2,
     SAY_MEMORY_SUMMON           = 3,
     SAY_MEMORY_DEATH            = 4,
-    SAY_KILL_PLAYER             = 5,
-    SAY_DEFEATED                = 6,
+    SAY_KILL_UNIT_P             = 5,
+    SAY_DEFEATED_P              = 6,
 
     // Memory of X
     EMOTE_WAKING_NIGHTMARE      = 0
 };
-*/
+
+enum Events
+{
+    // Argent Lightwielder
+    EVENT_BLAZING_LIGHT         = 1,
+    EVENT_CLEAVE,
+    EVENT_UNBALANCING_STRIKE,
+    // Argent Monk
+    EVENT_FLURRY_OF_BLOWS,
+    EVENT_PUMMEL,
+    // Argent Priestess
+    EVENT_HOLY_SMITE,
+    EVENT_SHADOW_WORD_PAIN,
+    EVENT_FOUNTAIN,
+    EVENT_FOUNTAIN_DUMMY,
+    EVENT_MIND_CONTROL,
+    // Argent Confessor Paletress
+    EVENT_HOLY_FIRE,
+    EVENT_HOLY_SMITE_E,
+    EVENT_RENEW,
+    EVENT_SUMMON_MEMORY,
+    EVENT_PALETRESS_DONE,
+    // Memory
+    EVENT_ENTER_AGGRESSIVE,
+    EVENT_OLD_WOUNDS,
+    EVENT_SHADOWS_PAST,
+    EVENT_WAKING_NIGHTMARE,
+    // Eadric the Pure
+    EVENT_VENGEANCE,
+    EVENT_RADIANCE,
+    EVENT_HAMMER_OF_JUSTICE,
+    EVENT_EADRIC_DONE
+};
+
 enum Spells
 {
+    // Argent Lightwielder
+    SPELL_BLAZING_LIGHT         = 67247,
+    SPELL_CLEAVE                = 15284,
+    SPELL_UNBALANCING_STRIKE    = 67237,
+
+    // Argent Monk
+    SPELL_FLURRY_OF_BLOWS       = 67233,
+    SPELL_PUMMEL                = 67235,
+    SPELL_DIVINE_SHIELD         = 67251,
+    SPELL_FINAL_MEDITATION      = 67255,
+
+    // Argent Priestess
+    SPELL_HOLY_SMITE            = 36176,
+    SPELL_HOLY_SMITE_H          = 67289,
+    SPELL_SHADOW_WORD_PAIN      = 34941,
+    SPELL_SHADOW_WORD_PAIN_H    = 34942,
+    SPELL_MIND_CONTROL          = 67229,
+    SPELL_SUMMON_FOUNTAIN       = 67194,
+    SPELL_FOUNTAIN_DUMMY_HEAL   = 67196,
+
     // Eadric the Pure
-    SPELL_EADRIC_ACHIEVEMENT    = 68197,
+    SPELL_EADRIC_FACEROLLER     = 68197,
     SPELL_HAMMER_JUSTICE        = 66863,
+    SPELL_HAMMER_JUSTICE_STUN   = 66940,
     SPELL_HAMMER_RIGHTEOUS      = 66867,
+    SPELL_HAMMER_RIGHT_DUMMY    = 66904,
+    SPELL_HAMMER_RIGHTEOUS_PLR  = 66905,
     SPELL_RADIANCE              = 66935,
     SPELL_VENGEANCE             = 66865,
+    SPELL_EADRIC_ACH            = 68575, // dummy spell for achievement credit (IDs 4297, 4298, 3778, 4296)
 
     // Paletress
+    SPELL_PALETRESS_CONFESSOR   = 68206, // achievement id 3802
     SPELL_SMITE                 = 66536,
-    SPELL_SMITE_H               = 67674,
     SPELL_HOLY_FIRE             = 66538,
-    SPELL_HOLY_FIRE_H           = 67676,
     SPELL_RENEW                 = 66537,
-    SPELL_RENEW_H               = 67675,
     SPELL_HOLY_NOVA             = 66546,
     SPELL_SHIELD                = 66515,
+    SPELL_SHIELD_REFLECT        = 33619,
     SPELL_CONFESS               = 66680,
     SPELL_SUMMON_MEMORY         = 66545,
+    SPELL_PALETRESS_ACH         = 68574, // dummy spell for achievement credit (IDs 4297, 4298, 3778, 4296)
 
     // Memory of X (Summon)
     SPELL_MEMORY_ALGALON        = 66715,
@@ -101,44 +155,38 @@ enum Spells
     SPELL_MEMORY_VEZAX          = 66714,
 
     // Memory
+    SPELL_SHADOWFORM            = 41408,
+    SPELL_SPAWN_VISUAL          = 66675,
     SPELL_OLD_WOUNDS            = 66620,
-    SPELL_OLD_WOUNDS_H          = 67679,
     SPELL_SHADOWS_PAST          = 66619,
-    SPELL_SHADOWS_PAST_H        = 67678,
-    SPELL_WAKING_NIGHTMARE      = 66552,
-    SPELL_WAKING_NIGHTMARE_H    = 67677
+    SPELL_WAKING_NIGHTMARE      = 66552
 };
 
-class OrientationCheck : public std::unary_function<Unit*, bool>
+enum PointMovement
 {
-    public:
-        explicit OrientationCheck(Unit* _caster) : caster(_caster) { }
-        bool operator()(WorldObject* object)
-        {
-            return !object->isInFront(caster, 2.5f) || !object->IsWithinDist(caster, 40.0f);
-        }
-
-    private:
-        Unit* caster;
+    POINT_PREFIGHT              = 0,
+    POINT_PREPARE,
+    POINT_DESPAWN
 };
 
 class spell_eadric_radiance : public SpellScriptLoader
 {
     public:
         spell_eadric_radiance() : SpellScriptLoader("spell_eadric_radiance") { }
+
         class spell_eadric_radiance_SpellScript : public SpellScript
         {
             PrepareSpellScript(spell_eadric_radiance_SpellScript);
 
-            void FilterTargets(std::list<WorldObject*>& unitList)
+            void FilterTargets(std::list<WorldObject*>& targets)
             {
-                unitList.remove_if(OrientationCheck(GetCaster()));
+                Unit* caster = GetCaster();
+                targets.remove_if([caster](WorldObject* target) { return !target->isInFront(caster, 2.5f); });
             }
 
             void Register() override
             {
-                OnObjectAreaTargetSelect += SpellObjectAreaTargetSelectFn(spell_eadric_radiance_SpellScript::FilterTargets, EFFECT_0, TARGET_UNIT_SRC_AREA_ENEMY);
-                OnObjectAreaTargetSelect += SpellObjectAreaTargetSelectFn(spell_eadric_radiance_SpellScript::FilterTargets, EFFECT_1, TARGET_UNIT_SRC_AREA_ENEMY);
+                OnObjectAreaTargetSelect += SpellObjectAreaTargetSelectFn(spell_eadric_radiance_SpellScript::FilterTargets, EFFECT_ALL, TARGET_UNIT_SRC_AREA_ENEMY);
             }
         };
 
@@ -152,38 +200,26 @@ class boss_eadric : public CreatureScript
 {
 public:
     boss_eadric() : CreatureScript("boss_eadric") { }
-    struct boss_eadricAI : public ScriptedAI
+
+    struct boss_eadricAI : public BossAI
     {
-        boss_eadricAI(Creature* creature) : ScriptedAI(creature)
+        boss_eadricAI(Creature* creature) : BossAI(creature, DATA_EADRIC_THE_PURE)
         {
-            Initialize();
-            instance = creature->GetInstanceScript();
-            creature->SetReactState(REACT_PASSIVE);
-            creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+            me->SetReactState(REACT_DEFENSIVE);
         }
 
-        void Initialize()
-        {
-            uiVenganceTimer = 10000;
-            uiRadianceTimer = 16000;
-            uiHammerJusticeTimer = 25000;
-            uiResetTimer = 5000;
+        ObjectGuid faceRollerGUID;
 
-            bDone = false;
+        void Reset() override
+        {
+            if (instance->GetBossState(DATA_EADRIC_THE_PURE) != SPECIAL)
+                _Reset();
         }
 
-        InstanceScript* instance;
-
-        uint32 uiVenganceTimer;
-        uint32 uiRadianceTimer;
-        uint32 uiHammerJusticeTimer;
-        uint32 uiResetTimer;
-
-        bool bDone;
-
-        void Reset() override
+        void SetFacerollerPlayer(ObjectGuid playerGuid)
         {
-            Initialize();
+            if (instance->GetBossState(DATA_EADRIC_THE_PURE) != SPECIAL)
+                faceRollerGUID = playerGuid;
         }
 
         void DamageTaken(Unit* /*done_by*/, uint32 &damage) override
@@ -191,61 +227,119 @@ class boss_eadric : public CreatureScript
             if (damage >= me->GetHealth())
             {
                 damage = 0;
-                EnterEvadeMode();
-                me->setFaction(35);
-                bDone = true;
+                if (instance->GetBossState(DATA_EADRIC_THE_PURE) != SPECIAL)
+                {
+                    events.Reset();
+                    instance->SetBossState(DATA_EADRIC_THE_PURE, SPECIAL);
+                    Talk(SAY_DEFEATED_E);
+                }
+                return;
             }
         }
 
-        void MovementInform(uint32 MovementType, uint32 /*Data*/) override
+        void JustReachedHome() override
+        {
+            if (instance->GetBossState(DATA_EADRIC_THE_PURE) == SPECIAL)
+                events.ScheduleEvent(EVENT_EADRIC_DONE, 4000);
+            else
+                me->SetUInt32Value(UNIT_NPC_EMOTESTATE, EMOTE_STATE_READY1H);
+        }
+
+        void MovementInform(uint32 type, uint32 id) override
         {
-            if (MovementType != POINT_MOTION_TYPE)
+            if (type != POINT_MOTION_TYPE)
                 return;
 
-            instance->SetData(BOSS_ARGENT_CHALLENGE_E, DONE);
+            switch (id)
+            {
+                case POINT_PREFIGHT:
+                    if (Creature* announcer = instance->GetCreature(DATA_ANNOUNCER))
+                        announcer->AI()->SetData(DATA_ARGENT_CHAMPION_PREPARE, 0);
+                    break;
+                case POINT_PREPARE:
+                    me->SetWalk(false);
+                    me->SetUInt32Value(UNIT_NPC_EMOTESTATE, EMOTE_STATE_READY1H);
+                    break;
+                case POINT_DESPAWN:
+                    me->DisappearAndDie();
+                    break;
+                default:
+                    break;
+            }
+        }
+
+        void EnterCombat(Unit* who) override
+        {
+            if (instance->GetBossState(DATA_EADRIC_THE_PURE) != SPECIAL)
+            {
+                events.ScheduleEvent(EVENT_VENGEANCE, 500);
+                events.ScheduleEvent(EVENT_RADIANCE, urand(7000, 15000));
+                Talk(SAY_AGGRO_E, who);
+                _EnterCombat();
+            }
+        }
+
+        void KilledUnit(Unit* who) override
+        {
+            Talk(SAY_KILL_UNIT_E, who);
+        }
 
-            me->DisappearAndDie();
+        void AttackStart(Unit* who) override
+        {
+            if (instance->GetBossState(DATA_EADRIC_THE_PURE) != SPECIAL)
+                BossAI::AttackStart(who);
         }
 
         void UpdateAI(uint32 uiDiff) override
         {
-            if (bDone && uiResetTimer <= uiDiff)
-            {
-                me->GetMotionMaster()->MovePoint(0, 746.87f, 665.87f, 411.75f);
-                bDone = false;
-            } else uiResetTimer -= uiDiff;
+            events.Update(uiDiff);
 
-            if (!UpdateVictim())
+            if (me->HasUnitState(UNIT_STATE_CASTING))
                 return;
 
-            if (uiHammerJusticeTimer <= uiDiff)
+            while (uint32 eventId = events.ExecuteEvent())
             {
-                me->InterruptNonMeleeSpells(true);
-
-                if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 0, 250, true))
+                switch (eventId)
                 {
-                    if (target && target->IsAlive())
-                    {
-                        DoCast(target, SPELL_HAMMER_JUSTICE);
-                        DoCast(target, SPELL_HAMMER_RIGHTEOUS);
-                    }
+                    case EVENT_VENGEANCE:
+                        if (!me->HasAura(SPELL_VENGEANCE))
+                            DoCast(me, SPELL_VENGEANCE);
+                        events.ScheduleEvent(EVENT_VENGEANCE, 30000);
+                        break;
+                    case EVENT_RADIANCE:
+                        DoCastAOE(SPELL_RADIANCE);
+                        Talk(EMOTE_RADIANCE);
+                        events.ScheduleEvent(EVENT_HAMMER_OF_JUSTICE, urand(20000, 30000));
+                        break;
+                    case EVENT_HAMMER_OF_JUSTICE:
+                        if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 0, 100.0f, true))
+                        {
+                            DoCast(target, SPELL_HAMMER_JUSTICE, true);
+                            DoCast(target, SPELL_HAMMER_RIGHTEOUS);
+                            Talk(EMOTE_HAMMER_RIGHTEOUS, target);
+                            Talk(SAY_HAMMER_RIGHTEOUS);
+                        }
+                        events.ScheduleEvent(EVENT_RADIANCE, urand(7000, 15000));
+                        break;
+                    case EVENT_EADRIC_DONE:
+                        me->RemoveAllAuras();
+                        me->DeleteThreatList();
+                        me->SetFullHealth();
+                        me->RestoreFaction();
+                        instance->DoUpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_BE_SPELL_TARGET, SPELL_EADRIC_ACH, 0, me);
+                        if (Player* player = ObjectAccessor::GetPlayer(*me, faceRollerGUID))
+                            player->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_BE_SPELL_TARGET, SPELL_EADRIC_FACEROLLER, 0, me);
+                        _JustDied();
+                        me->SetWalk(true);
+                        me->GetMotionMaster()->MovePoint(POINT_DESPAWN, bossExitPos);
+                        break;
+                    default:
+                        break;
                 }
-                uiHammerJusticeTimer = 25000;
-            } else uiHammerJusticeTimer -= uiDiff;
-
-            if (uiVenganceTimer <= uiDiff)
-            {
-                DoCast(me, SPELL_VENGEANCE);
-
-                uiVenganceTimer = 10000;
-            } else uiVenganceTimer -= uiDiff;
-
-            if (uiRadianceTimer <= uiDiff)
-            {
-                DoCastAOE(SPELL_RADIANCE);
+            }
 
-                uiRadianceTimer = 16000;
-            } else uiRadianceTimer -= uiDiff;
+            if (!UpdateVictim())
+                return;
 
             DoMeleeAttackIfReady();
         }
@@ -262,155 +356,200 @@ class boss_paletress : public CreatureScript
 public:
     boss_paletress() : CreatureScript("boss_paletress") { }
 
-    struct boss_paletressAI : public ScriptedAI
+    struct boss_paletressAI : public BossAI
     {
-        boss_paletressAI(Creature* creature) : ScriptedAI(creature)
+        boss_paletressAI(Creature* creature) : BossAI(creature, DATA_ARGENT_CONFESSOR_PALETRESS)
         {
             Initialize();
-            instance = creature->GetInstanceScript();
 
-            creature->SetReactState(REACT_PASSIVE);
-            creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
-            creature->RestoreFaction();
+            me->SetReactState(REACT_DEFENSIVE);
         }
 
         void Initialize()
         {
-            uiHolyFireTimer = urand(9000, 12000);
-            uiHolySmiteTimer = urand(5000, 7000);
-            uiRenewTimer = urand(2000, 5000);
-
-            uiResetTimer = 7000;
-
-            bHealth = false;
-            bDone = false;
+            bMemory = false;
         }
 
-        InstanceScript* instance;
         ObjectGuid MemoryGUID;
-
-        bool bHealth;
-        bool bDone;
-
-        uint32 uiHolyFireTimer;
-        uint32 uiHolySmiteTimer;
-        uint32 uiRenewTimer;
-        uint32 uiResetTimer;
+        bool bMemory;
 
         void Reset() override
         {
-            me->RemoveAllAuras();
-
-            Initialize();
-
-            if (Creature* pMemory = ObjectAccessor::GetCreature(*me, MemoryGUID))
-                if (pMemory->IsAlive())
-                    pMemory->RemoveFromWorld();
+            if (instance->GetBossState(DATA_ARGENT_CONFESSOR_PALETRESS) != SPECIAL)
+            {
+                me->RemoveAura(SPELL_SHIELD);
+                Initialize();
+                _Reset();
+            }
         }
 
         void SetData(uint32 uiId, uint32 /*uiValue*/) override
         {
             if (uiId == 1)
+            {
+                me->InterruptNonMeleeSpells(true);
+                Talk(SAY_MEMORY_DEATH);
+                me->GetMotionMaster()->Clear();
                 me->RemoveAura(SPELL_SHIELD);
+            }
         }
 
         void DamageTaken(Unit* /*done_by*/, uint32 &damage) override
         {
+            if (!bMemory && !HealthAbovePct(25))
+            {
+                me->InterruptNonMeleeSpells(true);
+                DoCastAOE(SPELL_HOLY_NOVA, false);
+                Talk(SAY_MEMORY_SUMMON);
+                DoCast(me, SPELL_SHIELD);
+                DoCastAOE(SPELL_CONFESS, false);
+                me->AttackStop();
+                events.ScheduleEvent(EVENT_SUMMON_MEMORY, 2000);
+
+                bMemory = true;
+            }
+            
             if (damage >= me->GetHealth())
             {
                 damage = 0;
-                EnterEvadeMode();
-                me->setFaction(35);
-                bDone = true;
+                if (instance->GetBossState(DATA_ARGENT_CONFESSOR_PALETRESS) != SPECIAL)
+                {
+                    events.Reset();
+                    instance->SetBossState(DATA_ARGENT_CONFESSOR_PALETRESS, SPECIAL);
+                    Talk(SAY_DEFEATED_P);
+                }
+                return;
             }
         }
 
-        void MovementInform(uint32 MovementType, uint32 Point) override
+        void JustReachedHome() override
+        {
+            if (instance->GetBossState(DATA_ARGENT_CONFESSOR_PALETRESS) == SPECIAL)
+                events.ScheduleEvent(EVENT_PALETRESS_DONE, 4000);
+            else
+                me->SetUInt32Value(UNIT_NPC_EMOTESTATE, EMOTE_STATE_READY1H);
+        }
+
+        void MovementInform(uint32 type, uint32 id) override
         {
-            if (MovementType != POINT_MOTION_TYPE || Point != 0)
+            if (type != POINT_MOTION_TYPE)
                 return;
 
-            instance->SetData(BOSS_ARGENT_CHALLENGE_P, DONE);
+            switch (id)
+            {
+                case POINT_PREFIGHT:
+                    if (Creature* announcer = instance->GetCreature(DATA_ANNOUNCER))
+                        announcer->AI()->SetData(DATA_ARGENT_CHAMPION_PREPARE, 0);
+                    break;
+                case POINT_PREPARE:
+                    me->SetWalk(false);
+                    me->SetUInt32Value(UNIT_NPC_EMOTESTATE, EMOTE_STATE_READY1H);
+                    break;
+                case POINT_DESPAWN:
+                    me->DisappearAndDie();
+                    break;
+                default:
+                    break;
+            }
+        }
+
+        void JustSummoned(Creature* summon) override
+        {
+            MemoryGUID = summon->GetGUID();
+            me->GetMotionMaster()->MoveFollow(summon, 30.0f, 0.0f);
+        }
 
-            me->DisappearAndDie();
+        void SummonedCreatureDespawn(Creature* summon) override
+        {
+            summons.Despawn(summon);
         }
 
-        void UpdateAI(uint32 uiDiff) override
+        void EnterCombat(Unit* who) override
         {
-            if (bDone && uiResetTimer <= uiDiff)
+            if (instance->GetBossState(DATA_ARGENT_CONFESSOR_PALETRESS) != SPECIAL)
             {
-                me->GetMotionMaster()->MovePoint(0, 746.87f, 665.87f, 411.75f);
-                bDone = false;
-            } else uiResetTimer -= uiDiff;
+                events.ScheduleEvent(EVENT_HOLY_SMITE_E, 2000);
+                events.ScheduleEvent(EVENT_HOLY_FIRE, urand(9000, 12000));
+                events.ScheduleEvent(EVENT_RENEW, urand(15000, 17000));
+                Talk(SAY_AGGRO_P, who);
+                _EnterCombat();
+            }
+        }
 
-            if (!UpdateVictim())
-                return;
+        void KilledUnit(Unit* who) override
+        {
+            Talk(SAY_KILL_UNIT_P, who);
+        }
 
-            if (uiHolyFireTimer <= uiDiff)
-            {
-                if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 0, 250, true))
-                {
-                    if (target && target->IsAlive())
-                        DoCast(target, SPELL_HOLY_FIRE);
-                }
-                 if (me->HasAura(SPELL_SHIELD))
-                    uiHolyFireTimer = 13000;
-                else
-                    uiHolyFireTimer = urand(9000, 12000);
-            } else uiHolyFireTimer -= uiDiff;
+        void AttackStart(Unit* who) override
+        {
+            if (!me->HasAura(SPELL_SHIELD) && instance->GetBossState(DATA_ARGENT_CONFESSOR_PALETRESS) != SPECIAL)
+                BossAI::AttackStart(who);
+        }
 
-            if (uiHolySmiteTimer <= uiDiff)
-            {
-                if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 0, 250, true))
-                {
-                    if (target && target->IsAlive())
-                        DoCast(target, SPELL_SMITE);
-                }
-                if (me->HasAura(SPELL_SHIELD))
-                    uiHolySmiteTimer = 9000;
-                else
-                    uiHolySmiteTimer = urand(5000, 7000);
-            } else uiHolySmiteTimer -= uiDiff;
+        void UpdateAI(uint32 uiDiff) override
+        {
+            events.Update(uiDiff);
 
-            if (me->HasAura(SPELL_SHIELD))
+            while (uint32 eventId = events.ExecuteEvent())
             {
-                if (uiRenewTimer <= uiDiff)
+                switch (eventId)
                 {
-                    me->InterruptNonMeleeSpells(true);
-                    uint8 uiTarget = urand(0, 1);
-                    switch (uiTarget)
-                    {
-                        case 0:
+                    case EVENT_HOLY_SMITE_E:
+                        if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 0, 50.0f, true))
+                            DoCast(target, SPELL_SMITE);
+                        events.ScheduleEvent(EVENT_HOLY_SMITE_E, urand(2000, 3000));
+                        break;
+                    case EVENT_HOLY_FIRE:
+                        if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 0, 30.0f, true))
+                            DoCast(target, SPELL_HOLY_FIRE);
+                        events.ScheduleEvent(EVENT_HOLY_FIRE, urand(9000, 12000));
+                        break;
+                    case EVENT_RENEW:
+                        me->InterruptNonMeleeSpells(true);
+                        if (rand32() % 2 && me->GetHealthPct() < 100)
                             DoCast(me, SPELL_RENEW);
-                            break;
-                        case 1:
-                            if (Creature* pMemory = ObjectAccessor::GetCreature(*me, MemoryGUID))
-                                if (pMemory->IsAlive())
-                                    DoCast(pMemory, SPELL_RENEW);
-                            break;
-                    }
-                    uiRenewTimer = urand(15000, 17000);
-                } else uiRenewTimer -= uiDiff;
+                        else
+                        {
+                            Creature* pMemory = ObjectAccessor::GetCreature(*me, MemoryGUID);
+                            if (pMemory && pMemory->GetHealth() > 1)
+                                DoCast(pMemory, SPELL_RENEW);
+                            else
+                                DoCast(me, SPELL_RENEW);
+                        }
+                        events.ScheduleEvent(EVENT_RENEW, urand(15000, 17000));
+                        break;
+                    case EVENT_SUMMON_MEMORY:
+                        // Memory spawns at random player's position
+                        if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 0, 50.0f, true))
+                            DoCast(target, SPELL_SUMMON_MEMORY, true);
+                        break;
+                    case EVENT_PALETRESS_DONE:
+                        me->RemoveAllAuras();
+                        me->DeleteThreatList();
+                        me->SetFullHealth();
+                        me->RestoreFaction();
+                        instance->DoUpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_BE_SPELL_TARGET, SPELL_PALETRESS_ACH, 0, me);
+                        if (Creature* memory = ObjectAccessor::GetCreature(*me, MemoryGUID))
+                        {
+                            if (IsHeroic())
+                                instance->DoUpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_BE_SPELL_TARGET, SPELL_PALETRESS_CONFESSOR, 0, memory);
+                            memory->DisappearAndDie();
+                        }
+                        _JustDied();
+                        me->SetWalk(true);
+                        me->GetMotionMaster()->MovePoint(POINT_DESPAWN, bossExitPos);
+                        break;
+                    default:
+                        break; 
+                }
             }
 
-            if (!bHealth && !HealthAbovePct(25))
-            {
-                me->InterruptNonMeleeSpells(true);
-                DoCastAOE(SPELL_HOLY_NOVA, false);
-                DoCast(me, SPELL_SHIELD);
-                DoCastAOE(SPELL_SUMMON_MEMORY, false);
-                DoCastAOE(SPELL_CONFESS, false);
-
-                bHealth = true;
-            }
+            if (!UpdateVictim())
+                return;
 
             DoMeleeAttackIfReady();
         }
-
-        void JustSummoned(Creature* summon) override
-        {
-            MemoryGUID = summon->GetGUID();
-        }
     };
 
     CreatureAI* GetAI(Creature* creature) const override
@@ -429,64 +568,96 @@ class npc_memory : public CreatureScript
         npc_memoryAI(Creature* creature) : ScriptedAI(creature)
         {
             Initialize();
+            me->SetReactState(REACT_PASSIVE);
         }
 
         void Initialize()
         {
-            uiOldWoundsTimer = 12000;
-            uiShadowPastTimer = 5000;
-            uiWakingNightmare = 7000;
+            DoCast(me, SPELL_SHADOWFORM);
+            DoCast(me, SPELL_SPAWN_VISUAL);
+            events.ScheduleEvent(EVENT_ENTER_AGGRESSIVE, 3000);
         }
 
-        uint32 uiOldWoundsTimer;
-        uint32 uiShadowPastTimer;
-        uint32 uiWakingNightmare;
+        EventMap events;
 
         void Reset() override
         {
+            events.Reset();
             Initialize();
         }
 
-        void UpdateAI(uint32 uiDiff) override
+        void DamageTaken(Unit* /*attacker*/, uint32& damage) override
         {
-            if (!UpdateVictim())
-                return;
-
-            if (uiOldWoundsTimer <= uiDiff)
+            if (damage >= me->GetHealth())
             {
-                if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 0))
+                // We can't make memory despawn yet 
+                // to give correct achievement credit later when Paletress is defeated
+                // so we make him invisible
+                damage = 0;
+                events.Reset();
+                me->SetHealth(1);
+                me->setRegeneratingHealth(false);
+                me->RemoveAllAuras();
+                me->CombatStop(true);
+                me->SetReactState(REACT_PASSIVE);
+                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                me->GetMotionMaster()->MoveIdle();
+                me->SetVisible(false);
+
+                if (TempSummon* summ = me->ToTempSummon())
                 {
-                    if (target && target->IsAlive())
-                        DoCast(target, SPELL_OLD_WOUNDS);
+                    if (Unit* summoner = summ->GetSummoner())
+                        summoner->GetAI()->SetData(1, 0);
                 }
-                uiOldWoundsTimer = 12000;
-            }else uiOldWoundsTimer -= uiDiff;
+            }
+        }
 
-            if (uiWakingNightmare <= uiDiff)
-            {
-                DoCast(me, SPELL_WAKING_NIGHTMARE);
-                uiWakingNightmare = 7000;
-            }else uiWakingNightmare -= uiDiff;
+        void EnterCombat(Unit* /*who*/) override
+        {
+            DoZoneInCombat();
+        }
 
-            if (uiShadowPastTimer <= uiDiff)
+        void UpdateAI(uint32 uiDiff) override
+        {
+            events.Update(uiDiff);
+
+            if (me->HasUnitState(UNIT_STATE_CASTING))
+                return;
+
+            while (uint32 eventId = events.ExecuteEvent())
             {
-                if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 1))
+                switch (eventId)
                 {
-                    if (target && target->IsAlive())
-                        DoCast(target, SPELL_SHADOWS_PAST);
+                    case EVENT_ENTER_AGGRESSIVE:
+                        me->SetReactState(REACT_AGGRESSIVE);
+                        events.ScheduleEvent(EVENT_OLD_WOUNDS, urand(11000, 13000));
+                        events.ScheduleEvent(EVENT_SHADOWS_PAST, 5000);
+                        events.ScheduleEvent(EVENT_WAKING_NIGHTMARE, urand(7000, 10000));
+                        break;
+                    case EVENT_OLD_WOUNDS:
+                        if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 0, 5.0f, true))
+                            DoCast(target, SPELL_OLD_WOUNDS);
+                        events.ScheduleEvent(EVENT_OLD_WOUNDS, urand(11000, 13000));
+                        break;
+                    case EVENT_SHADOWS_PAST:
+                        if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 0, 40.0f, true))
+                            DoCast(target, SPELL_SHADOWS_PAST);
+                        events.ScheduleEvent(EVENT_SHADOWS_PAST, urand(5000, 7000));
+                        break;
+                    case EVENT_WAKING_NIGHTMARE:
+                        Talk(EMOTE_WAKING_NIGHTMARE);
+                        DoCastAOE(SPELL_WAKING_NIGHTMARE);
+                        events.ScheduleEvent(EVENT_WAKING_NIGHTMARE, urand(20000, 40000));
+                        break;
+                    default:
+                        break;
                 }
-                uiShadowPastTimer = 5000;
-            }else uiShadowPastTimer -= uiDiff;
+            }
 
-            DoMeleeAttackIfReady();
-        }
+            if (!UpdateVictim())
+                return;
 
-        void JustDied(Unit* /*killer*/) override
-        {
-            if (TempSummon* summ = me->ToTempSummon())
-                if (Unit* summoner = summ->GetSummoner())
-                    if (summoner->IsAlive())
-                        summoner->GetAI()->SetData(1, 0);
+            DoMeleeAttackIfReady();
         }
     };
 
@@ -501,105 +672,284 @@ class npc_argent_soldier : public CreatureScript
 public:
     npc_argent_soldier() : CreatureScript("npc_argent_soldier") { }
 
-    // THIS AI NEEDS MORE IMPROVEMENTS
-    struct npc_argent_soldierAI : public npc_escortAI
+    struct npc_argent_soldierAI : public ScriptedAI
     {
-        npc_argent_soldierAI(Creature* creature) : npc_escortAI(creature)
+        npc_argent_soldierAI(Creature* creature) : ScriptedAI(creature)
         {
             instance = creature->GetInstanceScript();
-            me->SetReactState(REACT_DEFENSIVE);
-            SetDespawnAtEnd(false);
+            Initialize();
             uiWaypoint = 0;
         }
 
+        void Initialize()
+        {
+            shielded = false;
+        }
+
+        EventMap events;
         InstanceScript* instance;
 
+        bool shielded;
         uint8 uiWaypoint;
 
-        void WaypointReached(uint32 waypointId) override
+        ObjectGuid fountainGuid;
+
+        void Reset() override
         {
-            if (waypointId == 0)
+            events.Reset();
+            Initialize();
+            if (me->GetEntry() == NPC_PRIESTESS)
             {
-                switch (uiWaypoint)
-                {
-                    case 0:
-                        me->SetFacingTo(5.81f);
-                        break;
-                    case 1:
-                        me->SetFacingTo(4.60f);
-                        break;
-                    case 2:
-                        me->SetFacingTo(2.79f);
-                        break;
-                }
+                if (Creature* fountain = ObjectAccessor::GetCreature(*me, fountainGuid))
+                    fountain->DisappearAndDie();
             }
         }
 
-        void SetData(uint32 uiType, uint32 /*uiData*/) override
+        Position GenerateFinalPosition() const
         {
+            Position finalPos;
             switch (me->GetEntry())
             {
                 case NPC_ARGENT_LIGHWIELDER:
-                    switch (uiType)
+                    switch (uiWaypoint)
                     {
                         case 0:
-                            AddWaypoint(0, 712.14f, 628.42f, 411.88f);
+                            finalPos = { 712.14f, 628.42f, 411.88f, 5.81f };
                             break;
                         case 1:
-                            AddWaypoint(0, 742.44f, 650.29f, 411.79f);
+                            finalPos = { 742.44f, 650.29f, 411.79f, 4.60f };
                             break;
                         case 2:
-                            AddWaypoint(0, 783.33f, 615.29f, 411.84f);
+                            finalPos = { 774.94f, 636.64f, 411.89f, 3.78f };
                             break;
                     }
                     break;
                 case NPC_ARGENT_MONK:
-                    switch (uiType)
+                    switch (uiWaypoint)
                     {
                         case 0:
-                            AddWaypoint(0, 713.12f, 632.97f, 411.90f);
+                            finalPos = { 713.12f, 632.97f, 411.90f, 5.81f };
                             break;
                         case 1:
-                            AddWaypoint(0, 746.73f, 650.24f, 411.56f);
+                            finalPos = { 746.73f, 650.24f, 411.56f, 4.60f };
                             break;
                         case 2:
-                            AddWaypoint(0, 781.32f, 610.54f, 411.82f);
+                            finalPos = { 777.33f, 633.08f, 411.89f, 3.78f };
                             break;
                     }
                     break;
                 case NPC_PRIESTESS:
-                    switch (uiType)
+                    switch (uiWaypoint)
                     {
                         case 0:
-                            AddWaypoint(0, 715.06f, 637.07f, 411.91f);
+                            finalPos = { 715.06f, 637.07f, 411.91f, 5.81f };
                             break;
                         case 1:
-                            AddWaypoint(0, 750.72f, 650.20f, 411.77f);
+                            finalPos = { 750.72f, 650.20f, 411.77f, 4.60f };
                             break;
                         case 2:
-                            AddWaypoint(0, 779.77f, 607.03f, 411.81f);
+                            finalPos = { 780.13f, 629.18f, 411.89f, 3.78f };
                             break;
                     }
                     break;
+                default:
+                    break;
             }
+            return finalPos;
+        }
 
-            Start(false, true);
-            uiWaypoint = uiType;
+        void JustReachedHome() override
+        {
+            me->SetUInt32Value(UNIT_NPC_EMOTESTATE, EMOTE_STATE_READY1H);
         }
 
-        void UpdateAI(uint32 uiDiff) override
+        void MovementInform(uint32 uiType, uint32 uiPointId) override
         {
-            npc_escortAI::UpdateAI(uiDiff);
+            ScriptedAI::MovementInform(uiType, uiPointId);
 
-            if (!UpdateVictim())
+            if (uiType != POINT_MOTION_TYPE)
                 return;
 
-            DoMeleeAttackIfReady();
+            if (uiPointId == 0)
+            {
+                me->SetWalk(false);
+                me->GetMotionMaster()->MoveTargetedHome(); // this corrects facing 100%
+                if (me->GetEntry() == NPC_ARGENT_MONK)
+                {
+                    if (Creature* pLightwielder = me->FindNearestCreature(NPC_ARGENT_LIGHWIELDER, 15.0f))
+                    {
+                        if (pLightwielder->GetFollowAngle() != 0)
+                        {
+                            pLightwielder->GetMotionMaster()->Clear();
+                            pLightwielder->GetMotionMaster()->MovePoint(0, pLightwielder->GetHomePosition());
+                        }
+                    }
+                    if (Creature* pPriestess = me->FindNearestCreature(NPC_PRIESTESS, 15.0f))
+                    {
+                        if (pPriestess->GetFollowAngle() != 0)
+                        {
+                            pPriestess->GetMotionMaster()->Clear();
+                            pPriestess->GetMotionMaster()->MovePoint(0, pPriestess->GetHomePosition());
+                        }
+                    }
+                }
+            }
+        }
+
+        void JustSummoned(Creature* summon) override
+        {
+            if (me->GetEntry() == NPC_PRIESTESS)
+                fountainGuid = summon->GetGUID();
+        }
+
+        void DamageTaken(Unit* /*attacker*/, uint32& dmg) override
+        {
+            if (me->GetEntry() == NPC_ARGENT_MONK && dmg >= me->GetHealth() && !shielded)
+            {
+                dmg = 0;
+                shielded = true;
+                me->SetHealth(1);
+                me->AttackStop();
+                DoCast(SPELL_DIVINE_SHIELD);
+                DoCast(SPELL_FINAL_MEDITATION);
+                return;
+            }
         }
 
         void JustDied(Unit* /*killer*/) override
         {
             instance->SetData(DATA_ARGENT_SOLDIER_DEFEATED, instance->GetData(DATA_ARGENT_SOLDIER_DEFEATED) + 1);
+            if (me->GetEntry() == NPC_PRIESTESS)
+            {
+                if (Creature* fountain = ObjectAccessor::GetCreature(*me, fountainGuid))
+                    fountain->DisappearAndDie();
+            }
+        }
+
+        void SetData(uint32 uiType, uint32 /*uiData*/) override
+        {
+            uiWaypoint = uiType;
+            Position const homePos = GenerateFinalPosition();
+            if (homePos.IsPositionValid())
+            {
+                me->SetHomePosition(homePos);
+                me->SetWalk(true);
+                if (me->GetEntry() == NPC_ARGENT_MONK)
+                    me->GetMotionMaster()->MovePoint(0, homePos);
+            }
+        }
+
+        void EnterCombat(Unit* /*who*/) override
+        {
+            switch (me->GetEntry())
+            {
+                case NPC_ARGENT_LIGHWIELDER:
+                    events.ScheduleEvent(EVENT_BLAZING_LIGHT, 10000);
+                    events.ScheduleEvent(EVENT_CLEAVE, urand(4000, 6000));
+                    if (IsHeroic())
+                        events.ScheduleEvent(EVENT_UNBALANCING_STRIKE, 8000);
+                    break;
+                case NPC_ARGENT_MONK:
+                    events.ScheduleEvent(EVENT_FLURRY_OF_BLOWS, 2000);
+                    events.ScheduleEvent(EVENT_PUMMEL, 12000);
+                    break;
+                case NPC_PRIESTESS:
+                    events.ScheduleEvent(EVENT_SHADOW_WORD_PAIN, 500);
+                    events.ScheduleEvent(EVENT_HOLY_SMITE, 2500);
+                    events.ScheduleEvent(EVENT_FOUNTAIN, 10000);
+                    if (IsHeroic())
+                        events.ScheduleEvent(EVENT_MIND_CONTROL, 15000);
+                    break;
+                default:
+                    break;
+            }
+        }
+
+        void AttackStart(Unit* who) override
+        {
+            if (!(me->GetEntry() == NPC_ARGENT_MONK && me->HasAura(SPELL_DIVINE_SHIELD)))
+                ScriptedAI::AttackStart(who);
+        }
+
+        void UpdateAI(uint32 uiDiff) override
+        {
+            events.Update(uiDiff);
+
+            if (me->HasUnitState(UNIT_STATE_CASTING))
+                return;
+
+            if (!UpdateVictim())
+                return;
+
+            while (uint32 eventId = events.ExecuteEvent())
+            {
+                switch (eventId)
+                {
+                    case EVENT_BLAZING_LIGHT:
+                        if (Unit* pFriend = DoSelectLowestHpFriendly(40.0f))
+                        {
+                            if (pFriend->GetHealthPct() > me->GetHealthPct())
+                                DoCast(me, SPELL_BLAZING_LIGHT);
+                            else
+                                DoCast(pFriend, SPELL_BLAZING_LIGHT);
+                        }
+                        events.ScheduleEvent(EVENT_BLAZING_LIGHT, 10000);
+                        break;
+                    case EVENT_CLEAVE:
+                        DoCastVictim(SPELL_CLEAVE);
+                        events.ScheduleEvent(EVENT_CLEAVE, urand(4000, 6000));
+                        break;
+                    case EVENT_UNBALANCING_STRIKE:
+                        DoCastVictim(SPELL_UNBALANCING_STRIKE);
+                        events.ScheduleEvent(EVENT_UNBALANCING_STRIKE, 15000);
+                        break;
+                    case EVENT_FLURRY_OF_BLOWS:
+                        DoCast(SPELL_FLURRY_OF_BLOWS);
+                        events.ScheduleEvent(EVENT_FLURRY_OF_BLOWS, 15000);
+                        break;
+                    case EVENT_PUMMEL:
+                    {
+                        Map::PlayerList const &pList = me->GetMap()->GetPlayers();
+                        for (Map::PlayerList::const_iterator itr = pList.begin(); itr != pList.end(); ++itr)
+                        {
+                            Player* player = itr->GetSource();
+                            if (me->IsWithinDist(player, 5.0f) && player->IsNonMeleeSpellCast(true))
+                            {
+                                DoCast(player, SPELL_PUMMEL);
+                                break;
+                            }
+                        }
+                        events.ScheduleEvent(EVENT_PUMMEL, 12000);
+                        break;
+                    }
+                    case EVENT_SHADOW_WORD_PAIN:
+                        if (IsHeroic())
+                            DoCastVictim(SPELL_SHADOW_WORD_PAIN_H);
+                        else
+                            DoCastVictim(SPELL_SHADOW_WORD_PAIN);
+                        events.ScheduleEvent(EVENT_SHADOW_WORD_PAIN, 15000);
+                        break;
+                    case EVENT_HOLY_SMITE:
+                        if (IsHeroic())
+                            DoCastVictim(SPELL_HOLY_SMITE_H);
+                        else
+                            DoCastVictim(SPELL_HOLY_SMITE);
+                        events.ScheduleEvent(EVENT_HOLY_SMITE, urand(4000, 7000));
+                        break;
+                    case EVENT_FOUNTAIN:
+                        DoCast(SPELL_SUMMON_FOUNTAIN);
+                        events.ScheduleEvent(EVENT_FOUNTAIN, 50000);
+                        break;
+                    case EVENT_MIND_CONTROL:
+                        if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 1, 30.0f, true))
+                            DoCast(target, SPELL_MIND_CONTROL);
+                        events.ScheduleEvent(EVENT_MIND_CONTROL, 15000);
+                        break;
+                    default:
+                        break;
+                }
+            }
+            DoMeleeAttackIfReady();
         }
     };
 
@@ -609,6 +959,68 @@ class npc_argent_soldier : public CreatureScript
     }
 };
 
+class npc_fountain_of_light : public CreatureScript
+{
+    public:
+        npc_fountain_of_light() : CreatureScript("npc_fountain_of_light") { }
+
+        struct npc_fountain_of_lightAI : public ScriptedAI
+        {
+            npc_fountain_of_lightAI(Creature* creature) : ScriptedAI(creature)
+            {
+                Initialize();
+                me->SetReactState(REACT_PASSIVE);
+                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_DISABLE_MOVE);
+                SetCombatMovement(false);
+                instance = creature->GetInstanceScript();
+            }
+
+            void Initialize()
+            {
+                events.ScheduleEvent(EVENT_FOUNTAIN_DUMMY, 2000);
+            }
+
+            InstanceScript* instance;
+            EventMap events;
+
+            void Reset() override
+            {
+                events.Reset();
+                Initialize();
+            }
+
+            void JustDied(Unit* /*killer*/) override
+            {
+                me->DespawnOrUnsummon();
+            }
+
+            void AttackStart(Unit* /*who*/) override { }
+
+            void UpdateAI(uint32 uiDiff) override
+            {
+                events.Update(uiDiff);
+
+                while (uint32 eventId = events.ExecuteEvent())
+                {
+                    if (eventId == EVENT_FOUNTAIN_DUMMY)
+                    {
+                        if (!me->HasAura(SPELL_FOUNTAIN_DUMMY_HEAL))
+                            DoCast(me, SPELL_FOUNTAIN_DUMMY_HEAL);
+                        events.ScheduleEvent(EVENT_FOUNTAIN_DUMMY, 5000);
+                    }
+                }
+
+                if (!UpdateVictim())
+                    return;
+            }
+        };
+
+        CreatureAI* GetAI(Creature* creature) const override
+        {
+            return GetInstanceAI<npc_fountain_of_lightAI>(creature);
+        }
+};
+
 uint32 const memorySpellId[25] =
 {
     SPELL_MEMORY_ALGALON,
@@ -668,7 +1080,7 @@ class spell_paletress_summon_memory : public SpellScriptLoader
 
             void HandleScript(SpellEffIndex /*effIndex*/)
             {
-                GetHitUnit()->CastSpell(GetHitUnit(), memorySpellId[urand(0, 24)], true, NULL, NULL, GetCaster()->GetGUID());
+                GetHitUnit()->CastSpell(GetHitUnit(), memorySpellId[urand(0, 24)], true, nullptr, nullptr, GetCaster()->GetGUID());
             }
 
             void Register() override
@@ -684,6 +1096,122 @@ class spell_paletress_summon_memory : public SpellScriptLoader
         }
 };
 
+class spell_paletress_reflective_shield : public SpellScriptLoader
+{
+    public:
+        spell_paletress_reflective_shield() : SpellScriptLoader("spell_paletress_reflective_shield") { }
+
+        class spell_paletress_reflective_shield_AuraScript : public AuraScript
+        {
+            PrepareAuraScript(spell_paletress_reflective_shield_AuraScript);
+
+            bool Validate(SpellInfo const* /*spellInfo*/) override
+            {
+                if (!sSpellMgr->GetSpellInfo(SPELL_SHIELD_REFLECT))
+                    return false;
+                return true;
+            }
+
+            void HandleScript(AuraEffect* aurEff, DamageInfo& dmgInfo, uint32& absorbAmount)
+            {
+                // Reflecting 25% of absorbed damage back to attacker
+                if (dmgInfo.GetAttacker() == GetTarget())
+                    return;
+                int32 bp = absorbAmount / 4;
+                GetTarget()->CastCustomSpell(dmgInfo.GetAttacker(), SPELL_SHIELD_REFLECT, &bp, nullptr, nullptr, true, nullptr, aurEff);
+            }
+
+            void Register() override
+            {
+                AfterEffectAbsorb += AuraEffectAbsorbFn(spell_paletress_reflective_shield_AuraScript::HandleScript, EFFECT_0);
+            }
+        };
+
+        AuraScript* GetAuraScript() const override
+        {
+            return new spell_paletress_reflective_shield_AuraScript();
+        }
+};
+
+class spell_eadric_hammer_of_righteous : public SpellScriptLoader
+{
+    public:
+        spell_eadric_hammer_of_righteous() : SpellScriptLoader("spell_eadric_hammer_of_righteous") { }
+
+        class spell_eadric_hammer_of_righteous_SpellScript : public SpellScript
+        {
+            PrepareSpellScript(spell_eadric_hammer_of_righteous_SpellScript);
+
+            bool Validate(SpellInfo const* /*spellInfo*/) override
+            {
+                if (!sSpellMgr->GetSpellInfo(SPELL_HAMMER_RIGHT_DUMMY) || 
+                    !sSpellMgr->GetSpellInfo(SPELL_HAMMER_JUSTICE_STUN))
+                    return false;
+                return true;
+            }
+
+            void HandleDamage()
+            {
+                if (Unit* target = GetHitUnit())
+                {
+                    if (!target->HasAura(SPELL_HAMMER_JUSTICE_STUN))
+                    {
+                        // If target does not have Hammer of Justice stun,
+                        // then target gets the dummy aura which allows you to throw hammer back to Eadric
+                        PreventHitDefaultEffect(EFFECT_0);
+                        PreventHitDamage();
+                        GetCaster()->CastSpell(target, SPELL_HAMMER_RIGHT_DUMMY, true);
+                    }
+                }
+            }
+
+            void Register() override
+            {
+                BeforeHit += SpellHitFn(spell_eadric_hammer_of_righteous_SpellScript::HandleDamage);
+            }
+        };
+
+        SpellScript* GetSpellScript() const override
+        {
+            return new spell_eadric_hammer_of_righteous_SpellScript();
+        }
+};
+
+class spell_eadric_hammer_of_righteous_faceroller : public SpellScriptLoader
+{
+    public:
+        spell_eadric_hammer_of_righteous_faceroller() : SpellScriptLoader("spell_eadric_hammer_of_righteous_faceroller") { }
+
+        class spell_eadric_hammer_of_righteous_faceroller_SpellScript : public SpellScript
+        {
+            PrepareSpellScript(spell_eadric_hammer_of_righteous_faceroller_SpellScript);
+
+            void CheckHealth(SpellEffIndex /*effIndex*/)
+            {
+                if (GetCaster()->GetTypeId() != TYPEID_PLAYER || !GetCaster()->GetMap()->IsHeroic())
+                    return;
+
+                if (!GetHitUnit() || !GetHitUnit()->ToCreature() || GetHitUnit()->ToCreature()->GetEntry() != NPC_EADRIC)
+                    return;
+
+                // If the spell's damage is higher than Eadric' health,
+                // player gets the achievement
+                if (GetHitDamage() >= int32(GetHitUnit()->GetHealth()))
+                    ENSURE_AI(boss_eadric::boss_eadricAI, GetHitUnit()->ToCreature()->AI())->SetFacerollerPlayer(GetCaster()->GetGUID());
+            }
+
+            void Register() override
+            {
+                OnEffectHitTarget += SpellEffectFn(spell_eadric_hammer_of_righteous_faceroller_SpellScript::CheckHealth, EFFECT_0, SPELL_EFFECT_SCHOOL_DAMAGE);
+            }
+        };
+
+        SpellScript* GetSpellScript() const override
+        {
+            return new spell_eadric_hammer_of_righteous_faceroller_SpellScript();
+        }
+};
+
 void AddSC_boss_argent_challenge()
 {
     new boss_eadric();
@@ -691,5 +1219,9 @@ void AddSC_boss_argent_challenge()
     new boss_paletress();
     new npc_memory();
     new npc_argent_soldier();
+    new npc_fountain_of_light();
     new spell_paletress_summon_memory();
+    new spell_paletress_reflective_shield();
+    new spell_eadric_hammer_of_righteous();
+    new spell_eadric_hammer_of_righteous_faceroller();
 }
diff --git a/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheChampion/boss_black_knight.cpp b/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheChampion/boss_black_knight.cpp
index c10eb0f..753a9e1 100644
--- a/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheChampion/boss_black_knight.cpp
+++ b/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheChampion/boss_black_knight.cpp
@@ -17,71 +17,109 @@
 
 /* ScriptData
 SDName: Boss Black Knight
-SD%Complete: 80%
-SDComment: missing yells. not sure about timers.
+SD%Complete: 100%
+SDComment:
 SDCategory: Trial of the Champion
 EndScriptData */
 
+#include "Player.h"
 #include "ScriptMgr.h"
 #include "ScriptedCreature.h"
 #include "ScriptedEscortAI.h"
+#include "SpellAuraEffects.h"
+#include "SpellScript.h"
 #include "trial_of_the_champion.h"
 
+enum Yells
+{
+    SAY_AGGRO               = 3,
+    SAY_PHASE_2             = 4,
+    SAY_PHASE_3             = 5,
+    SAY_KILL                = 6,
+    SAY_DEATH               = 7
+};
+
+enum Events
+{
+    // The Black Knight
+    EVENT_ICY_TOUCH         = 1,
+    EVENT_PLAGUE_STRIKE,
+    EVENT_DEATH_RESPITE,
+    EVENT_OBLITERATE,
+    EVENT_DESECRATION,
+    EVENT_GHOUL_EXPLODE,
+    EVENT_DEATH_BITE,
+    EVENT_MARKED_DEATH,
+    EVENT_RESURRECT,
+    // Ghouls
+    EVENT_CLAW,
+    EVENT_LEAP
+};
+
 enum Spells
 {
-    //phase 1
-    SPELL_PLAGUE_STRIKE     = 67884,
-    SPELL_PLAGUE_STRIKE_2   = 67724,
-    SPELL_ICY_TOUCH_H       = 67881,
+    // Phase 1
+    SPELL_PLAGUE_STRIKE     = 67724,
     SPELL_ICY_TOUCH         = 67718,
     SPELL_DEATH_RESPITE     = 67745,
-    SPELL_DEATH_RESPITE_2   = 68306,
-    SPELL_DEATH_RESPITE_3   = 66798,
-    SPELL_OBLITERATE_H      = 67883,
     SPELL_OBLITERATE        = 67725,
-    //in this phase should rise herald (the spell is missing)
+    SPELL_RAISE_ARELAS      = 67705,
+    SPELL_RAISE_JAEREN      = 67715,
 
-    //phase 2 - During this phase, the Black Knight will use the same abilities as in phase 1, except for Death's Respite
+    // Phase 2 
     SPELL_ARMY_DEAD         = 67761,
     SPELL_DESECRATION       = 67778,
-    SPELL_DESECRATION_2     = 67778,
     SPELL_GHOUL_EXPLODE     = 67751,
 
-    //phase 3
-    SPELL_DEATH_BITE_H      = 67875,
+    // Phase 3
     SPELL_DEATH_BITE        = 67808,
     SPELL_MARKED_DEATH      = 67882,
-    SPELL_MARKED_DEATH_2    = 67823,
-
-    SPELL_BLACK_KNIGHT_RES  = 67693,
 
+    // Ghouls
+    SPELL_CLAW              = 67774,
     SPELL_LEAP              = 67749,
-    SPELL_LEAP_H            = 67880,
 
+    SPELL_DEATH_RESPITE_DND = 66798, // casted on announcer
+    SPELL_FEIGN_DEATH       = 66804,
+    SPELL_BLACK_KNIGHT_DIE  = 67691,
+    SPELL_BLACK_KNIGHT_RES  = 67693,
+    SPELL_FROST_FEVER       = 67719,
+    SPELL_BLOOD_PLAGUE      = 67722,
+    SPELL_EXPLODE           = 67729,
+    SPELL_DESECRATION_DND   = 67782,
+    SPELL_DESECRATION_ARM   = 67803,
+    SPELL_FROST_FEVER_H     = 67878,
+    SPELL_BLOOD_PLAGUE_H    = 67885,
+    SPELL_EXPLODE_H         = 67886,
     SPELL_KILL_CREDIT       = 68663
 };
 
 enum Models
 {
-    MODEL_SKELETON = 29846,
-    MODEL_GHOST    = 21300
+    MODEL_SKELETON          = 29846,
+    MODEL_GHOST             = 21300
+};
+
+enum Equipment
+{
+    EQUIP_SWORD             = 40343
 };
 
 enum Phases
 {
-    PHASE_UNDEAD    = 1,
-    PHASE_SKELETON  = 2,
-    PHASE_GHOST     = 3
+    PHASE_UNDEAD            = 1,
+    PHASE_SKELETON          = 2,
+    PHASE_GHOST             = 3
 };
 
-class boss_black_knight : public CreatureScript
+class npc_risen_ghoul : public CreatureScript
 {
 public:
-    boss_black_knight() : CreatureScript("boss_black_knight") { }
+    npc_risen_ghoul() : CreatureScript("npc_risen_ghoul") { }
 
-    struct boss_black_knightAI : public ScriptedAI
+    struct npc_risen_ghoulAI : public ScriptedAI
     {
-        boss_black_knightAI(Creature* creature) : ScriptedAI(creature), summons(creature)
+        npc_risen_ghoulAI(Creature* creature) : ScriptedAI(creature)
         {
             Initialize();
             instance = creature->GetInstanceScript();
@@ -89,263 +127,364 @@ class boss_black_knight : public CreatureScript
 
         void Initialize()
         {
-            bEventInProgress = false;
-            bEvent = false;
-            bSummonArmy = false;
-            bDeathArmyDone = false;
-
-            uiPhase = PHASE_UNDEAD;
-
-            uiIcyTouchTimer = urand(5000, 9000);
-            uiPlagueStrikeTimer = urand(10000, 13000);
-            uiDeathRespiteTimer = urand(15000, 16000);
-            uiObliterateTimer = urand(17000, 19000);
-            uiDesecration = urand(15000, 16000);
-            uiDeathArmyCheckTimer = 7000;
-            uiResurrectTimer = 4000;
-            uiGhoulExplodeTimer = 8000;
-            uiDeathBiteTimer = urand(2000, 4000);
-            uiMarkedDeathTimer = urand(5000, 7000);
+            doExplode = false;
         }
 
         InstanceScript* instance;
 
-        SummonList summons;
+        EventMap events;
 
-        bool bEventInProgress;
-        bool bEvent;
-        bool bSummonArmy;
-        bool bDeathArmyDone;
+        bool doExplode;
 
-        uint8 uiPhase;
+        void Reset() override
+        {
+            events.Reset();
+            Initialize();
+        }
 
-        uint32 uiPlagueStrikeTimer;
-        uint32 uiIcyTouchTimer;
-        uint32 uiDeathRespiteTimer;
-        uint32 uiObliterateTimer;
-        uint32 uiDesecration;
-        uint32 uiResurrectTimer;
-        uint32 uiDeathArmyCheckTimer;
-        uint32 uiGhoulExplodeTimer;
-        uint32 uiDeathBiteTimer;
-        uint32 uiMarkedDeathTimer;
+        void SpellHitTarget(Unit* target, SpellInfo const* spell) override
+        {
+            if (spell->Id == SPELL_EXPLODE || spell->Id == SPELL_EXPLODE_H)
+            {
+                if (!target->ToPlayer())
+                    return;
 
-        void Reset() override
+                if (Creature* knight = instance->GetCreature(DATA_THE_BLACK_KNIGHT))
+                    // If corpse explosion hits any player during encounter
+                    // we cannot give achievement id 3804
+                    knight->AI()->SetData(1, 0);
+            }
+        }
+
+        void DoExplode()
         {
-            summons.DespawnAll();
-            me->SetDisplayId(me->GetNativeDisplayId());
-            me->ClearUnitState(UNIT_STATE_ROOT | UNIT_STATE_STUNNED);
+            // We trigger the ghoul explode spell casted on us by Black Knight
+            // to get immunity to crowd control forms and we get correct growth aura
+            // the spell script of Ghoul Explode functions normally from here on
+            if (me->HasAura(SPELL_GHOUL_EXPLODE))
+                return;
+            DoCast(me, SPELL_GHOUL_EXPLODE, true);
+            // wtf?
+            if (me->GetEntry() == NPC_RISEN_ARELAS || me->GetEntry() == NPC_RISEN_JAEREN)
+                Talk(urand(0, 2));
+        }
 
-            Initialize();
+        void DamageTaken(Unit* /*attacker*/, uint32& /*damage*/) override
+        {
+            if (HealthBelowPct(31) && !doExplode)
+            {
+                // Ghouls cast explode when they reach 30% health or if Black Knight dies
+                // or if Black Knight forces them to explode
+                doExplode = true;
+                DoExplode();
+            }
         }
 
-        void JustSummoned(Creature* summon) override
+        void EnterCombat(Unit* /*who*/) override
         {
-            summons.Summon(summon);
-            summon->AI()->AttackStart(me->GetVictim());
+            events.ScheduleEvent(EVENT_CLAW, 3000);
+            events.ScheduleEvent(EVENT_LEAP, 2000);
+            DoZoneInCombat();
         }
 
-        void SummonedCreatureDespawn(Creature* summon) override
+        void JustDied(Unit* /*killer*/) override
         {
-            summons.Despawn(summon);
+            me->DespawnOrUnsummon(1000);
         }
 
-        void UpdateAI(uint32 uiDiff) override
+        void KilledUnit(Unit* who) override
         {
-            //Return since we have no target
-            if (!UpdateVictim())
+            if (who == me)
                 return;
-
-            if (bEventInProgress)
+            if (Creature* knight = instance->GetCreature(DATA_THE_BLACK_KNIGHT))
             {
-                if (uiResurrectTimer <= uiDiff)
-                {
-                    me->SetFullHealth();
-                    DoCast(me, SPELL_BLACK_KNIGHT_RES, true);
-                    uiPhase++;
-                    uiResurrectTimer = 4000;
-                    bEventInProgress = false;
-                    me->ClearUnitState(UNIT_STATE_ROOT | UNIT_STATE_STUNNED);
-                } else uiResurrectTimer -= uiDiff;
+                if (!knight->HasAura(SPELL_BLACK_KNIGHT_DIE))
+                    knight->AI()->KilledUnit(who);
             }
+        }
+
+        void UpdateAI(uint32 uiDiff) override
+        {
+            events.Update(uiDiff);
+
+            if (me->HasUnitState(UNIT_STATE_CASTING))
+                return;
 
-            switch (uiPhase)
+            if (!UpdateVictim())
+                return;
+
+            while (uint32 eventId = events.ExecuteEvent())
             {
-                case PHASE_UNDEAD:
-                case PHASE_SKELETON:
+                switch (eventId)
                 {
-                    if (uiIcyTouchTimer <= uiDiff)
-                    {
-                        DoCastVictim(SPELL_ICY_TOUCH);
-                        uiIcyTouchTimer = urand(5000, 7000);
-                    } else uiIcyTouchTimer -= uiDiff;
-                    if (uiPlagueStrikeTimer <= uiDiff)
-                    {
-                        DoCastVictim(SPELL_ICY_TOUCH);
-                        uiPlagueStrikeTimer = urand(12000, 15000);
-                    } else uiPlagueStrikeTimer -= uiDiff;
-                    if (uiObliterateTimer <= uiDiff)
-                    {
-                        DoCastVictim(SPELL_OBLITERATE);
-                        uiObliterateTimer = urand(17000, 19000);
-                    } else uiObliterateTimer -= uiDiff;
-                    switch (uiPhase)
-                    {
-                        case PHASE_UNDEAD:
+                    case EVENT_CLAW:
+                        DoCastVictim(SPELL_CLAW);
+                        if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 1, 50.0f, true))
                         {
-                            if (uiDeathRespiteTimer <= uiDiff)
-                            {
-                                if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 0, 100, true))
-                                {
-                                    if (target && target->IsAlive())
-                                        DoCast(target, SPELL_DEATH_RESPITE);
-                                }
-                                uiDeathRespiteTimer = urand(15000, 16000);
-                            } else uiDeathRespiteTimer -= uiDiff;
-                            break;
+                            DoResetThreat();
+                            me->AddThreat(target, 10.0f);
+                            me->AI()->AttackStart(target);
                         }
-                        case PHASE_SKELETON:
+                        events.ScheduleEvent(EVENT_CLAW, urand(12000, 15000));
+                        break;
+                    case EVENT_LEAP:
+                        if (me->GetEntry() == NPC_RISEN_ARELAS || me->GetEntry() == NPC_RISEN_JAEREN)
                         {
-                            if (!bSummonArmy)
-                            {
-                                bSummonArmy = true;
-                                me->AddUnitState(UNIT_STATE_ROOT | UNIT_STATE_STUNNED);
-                                DoCast(me, SPELL_ARMY_DEAD);
-                            }
-                            if (!bDeathArmyDone)
-                            {
-                                if (uiDeathArmyCheckTimer <= uiDiff)
-                                {
-                                    me->ClearUnitState(UNIT_STATE_ROOT | UNIT_STATE_STUNNED);
-                                    uiDeathArmyCheckTimer = 0;
-                                    bDeathArmyDone = true;
-                                } else uiDeathArmyCheckTimer -= uiDiff;
-                            }
-                            if (uiDesecration <= uiDiff)
-                            {
-                                if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 0, 100, true))
-                                {
-                                    if (target && target->IsAlive())
-                                        DoCast(target, SPELL_DESECRATION);
-                                }
-                                uiDesecration = urand(15000, 16000);
-                            } else uiDesecration -= uiDiff;
-                            if (uiGhoulExplodeTimer <= uiDiff)
-                            {
-                                DoCast(me, SPELL_GHOUL_EXPLODE);
-                                uiGhoulExplodeTimer = 8000;
-                            } else uiGhoulExplodeTimer -= uiDiff;
-                            break;
+                            if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 1, 30.0f, true))
+                                DoCast(target, SPELL_LEAP);
+                            events.ScheduleEvent(EVENT_LEAP, urand(8000, 10000));
                         }
                         break;
-                    }
-                    break;
+                    default:
+                        break;
                 }
-                case PHASE_GHOST:
+            }
+            DoMeleeAttackIfReady();
+        }
+    };
+
+    CreatureAI* GetAI(Creature* creature) const override
+    {
+        return new npc_risen_ghoulAI(creature);
+    }
+};
+
+class boss_black_knight : public CreatureScript
+{
+public:
+    boss_black_knight() : CreatureScript("boss_black_knight") { }
+
+    struct boss_black_knightAI : public BossAI
+    {
+        boss_black_knightAI(Creature* creature) : BossAI(creature, DATA_THE_BLACK_KNIGHT)
+        {
+            Initialize();
+            me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+            me->SetReactState(REACT_PASSIVE);
+        }
+
+        void Initialize()
+        {
+            uiPhase = PHASE_UNDEAD;
+            achievementCredit = true;
+        }
+
+        uint8 uiPhase;
+        bool achievementCredit;
+
+        void Reset() override
+        {
+            me->SetDisplayId(me->GetNativeDisplayId());
+            SetEquipmentSlots(false, EQUIP_SWORD, EQUIP_NO_CHANGE, EQUIP_NO_CHANGE);
+            _Reset();
+            Initialize();
+        }
+
+        void EnterEvadeMode(EvadeReason why = EVADE_REASON_OTHER) override
+        {
+            BossAI::EnterEvadeMode(why);
+            me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_IMMUNE_TO_PC);
+        }
+
+        // Events are not resetted in this function
+        void LoadEvents()
+        {
+            if (uiPhase == PHASE_GHOST)
+            {
+                // Phase 3
+                events.ScheduleEvent(EVENT_DEATH_BITE, 5000);
+                events.ScheduleEvent(EVENT_MARKED_DEATH, 20000);
+            }
+            else
+            {
+                // Phase 1 and 2
+                events.ScheduleEvent(EVENT_ICY_TOUCH, 6000);
+                if (uiPhase == PHASE_UNDEAD)
                 {
-                    if (uiDeathBiteTimer <= uiDiff)
-                    {
-                        DoCastAOE(SPELL_DEATH_BITE);
-                        uiDeathBiteTimer = urand(2000, 4000);
-                    } else uiDeathBiteTimer -= uiDiff;
-                    if (uiMarkedDeathTimer <= uiDiff)
+                    // Phase 1 only
+                    events.ScheduleEvent(EVENT_DEATH_RESPITE, 8000);
+
+                    // Raising announcer as a ghoul
+                    if (Creature* announcer = instance->GetCreature(DATA_ANNOUNCER))
                     {
-                        if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 0, 100, true))
-                        {
-                            if (target && target->IsAlive())
-                                DoCast(target, SPELL_MARKED_DEATH);
-                        }
-                        uiMarkedDeathTimer = urand(5000, 7000);
-                    } else uiMarkedDeathTimer -= uiDiff;
-                    break;
+                        if (announcer->GetEntry() == NPC_JAEREN)
+                            announcer->CastSpell(me->GetVictim(), SPELL_RAISE_JAEREN, false, nullptr, nullptr, me->GetGUID());
+                        else
+                            announcer->CastSpell(me->GetVictim(), SPELL_RAISE_ARELAS, false, nullptr, nullptr, me->GetGUID());
+                    }
+                }
+                else
+                {
+                    // Phase 2 only
+                    events.ScheduleEvent(EVENT_DESECRATION, 5000);
+                    events.ScheduleEvent(EVENT_GHOUL_EXPLODE, 8000);
+
+                    // Army of the Dead
+                    // disabling movement temporarily so the spell wont get interrupted
+                    me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_DISABLE_MOVE);
+                    DoCast(SPELL_ARMY_DEAD);
                 }
             }
+        }
 
-            if (!me->HasUnitState(UNIT_STATE_ROOT) && !me->HealthBelowPct(1))
-                DoMeleeAttackIfReady();
+        void SetData(uint32 type, uint32 /*data*/) override
+        {
+            if (type == 1)
+                achievementCredit = false;
         }
 
-        void DamageTaken(Unit* /*pDoneBy*/, uint32& uiDamage) override
+        void SpellHit(Unit* /*caster*/, SpellInfo const* spell) override
         {
-            if (uiDamage > me->GetHealth() && uiPhase <= PHASE_SKELETON)
+            if (spell->Id == SPELL_BLACK_KNIGHT_RES)
             {
-                uiDamage = 0;
-                me->SetHealth(0);
-                me->AddUnitState(UNIT_STATE_ROOT | UNIT_STATE_STUNNED);
-                summons.DespawnAll();
-                switch (uiPhase)
+                // TODO: According to sniffs, The Black Knight should update 
+                // creature template to another entry, not just change his display id
+                // But the other templates are missing correct damage modifiers
+                me->SetFullHealth();
+                me->SetStandState(UNIT_STAND_STATE_STAND);
+                if (uiPhase == PHASE_UNDEAD)
                 {
-                    case PHASE_UNDEAD:
-                        me->SetDisplayId(MODEL_SKELETON);
-                        break;
-                    case PHASE_SKELETON:
-                        me->SetDisplayId(MODEL_GHOST);
-                        break;
+                    me->SetDisplayId(MODEL_SKELETON);
+                    Talk(SAY_PHASE_2);
+                }
+                else if (uiPhase == PHASE_SKELETON)
+                {
+                    me->SetDisplayId(MODEL_GHOST);
+                    SetEquipmentSlots(false, EQUIP_UNEQUIP, EQUIP_NO_CHANGE, EQUIP_NO_CHANGE);
+                    Talk(SAY_PHASE_3);
                 }
-                bEventInProgress = true;
+                ++uiPhase;
+                LoadEvents();
             }
         }
 
-        void JustDied(Unit* /*killer*/) override
+        void MovementInform(uint32 type, uint32 id) override
         {
-            DoCast(me, SPELL_KILL_CREDIT);
+            if (type != POINT_MOTION_TYPE)
+                return;
 
-            instance->SetData(BOSS_BLACK_KNIGHT, DONE);
+            if (id == 0)
+            {
+                if (Creature* announcer = instance->GetCreature(DATA_ANNOUNCER))
+                    announcer->AI()->SetData(DATA_BLACK_KNIGHT_PRECAST, 0);
+            }
         }
-    };
 
-    CreatureAI* GetAI(Creature* creature) const override
-    {
-        return GetInstanceAI<boss_black_knightAI>(creature);
-    }
-};
+        void JustSummoned(Creature* summon) override
+        {
+            if (summon->GetEntry() == NPC_DESECRATION_STALKER)
+            {
+                summon->CastSpell(summon, SPELL_DESECRATION_DND, true);
+                summon->CastSpell(summon, SPELL_DESECRATION_ARM, true);
+                return;
+            }
+            summons.Summon(summon);
+            summon->AI()->AttackStart(me->GetVictim());
+        }
 
-class npc_risen_ghoul : public CreatureScript
-{
-public:
-    npc_risen_ghoul() : CreatureScript("npc_risen_ghoul") { }
+        void SummonedCreatureDespawn(Creature* summon) override
+        {
+            summons.Despawn(summon);
+        }
 
-    struct npc_risen_ghoulAI : public ScriptedAI
-    {
-        npc_risen_ghoulAI(Creature* creature) : ScriptedAI(creature)
+        void DamageTaken(Unit* /*done_by*/, uint32& damage) override
         {
-            Initialize();
+            if (damage >= me->GetHealth() && uiPhase < PHASE_GHOST)
+            {
+                damage = 0;
+                events.Reset();
+                me->RemoveAllAuras();
+                me->SetHealth(0);
+                me->SetStandState(UNIT_STAND_STATE_DEAD);
+                DoCast(me, SPELL_BLACK_KNIGHT_DIE);
+                for (SummonList::const_iterator itr = summons.begin(); itr != summons.end(); ++itr)
+                {
+                    Creature* ghoul = ObjectAccessor::GetCreature(*me, *itr);
+                    if (ghoul && ghoul->IsAlive() && !ghoul->HasAura(SPELL_GHOUL_EXPLODE))
+                        ENSURE_AI(npc_risen_ghoul::npc_risen_ghoulAI, ghoul->AI())->DoExplode();
+                }
+            }
         }
 
-        void Initialize()
+        void JustDied(Unit* /*killer*/) override
         {
-            uiAttackTimer = 3500;
+            Talk(SAY_DEATH);
+            instance->DoUpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_BE_SPELL_TARGET, SPELL_KILL_CREDIT, 0, me);
+            _JustDied();
         }
 
-        uint32 uiAttackTimer;
+        void EnterCombat(Unit* who) override
+        {
+            LoadEvents();
+            Talk(SAY_AGGRO, who);
+            _EnterCombat();
+        }
 
-        void Reset() override
+        void KilledUnit(Unit* who) override
         {
-            Initialize();
+            Talk(SAY_KILL, who);
         }
 
         void UpdateAI(uint32 uiDiff) override
         {
+            events.Update(uiDiff);
+
+            if (me->HasUnitState(UNIT_STATE_CASTING))
+                return;
+
             if (!UpdateVictim())
                 return;
 
-            if (uiAttackTimer <= uiDiff)
+            while (uint32 eventId = events.ExecuteEvent())
             {
-                if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 1, 100, true))
+                switch (eventId)
                 {
-                    if (target && target->IsAlive())
-                        DoCast(target, (SPELL_LEAP));
+                    case EVENT_ICY_TOUCH:
+                        DoCastVictim(SPELL_ICY_TOUCH);
+                        events.ScheduleEvent(EVENT_PLAGUE_STRIKE, 1000);
+                        break;
+                    case EVENT_PLAGUE_STRIKE:
+                        DoCastVictim(SPELL_PLAGUE_STRIKE);
+                        events.ScheduleEvent(EVENT_OBLITERATE, 5000);
+                        break;
+                    case EVENT_OBLITERATE:
+                        DoCastVictim(SPELL_OBLITERATE);
+                        events.ScheduleEvent(EVENT_ICY_TOUCH, urand(5000, 8000));
+                        break;
+                    case EVENT_DEATH_RESPITE:
+                        // TODO: fixing this later
+                        if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 1, 50.0f, true))
+                            DoCast(target, SPELL_DEATH_RESPITE);
+                        events.ScheduleEvent(EVENT_DEATH_RESPITE, urand(15000, 16000));
+                        break;
+                    case EVENT_DESECRATION:
+                        DoCastVictim(SPELL_DESECRATION);
+                        events.ScheduleEvent(EVENT_DESECRATION, urand(15000, 16000));
+                        break;
+                    case EVENT_GHOUL_EXPLODE:
+                        DoCastAOE(SPELL_GHOUL_EXPLODE);
+                        events.ScheduleEvent(EVENT_GHOUL_EXPLODE, urand(15000, 16000));
+                        break;
+                    case EVENT_DEATH_BITE:
+                        DoCastAOE(SPELL_DEATH_BITE);
+                        events.ScheduleEvent(EVENT_DEATH_BITE, 3000);
+                        break;
+                    case EVENT_MARKED_DEATH:
+                        if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 0, 50.0f))
+                            DoCast(target, SPELL_MARKED_DEATH);
+                        events.ScheduleEvent(EVENT_MARKED_DEATH, urand(13000, 15000));
+                        break;
+                    default:
+                        break;
                 }
-                uiAttackTimer = 3500;
-            } else uiAttackTimer -= uiDiff;
-
+            }
             DoMeleeAttackIfReady();
         }
     };
 
     CreatureAI* GetAI(Creature* creature) const override
     {
-        return new npc_risen_ghoulAI(creature);
+        return GetInstanceAI<boss_black_knightAI>(creature);
     }
 };
 
@@ -358,10 +497,74 @@ class npc_black_knight_skeletal_gryphon : public CreatureScript
     {
         npc_black_knight_skeletal_gryphonAI(Creature* creature) : npc_escortAI(creature)
         {
-            Start(false, true);
+            me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+            me->SetReactState(REACT_PASSIVE);
+            me->SetCanFly(true);
+            me->SetDisableGravity(true);
+            SetDespawnAtEnd(true);
+
+            uiWaypointPath = 0;
+            instance = creature->GetInstanceScript();
+        }
+
+        InstanceScript* instance;
+        uint32 uiWaypointPath;
+
+        void SetData(uint32 uiType, uint32 /*uiData*/) override
+        {
+            if (uiType == 1)
+            {
+                // Black Knight is flying towards arena
+                AddWaypoint(0, 766.99f, 657.16f, 457.43f);
+                AddWaypoint(1, 747.28f, 659.71f, 440.49f);
+                AddWaypoint(2, 730.03f, 639.59f, 428.16f);
+                AddWaypoint(3, 721.13f, 621.49f, 423.16f);
+                AddWaypoint(4, 731.72f, 599.81f, 421.99f);
+                AddWaypoint(5, 753.71f, 591.09f, 420.63f);
+                AddWaypoint(6, 776.53f, 597.52f, 418.05f);
+                AddWaypoint(7, 787.38f, 617.07f, 417.49f);
+                AddWaypoint(8, 777.06f, 636.98f, 416.57f);
+                AddWaypoint(9, 760.6f, 642.12f, 414.71f);
+                AddWaypoint(10, 752.58f, 632.35f, 411.63f);
+                // The vehicle starts flying away
+                AddWaypoint(11, 748.89f, 633.61f, 415.24f);
+                AddWaypoint(12, 740.42f, 636.31f, 418.32f);
+                AddWaypoint(13, 727.49f, 637.4f, 422.24f);
+                AddWaypoint(14, 716.59f, 617.99f, 422.24f);
+                AddWaypoint(15, 727.18f, 599.29f, 422.24f);
+                AddWaypoint(16, 746.63f, 587.77f, 422.24f);
+                AddWaypoint(17, 765.6f, 599.52f, 422.24f);
+                AddWaypoint(18, 777.01f, 618.79f, 422.24f);
+                AddWaypoint(19, 761.84f, 642.18f, 422.24f);
+                AddWaypoint(20, 746.09f, 670.33f, 429.68f);
+                AddWaypoint(21, 748.02f, 728.22f, 466.68f);
+                AddWaypoint(22, 779.44f, 797.49f, 477.79f);
+                AddWaypoint(23, 859.14f, 807.98f, 477.79f);
+                Start(false, true);
+            }
+            else if (uiType == 2)
+            {
+                me->SetCanFly(true);
+                me->SetDisableGravity(true);
+                SetEscortPaused(false);
+            }
         }
 
-        void WaypointReached(uint32 /*waypointId*/) override { }
+        void WaypointReached(uint32 waypointId) override 
+        {
+            if (waypointId == 10)
+            {
+                // Reached to arena
+                SetEscortPaused(true);
+                me->SetCanFly(false);
+                me->SetDisableGravity(false);
+                if (Creature* announcer = instance->GetCreature(DATA_ANNOUNCER))
+                {
+                    me->SetFacingToObject(announcer);
+                    announcer->AI()->SetData(DATA_BLACK_KNIGHT_PREPARE, 0);
+                }
+            }
+        }
 
         void UpdateAI(uint32 uiDiff) override
         {
@@ -378,9 +581,184 @@ class npc_black_knight_skeletal_gryphon : public CreatureScript
     }
 };
 
+class spell_black_knight_deaths_push : public SpellScriptLoader
+{
+    public:
+        spell_black_knight_deaths_push() : SpellScriptLoader("spell_black_knight_deaths_push") { }
+
+        class spell_black_knight_deaths_push_AuraScript : public AuraScript
+        {
+            PrepareAuraScript(spell_black_knight_deaths_push_AuraScript);
+
+            bool Validate(SpellInfo const* /*spellInfo*/) override
+            {
+                if (!sSpellMgr->GetSpellInfo(SPELL_DEATH_RESPITE_DND) ||
+                    !sSpellMgr->GetSpellInfo(SPELL_FEIGN_DEATH))
+                    return false;
+                return true;
+            }
+
+            void HandleScript(AuraEffect const* /*aurEff*/, AuraEffectHandleModes /*mode*/)
+            {
+                // The spell applies a dummy aura with short duration
+                // when the dummy aura is removed, announcer 'dies'
+                GetTarget()->RemoveAura(SPELL_DEATH_RESPITE_DND);
+                GetTarget()->CastSpell(GetTarget(), SPELL_FEIGN_DEATH, true);
+                GetTarget()->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+            }
+
+            void Register() override
+            {
+                AfterEffectRemove += AuraEffectRemoveFn(spell_black_knight_deaths_push_AuraScript::HandleScript, EFFECT_1, SPELL_AURA_DUMMY, AURA_EFFECT_HANDLE_REAL);
+            }
+        };
+
+        AuraScript* GetAuraScript() const override
+        {
+            return new spell_black_knight_deaths_push_AuraScript();
+        }
+};
+
+class spell_black_knight_obliterate : public SpellScriptLoader
+{
+    public:
+        spell_black_knight_obliterate() : SpellScriptLoader("spell_black_knight_obliterate") { }
+
+        class spell_black_knight_obliterate_SpellScript : public SpellScript
+        {
+            PrepareSpellScript(spell_black_knight_obliterate_SpellScript);
+
+            bool Validate(SpellInfo const* /*spellInfo*/) override
+            {
+                if (!sSpellMgr->GetSpellInfo(SPELL_BLOOD_PLAGUE) ||
+                    !sSpellMgr->GetSpellInfo(SPELL_FROST_FEVER) ||
+                    !sSpellMgr->GetSpellInfo(SPELL_BLOOD_PLAGUE_H) ||
+                    !sSpellMgr->GetSpellInfo(SPELL_FROST_FEVER_H))
+                    return false;
+                return true;
+            }
+
+            void CalculateDamage()
+            {
+                if (!GetHitUnit())
+                    return;
+                uint32 bloodPlague = GetCaster()->GetMap()->IsHeroic() ? SPELL_BLOOD_PLAGUE_H : SPELL_BLOOD_PLAGUE;
+                uint32 frostFever = GetCaster()->GetMap()->IsHeroic() ? SPELL_FROST_FEVER_H : SPELL_FROST_FEVER;
+
+                int32 damage = GetHitDamage();
+                int32 bonus = 0;
+                if (GetHitUnit()->HasAura(frostFever))
+                {
+                    bonus += int32(damage * 0.3f);
+                    GetHitUnit()->RemoveAurasDueToSpell(frostFever);
+                }
+                if (GetHitUnit()->HasAura(bloodPlague))
+                {
+                    bonus += int32(damage * 0.3f);
+                    GetHitUnit()->RemoveAurasDueToSpell(bloodPlague);
+                }
+                SetHitDamage(damage + bonus);
+            }
+
+            void Register() override
+            {
+                OnHit += SpellHitFn(spell_black_knight_obliterate_SpellScript::CalculateDamage);
+            }
+        };
+
+        SpellScript* GetSpellScript() const override
+        {
+            return new spell_black_knight_obliterate_SpellScript();
+        }
+};
+
+class spell_black_knight_army_of_the_dead : public SpellScriptLoader
+{
+    public:
+        spell_black_knight_army_of_the_dead() : SpellScriptLoader("spell_black_knight_army_of_the_dead") { }
+
+        class spell_black_knight_army_of_the_dead_AuraScript : public AuraScript
+        {
+            PrepareAuraScript(spell_black_knight_army_of_the_dead_AuraScript);
+
+            void RemoveFlag(AuraEffect const* /*aurEff*/, AuraEffectHandleModes /*mode*/)
+            {
+                // that is wrong, movement disabled by spell (channel)
+                // On aura remove we must remove disable movement flag
+                if (Unit* caster = GetCaster())
+                    caster->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_DISABLE_MOVE);
+            }
+
+            void Register() override
+            {
+                AfterEffectRemove += AuraEffectRemoveFn(spell_black_knight_army_of_the_dead_AuraScript::RemoveFlag, EFFECT_0, SPELL_AURA_PERIODIC_TRIGGER_SPELL, AURA_EFFECT_HANDLE_REAL);
+            }
+        };
+
+        AuraScript* GetAuraScript() const override
+        {
+            return new spell_black_knight_army_of_the_dead_AuraScript();
+        }
+};
+
+class spell_black_knight_ghoul_explode : public SpellScriptLoader
+{
+    public:
+        spell_black_knight_ghoul_explode() : SpellScriptLoader("spell_black_knight_ghoul_explode") { }
+
+        class spell_black_knight_ghoul_explode_AuraScript : public AuraScript
+        {
+            PrepareAuraScript(spell_black_knight_ghoul_explode_AuraScript);
+
+            bool Validate(SpellInfo const* /*spellInfo*/) override
+            {
+                if (!sSpellMgr->GetSpellInfo(SPELL_EXPLODE))
+                    return false;
+                return true;
+            }
+
+            void CastExplode(AuraEffect const* /*aurEff*/, AuraEffectHandleModes /*mode*/)
+            {
+                // On Ghoul Explode aura apply, start casting Explode
+                GetTarget()->CastSpell(GetTarget(), SPELL_EXPLODE);
+            }
+
+            void Register() override
+            {
+                AfterEffectApply += AuraEffectApplyFn(spell_black_knight_ghoul_explode_AuraScript::CastExplode, EFFECT_0, SPELL_AURA_PERIODIC_TRIGGER_SPELL, AURA_EFFECT_HANDLE_REAL);
+            }
+        };
+
+        AuraScript* GetAuraScript() const override
+        {
+            return new spell_black_knight_ghoul_explode_AuraScript();
+        }
+};
+
+// Achievement id 3804 - I've Had Worse
+class achievement_ive_had_worse : public AchievementCriteriaScript
+{
+    public:
+        achievement_ive_had_worse() : AchievementCriteriaScript("achievement_ive_had_worse") { }
+
+        bool OnCheck(Player* /*player*/, Unit* target) override
+        {
+            if (target->GetEntry() != NPC_BLACK_KNIGHT)
+                return false;
+            if (!ENSURE_AI(boss_black_knight::boss_black_knightAI, target->GetAI())->achievementCredit)
+                return false;
+            return true;
+        }
+};
+
 void AddSC_boss_black_knight()
 {
     new boss_black_knight();
     new npc_risen_ghoul();
     new npc_black_knight_skeletal_gryphon();
+    new spell_black_knight_deaths_push();
+    new spell_black_knight_obliterate();
+    new spell_black_knight_army_of_the_dead();
+    new spell_black_knight_ghoul_explode();
+    new achievement_ive_had_worse();
 }
diff --git a/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheChampion/boss_grand_champions.cpp b/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheChampion/boss_grand_champions.cpp
index 154f14d..a6c630c 100644
--- a/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheChampion/boss_grand_champions.cpp
+++ b/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheChampion/boss_grand_champions.cpp
@@ -18,132 +18,673 @@
 
 /* ScriptData
 SDName: boss_grand_champions
-SD%Complete: 50 %
-SDComment: Is missing the ai to make the npcs look for a new mount and use it.
+SD%Complete: 99%
+SDComment: Cosmetic things missing
 SDCategory: Trial Of the Champion
 EndScriptData */
 
-#include "ScriptMgr.h"
+#include "GridNotifiers.h"
+#include "Player.h"
 #include "ScriptedCreature.h"
 #include "ScriptedEscortAI.h"
+#include "ScriptMgr.h"
+#include "SpellAuraEffects.h"
+#include "SpellScript.h"
 #include "Vehicle.h"
 #include "trial_of_the_champion.h"
-#include "Player.h"
+
+enum Events
+{
+    // Grand Champion
+    EVENT_WALK_TO_MOUNT                 = 1,
+    EVENT_START_ATTACK_JOUST,
+    EVENT_TRAMPLE,
+    EVENT_EVADE_MODE,
+    EVENT_START_ATTACK_REAL,
+    EVENT_DESPAWN,
+    // General vehicle AI
+    EVENT_BUFF_SHIELD,
+    EVENT_BUFF_FLAG,
+    EVENT_MOUNT_CHARGE,
+    EVENT_SHIELD_BREAKER,
+    // Warrior - Grand Champion
+    EVENT_BLADESTORM,
+    EVENT_INTERCEPT,
+    EVENT_MORTAL_STRIKE,
+    EVENT_ROLLING_THROW,
+    // Mage - Grand Champion
+    EVENT_FIREBALL,
+    EVENT_BLASTWAVE,
+    EVENT_HASTE,
+    EVENT_POLYMORPH,
+    // Shaman - Grand Champion
+    EVENT_DEF_CHECK,
+    EVENT_CHAIN_LIGHTNING,
+    EVENT_HEALING_WAVE,
+    EVENT_EARTH_SHIELD,
+    EVENT_HEX_MENDING,
+    // Hunter - Grand Champion
+    EVENT_MULTI_SHOT,
+    EVENT_LIGHTNING_ARROWS,
+    EVENT_DISENGAGE,
+    // Rogue - Grand Champion
+    EVENT_DEADLY_POISON,
+    EVENT_EVISCERATE,
+    EVENT_FAN_OF_KNIVES,
+    EVENT_POISON_BOTTLE
+};
 
 enum Spells
 {
-    //Vehicle
-    SPELL_CHARGE                    = 63010,
-    SPELL_SHIELD_BREAKER            = 68504,
-    SPELL_SHIELD                    = 66482,
+    // Vehicle
+    SPELL_CHARGE_GRAND_CHAMP            = 68321,
+    SPELL_CHARGE_LESSER_CHAMP           = 63010,
+    SPELL_SHIELD_BREAKER                = 68504,
+    SPELL_SHIELD_GRAND_CHAMP            = 62719,
+    SPELL_SHIELD_LESSER_CHAMP           = 64100,
+    SPELL_TRAMPLE_DUMMY_AURA            = 67870, // triggers trample aura every 1 second, used by all vehicles
+    SPELL_TRAMPLE_AURA                  = 67868, // actual trample stun
+
+    // General
+    SPELL_ACHIEVEMENT_CREDIT            = 68572, // dummy spell for achievement credit (IDs 4297, 4298, 3778, 4296)
+    SPELL_KNEEL                         = 68442,
 
     // Marshal Jacob Alerius && Mokra the Skullcrusher || Warrior
-    SPELL_MORTAL_STRIKE             = 68783,
-    SPELL_MORTAL_STRIKE_H           = 68784,
-    SPELL_BLADESTORM                = 63784,
-    SPELL_INTERCEPT                 = 67540,
-    SPELL_ROLLING_THROW             = 47115, //not implemented in the AI yet...
+    SPELL_MORTAL_STRIKE                 = 68783,
+    SPELL_BLADESTORM                    = 67541,
+    SPELL_INTERCEPT                     = 67540,
+    SPELL_ROLLING_THROW                 = 67546,
 
     // Ambrose Boltspark && Eressea Dawnsinger || Mage
-    SPELL_FIREBALL                  = 66042,
-    SPELL_FIREBALL_H                = 68310,
-    SPELL_BLAST_WAVE                = 66044,
-    SPELL_BLAST_WAVE_H              = 68312,
-    SPELL_HASTE                     = 66045,
-    SPELL_POLYMORPH                 = 66043,
-    SPELL_POLYMORPH_H               = 68311,
+    SPELL_FIREBALL                      = 66042,
+    SPELL_BLAST_WAVE                    = 66044,
+    SPELL_HASTE                         = 66045,
+    SPELL_POLYMORPH                     = 66043,
 
     // Colosos && Runok Wildmane || Shaman
-    SPELL_CHAIN_LIGHTNING           = 67529,
-    SPELL_CHAIN_LIGHTNING_H         = 68319,
-    SPELL_EARTH_SHIELD              = 67530,
-    SPELL_HEALING_WAVE              = 67528,
-    SPELL_HEALING_WAVE_H            = 68318,
-    SPELL_HEX_OF_MENDING            = 67534,
+    SPELL_CHAIN_LIGHTNING               = 67529,
+    SPELL_EARTH_SHIELD                  = 67530,
+    SPELL_HEALING_WAVE                  = 67528,
+    SPELL_HEX_OF_MENDING                = 67534,
 
     // Jaelyne Evensong && Zul'tore || Hunter
-    SPELL_DISENGAGE                 = 68340, //not implemented in the AI yet...
-    SPELL_LIGHTNING_ARROWS          = 66083,
-    SPELL_MULTI_SHOT                = 66081,
-    SPELL_SHOOT                     = 65868,
-    SPELL_SHOOT_H                   = 67988,
-
-    // Lana Stouthammer Evensong && Deathstalker Visceri || Rouge
-    SPELL_EVISCERATE                = 67709,
-    SPELL_EVISCERATE_H              = 68317,
-    SPELL_FAN_OF_KNIVES             = 67706,
-    SPELL_POISON_BOTTLE             = 67701
+    SPELL_DISENGAGE                     = 68339, // 68340 is correct disengage but spell needs to be scripted
+    SPELL_LIGHTNING_ARROWS              = 66083,
+    SPELL_LIGHTNING_ARROWS_AURA         = 66085,
+    SPELL_MULTI_SHOT                    = 66081,
+    SPELL_SHOOT                         = 66079,
+
+    // Lana Stouthammer && Deathstalker Visceri || Rouge
+    SPELL_EVISCERATE                    = 67709,
+    SPELL_FAN_OF_KNIVES                 = 67706,
+    SPELL_POISON_BOTTLE                 = 67701,
+    SPELL_DEADLY_POISON                 = 67711
 };
 
-enum Seats
+enum Texts
 {
-    SEAT_ID_0                       = 0
+    EMOTE_TRAMPLE                       = 0
 };
 
-/*
-struct Point
+enum PointMovement
 {
-    float x, y, z;
+    POINT_REMOUNT                       = 0,
+    POINT_DESPAWN
 };
 
-const Point MovementPoint[] =
+void EnterAggressiveMode(Creature* temp)
 {
-  {746.84f, 623.15f, 411.41f},
-  {747.96f, 620.29f, 411.09f},
-  {750.23f, 618.35f, 411.09f}
-};
+    temp->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_IMMUNE_TO_PC);
+    temp->SetReactState(REACT_AGGRESSIVE);
+}
+
+void DoCastPennant(Creature* me)
+{
+    switch (me->GetEntry())
+    {
+        case NPC_MOKRA:
+            me->CastSpell(me, SPELL_FLAG_ORGRIMMAR);
+            break;
+        case NPC_ERESSEA:
+            me->CastSpell(me, SPELL_FLAG_SILVERMOON);
+            break;
+        case NPC_RUNOK:
+            me->CastSpell(me, SPELL_FLAG_THUNDER_BLUFF);
+            break;
+        case NPC_ZULTORE:
+            me->CastSpell(me, SPELL_FLAG_SENJIN);
+            break;
+        case NPC_VISCERI:
+            me->CastSpell(me, SPELL_FLAG_UNDERCITY);
+            break;
+        case NPC_JACOB:
+            me->CastSpell(me, SPELL_FLAG_STORMWIND);
+            break;
+        case NPC_AMBROSE:
+            me->CastSpell(me, SPELL_FLAG_GNOMEREGAN);
+            break;
+        case NPC_COLOSOS:
+            me->CastSpell(me, SPELL_FLAG_EXODAR);
+            break;
+        case NPC_JAELYNE:
+            me->CastSpell(me, SPELL_FLAG_DARNASSUS);
+            break;
+        case NPC_LANA:
+            me->CastSpell(me, SPELL_FLAG_IRONFORGE);
+            break;
+        default:
+            break;
+    }
+    if (me->GetVehicleBase())
+        me->CastSpell(me->GetVehicleBase(), SPELL_TRAMPLE_DUMMY_AURA, true);
+}
+
+Creature* FindMyMount(Creature* me, bool newMount = false)
+{
+    InstanceScript* instance = me->GetInstanceScript();
+    if (newMount)
+    {
+        // Summoning a new vehicle if all others are used
+        // can but should not occur
+        uint32 tmpEntry = instance->GetData(DATA_TEAM_IN_INSTANCE) == ALLIANCE ? VEHICLE_ARGENT_BATTLEWORG_COSMETIC : VEHICLE_ARGENT_WARHORSE_COSMETIC;
+        if (Creature* mount = me->SummonCreature(tmpEntry, bossExitPos, TEMPSUMMON_CORPSE_TIMED_DESPAWN, 10000))
+        {
+            if (instance->GetGuidData(DATA_GRAND_CHAMPION_1) == me->GetGUID())
+                instance->SetGuidData(DATA_GRAND_CHAMPION_VEHICLE_1, mount->GetGUID());
+            else if (instance->GetGuidData(DATA_GRAND_CHAMPION_2) == me->GetGUID())
+                instance->SetGuidData(DATA_GRAND_CHAMPION_VEHICLE_2, mount->GetGUID());
+            else if (instance->GetGuidData(DATA_GRAND_CHAMPION_3) == me->GetGUID())
+                instance->SetGuidData(DATA_GRAND_CHAMPION_VEHICLE_3, mount->GetGUID());
+            mount->SetOrientation(centerOrientation);
+            mount->SetHomePosition(me->GetHomePosition());
+            return mount;
+        }
+    }
+    if (me->GetGUID() == instance->GetGuidData(DATA_GRAND_CHAMPION_1))
+        return ObjectAccessor::GetCreature(*me, instance->GetGuidData(DATA_GRAND_CHAMPION_VEHICLE_1));
+    else if (me->GetGUID() == instance->GetGuidData(DATA_GRAND_CHAMPION_2))
+        return ObjectAccessor::GetCreature(*me, instance->GetGuidData(DATA_GRAND_CHAMPION_VEHICLE_2));
+    else if (me->GetGUID() == instance->GetGuidData(DATA_GRAND_CHAMPION_3))
+        return ObjectAccessor::GetCreature(*me, instance->GetGuidData(DATA_GRAND_CHAMPION_VEHICLE_3));
+
+    // should not happen
+    return nullptr;
+}
+
+// called on rider
+void SetGrandChampionToEvadeMode(Creature* me)
+{
+    me->RemoveAllAuras();
+    me->ApplySpellImmune(SPELL_TRAMPLE_AURA, IMMUNITY_ID, SPELL_TRAMPLE_AURA, false);
+    me->DeleteThreatList();
+    me->CombatStop(true);
+    me->SetLootRecipient(nullptr);
+    me->AI()->Reset();
+    if (Creature* mount = FindMyMount(me))
+    {
+        mount->AI()->Reset();
+        EnterAggressiveMode(mount);
+        mount->GetMotionMaster()->Clear();
+        mount->GetMotionMaster()->MoveTargetedHome();
+    }
+    DoCastPennant(me);
+    // On reset Grand Champions' flags are restored to DB values and we don't want that
+    EnterAggressiveMode(me);
+}
+
+/*
+* Generic AI for Grand Champions in ToC.                    *
+* Script Complete: 100%                                     *
 */
-void AggroAllPlayers(Creature* temp)
+
+struct boss_grand_championAI : BossAI
 {
-    Map::PlayerList const &PlList = temp->GetMap()->GetPlayers();
+    boss_grand_championAI(Creature* creature) : BossAI(creature, DATA_GRAND_CHAMPIONS)
+    {
+        LookingForMount = false;
+        MountedPhaseDone = false;
+        IsChampionDown = false;
+        bDone = false;
+        bHome = false;
 
-    if (PlList.isEmpty())
+        uiPhase = 0;
+    }
+    uint8 uiPhase;
+
+    bool LookingForMount; // if is in looking for mount phase
+    bool MountedPhaseDone; // if jousting phase is done
+    bool IsChampionDown; // if champion is defeated
+    bool bDone; // if all champions have been downed
+    bool bHome; // if champion has reached home after jousing phase
+
+    void Reset() override
+    {
+        if (MountedPhaseDone)
+            DoCastPennant(me);
+        if (IsChampionDown)
+            IsChampionDown = false;
+        _Reset();
+    }
+    
+    bool GrandChampionsOutOfVehicles()
+    {
+        for (int i = 0; i < 3; i++)
+        {
+            if (Creature* pGrandChampion = ObjectAccessor::GetCreature(*me, instance->GetGuidData(DATA_GRAND_CHAMPION_1 + i)))
+            {
+                if (pGrandChampion->GetVehicleBase())
+                    return false;
+            }
+        }
+        return true;
+    }
+
+    bool GrandChampionsDefeated()
+    {
+        for (int i = 0; i < 3; i++)
+        {
+            if (Creature* pGrandChampion = ObjectAccessor::GetCreature(*me, instance->GetGuidData(DATA_GRAND_CHAMPION_1 + i)))
+            {
+                if (!pGrandChampion->HasAura(SPELL_KNEEL))
+                    return false;
+            }
+        }
+        return true;
+    }
+    
+    void AttackRandomPlayer()
+    {
+        Map::PlayerList const &players = me->GetMap()->GetPlayers();
+        if (players.isEmpty())
             return;
+    
+        for (Map::PlayerList::const_iterator itr = players.begin(); itr != players.end(); ++itr)
+        {
+            Player *plr = itr->GetSource();
+            if (plr && !plr->IsGameMaster() && plr->IsAlive())
+            {
+                for (int i = 0; i < 3; i++)
+                {
+                    if (Creature* pGrandChampion = ObjectAccessor::GetCreature(*me, instance->GetGuidData(DATA_GRAND_CHAMPION_1 + i)))
+                    {
+                        EnterAggressiveMode(pGrandChampion);
+                        if (!pGrandChampion->IsInCombat())
+                            pGrandChampion->AI()->AttackStart(plr);
+                    }
+                }
+                break;
+            }
+        }
+    }
+
+    bool CanUseNormalAI()
+    {
+        // must check for unattackable flag to prevent crash in certain situations
+        return !UpdateVictim() || me->GetVehicleBase() || LookingForMount || me->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE) || !MountedPhaseDone;
+    }
 
-    for (Map::PlayerList::const_iterator i = PlList.begin(); i != PlList.end(); ++i)
+    void EnterEvadeMode(EvadeReason why = EVADE_REASON_OTHER) override
     {
-        if (Player* player = i->GetSource())
+        if (LookingForMount || !MountedPhaseDone)
+            return;
+
+        // we must check if other champions have been downed and call evade for them
+        // for example, if players wipe during killing the last champion
+        for (int i = 0; i < 3; ++i)
+        {
+            if (Creature* pGrandChampion = ObjectAccessor::GetCreature(*me, instance->GetGuidData(DATA_GRAND_CHAMPION_1 + i)))
+            {
+                if (pGrandChampion->HasAura(SPELL_KNEEL))
+                {
+                    pGrandChampion->RemoveAllAuras();
+                    pGrandChampion->DeleteThreatList();
+                    pGrandChampion->SetLootRecipient(nullptr);
+                    pGrandChampion->setRegeneratingHealth(true);
+                    pGrandChampion->GetMotionMaster()->MoveTargetedHome();
+                    pGrandChampion->AI()->Reset();
+                }
+            }
+        }
+        BossAI::EnterEvadeMode(why);
+    }
+
+    void JustReachedHome() override
+    {
+        if (bHome)
+        {
+            // Champions will be unattackable for 15 seconds when reached their homepositions for first time after jousting event
+            // After that time, they will start attacking a random player
+            // if group wipes during actual fight, grand champions will be attackable immediately when reached home position
+            uiPhase = 4;
+            events.ScheduleEvent(EVENT_START_ATTACK_REAL, 15000);
+            bHome = false;
+        }
+        else if (MountedPhaseDone && !bHome)
+            EnterAggressiveMode(me);
+        _JustReachedHome();
+    }
+
+    void SpellHit(Unit* /*caster*/, SpellInfo const* spell) override
+    {
+        if (spell->Id == SPELL_TRAMPLE_AURA && LookingForMount && uiPhase == 0 && !me->IsImmunedToSpell(spell))
         {
-            if (player->IsGameMaster())
-                continue;
+            uiPhase = 3;
+            me->GetMotionMaster()->MovementExpired();
+            me->GetMotionMaster()->MoveIdle();
+            Talk(EMOTE_TRAMPLE, me);
+            events.ScheduleEvent(EVENT_TRAMPLE, spell->GetDuration());
+        }
+    }
+
+    void MovementInform(uint32 type, uint32 id) override
+    {
+        if (type != POINT_MOTION_TYPE)
+            return;
 
-            if (player->IsAlive())
+        if (id == POINT_REMOUNT && LookingForMount)
+        {
+            // Reached point, mounting again
+            if (Creature* mount = FindMyMount(me))
             {
-                temp->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_IMMUNE_TO_PC);
-                temp->SetReactState(REACT_AGGRESSIVE);
-                temp->SetInCombatWith(player);
-                player->SetInCombatWith(temp);
-                temp->AddThreat(player, 0.0f);
+                if (!me->IsWithinDist(mount, INTERACTION_DISTANCE))
+                    return;
+
+                LookingForMount = false;
+                uiPhase = 2;
+                me->ApplySpellImmune(SPELL_TRAMPLE_AURA, IMMUNITY_ID, SPELL_TRAMPLE_AURA, true); // Champion should be immune to trample here
+                me->GetMotionMaster()->Clear();
+                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE); // to prevent boss from bugging out
+                me->SetHealth(me->GetMaxHealth());
+                me->setRegeneratingHealth(true);
+                me->SetWalk(false);
+                mount->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+                // sometimes a player can trample champion right when he is about to enter in vehicle
+                // it will bug the boss and you can kill him without the need to kill others as well
+                // so we remove the stun aura just incase
+                me->RemoveAura(SPELL_TRAMPLE_AURA);
+                me->EnterVehicle(mount, SEAT_ID_0);
+
+                // In rare scenario all players can die meanwhile one of the champions is going for new mount, and then the champion ends in a bugged state
+                // so we must check do we have alive players in the map first, else we call evade
+                bool foundPlr = false;
+                Map::PlayerList const& players = me->GetMap()->GetPlayers();
+                for (Map::PlayerList::const_iterator itr = players.begin(); itr != players.end(); ++itr)
+                {
+                    Player* player = itr->GetSource();
+                    if (player && !player->IsGameMaster() && player->IsAlive())
+                    {
+                        foundPlr = true;
+                        break;
+                    }
+                }
+                if (foundPlr)
+                    events.ScheduleEvent(EVENT_START_ATTACK_JOUST, 2000); // slight delay before attacking
+                else
+                    SetGrandChampionToEvadeMode(me);
             }
         }
+        else if (id == POINT_DESPAWN)
+            me->DisappearAndDie();
     }
-}
 
-bool GrandChampionsOutVehicle(Creature* me)
-{
-    InstanceScript* instance = me->GetInstanceScript();
+    void DamageTaken(Unit* /*attacker*/, uint32& damage) override
+    {
+        if (damage >= me->GetHealth() && me->GetVehicleBase())
+        {
+            damage = 0;
+            LookingForMount = true;
+            uiPhase = 1;
+            me->ApplySpellImmune(SPELL_TRAMPLE_AURA, IMMUNITY_ID, SPELL_TRAMPLE_AURA, true); // Champion should be immune to trample here
+            me->ExitVehicle();
+            me->RemoveAllAuras();
+            DoCastPennant(me);
+            me->SetReactState(REACT_PASSIVE);
+            me->SetHealth(1);
+            me->CombatStop(true);
+            me->setRegeneratingHealth(false); // we don't regen health yet
+            me->GetMotionMaster()->MoveIdle();
+            me->SetWalk(true);
+            // Champion's current vehicle runs to the gates and despawns
+            // Champion will search for new mount
+            if (Creature* mount = FindMyMount(me))
+            {
+                mount->GetMotionMaster()->Clear();
+                mount->SetWalk(false);
+                mount->SetReactState(REACT_PASSIVE);
+                mount->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                
+                uint32 newMountEntry = instance->GetData(DATA_TEAM_IN_INSTANCE) == ALLIANCE ? VEHICLE_ARGENT_BATTLEWORG_COSMETIC : VEHICLE_ARGENT_WARHORSE_COSMETIC;
+                Creature* newMount = nullptr;
+                float dist = 0.0f;
+                std::list<Creature*> tempList;
+
+                Trinity::AllCreaturesOfEntryInRange check(me, newMountEntry, 100);
+                Trinity::CreatureListSearcher<Trinity::AllCreaturesOfEntryInRange> searcher(me, tempList, check);
+                me->VisitNearbyGridObject(me->GetGridActivationRange(), searcher);
+
+                for (std::list<Creature*>::const_iterator itr = tempList.begin(); itr != tempList.end(); ++itr)
+                {
+                    Creature* tmpMount = *itr;
+
+                    if (instance->GetGuidData(DATA_GRAND_CHAMPION_VEHICLE_1) == tmpMount->GetGUID() ||
+                        instance->GetGuidData(DATA_GRAND_CHAMPION_VEHICLE_2) == tmpMount->GetGUID() ||
+                        instance->GetGuidData(DATA_GRAND_CHAMPION_VEHICLE_3) == tmpMount->GetGUID())
+                        continue;
 
-    if (!instance)
-        return false;
+                    if (!tmpMount->IsAlive())
+                        continue;
 
-    Creature* pGrandChampion1 = ObjectAccessor::GetCreature(*me, instance->GetGuidData(DATA_GRAND_CHAMPION_1));
-    Creature* pGrandChampion2 = ObjectAccessor::GetCreature(*me, instance->GetGuidData(DATA_GRAND_CHAMPION_2));
-    Creature* pGrandChampion3 = ObjectAccessor::GetCreature(*me, instance->GetGuidData(DATA_GRAND_CHAMPION_3));
+                    if (dist == 0)
+                    {
+                        dist = me->GetDistance(tmpMount);
+                        newMount = tmpMount;
+                    }
+
+                    if (me->GetDistance(tmpMount) < dist)
+                    {
+                        dist = me->GetDistance(tmpMount);
+                        newMount = tmpMount;
+                    }
+                }
+                if (newMount)
+                {
+                    if (instance->GetGuidData(DATA_GRAND_CHAMPION_1) == me->GetGUID())
+                        instance->SetGuidData(DATA_GRAND_CHAMPION_VEHICLE_1, newMount->GetGUID());
+                    else if (instance->GetGuidData(DATA_GRAND_CHAMPION_2) == me->GetGUID())
+                        instance->SetGuidData(DATA_GRAND_CHAMPION_VEHICLE_2, newMount->GetGUID());
+                    else if (instance->GetGuidData(DATA_GRAND_CHAMPION_3) == me->GetGUID())
+                        instance->SetGuidData(DATA_GRAND_CHAMPION_VEHICLE_3, newMount->GetGUID());
+                    newMount->SetHomePosition(mount->GetHomePosition());
+                }
+                else
+                {
+                    // Summoning a new mount for Grand Champion if every other mount have been used
+                    (void)FindMyMount(me, true);
+                }
 
-    if (pGrandChampion1 && pGrandChampion2 && pGrandChampion3)
+                // Defeated mount runs towards the center of arena and disappears
+                if (Creature* announcer = instance->GetCreature(DATA_ANNOUNCER))
+                {
+                    mount->GetMotionMaster()->Clear();
+                    mount->GetMotionMaster()->MovePoint(1, announcer->GetHomePosition());
+                }
+            }
+            events.ScheduleEvent(EVENT_WALK_TO_MOUNT, 3000); // slight delay before we go for new mount
+            return;
+        }
+        else if (damage >= me->GetHealth() && LookingForMount)
+        {
+            damage = 0;
+            return;
+        }
+        else if (damage >= me->GetHealth() && MountedPhaseDone)
+        {
+            damage = 0;
+            if (!IsChampionDown)
+            {
+                IsChampionDown = true;
+                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                me->SetReactState(REACT_PASSIVE);
+                me->SetHealth(1);
+                me->CombatStop(true);
+                me->setRegeneratingHealth(false);
+                me->GetMotionMaster()->MoveIdle();
+                me->RemoveAura(SPELL_EARTH_SHIELD);
+                me->RemoveAura(SPELL_HASTE);
+                me->RemoveAura(SPELL_LIGHTNING_ARROWS_AURA);
+                me->RemoveAura(SPELL_BLADESTORM);
+                me->CastSpell(me, SPELL_KNEEL, true);
+            }
+            return;
+        }
+        else if (bDone)
+        {
+            damage = 0;
+            return;
+        }
+    }
+
+    void EnterCombat(Unit* who) override
     {
-        if (!pGrandChampion1->HasUnitMovementFlag(MOVEMENTFLAG_ONTRANSPORT) &&
-            !pGrandChampion2->HasUnitMovementFlag(MOVEMENTFLAG_ONTRANSPORT) &&
-            !pGrandChampion3->HasUnitMovementFlag(MOVEMENTFLAG_ONTRANSPORT))
-            return true;
+        //if (MountedPhaseDone)
+        //{
+            // All champions should attack together
+            for (int i = 0; i < 3; i++)
+            {
+                Creature* pGrandChampion = ObjectAccessor::GetCreature(*me, instance->GetGuidData(DATA_GRAND_CHAMPION_1 + i));
+                if (pGrandChampion && !pGrandChampion->HasAura(SPELL_KNEEL) && !pGrandChampion->IsInCombat())
+                    pGrandChampion->AI()->AttackStart(who);
+            }
+            _EnterCombat();
+        //}
     }
 
-    return false;
-}
+    void AttackStart(Unit* who) override
+    {
+        if (LookingForMount || uiPhase != 0)
+            return;
+        if (Creature* mount = FindMyMount(me))
+            mount->AI()->AttackStart(who);
+        BossAI::AttackStart(who);
+    }
+
+    void UpdateAI(uint32 diff) override
+    {
+        events.Update(diff);
+
+        while (uint32 eventId = events.ExecuteEvent())
+        {
+            switch (eventId)
+            {
+                case EVENT_WALK_TO_MOUNT:
+                    // Starts walking for mount
+                    if (!LookingForMount)
+                        break;
+                    me->ApplySpellImmune(SPELL_TRAMPLE_AURA, IMMUNITY_ID, SPELL_TRAMPLE_AURA, false);
+                    // Sometimes boss can bug out after being thrown down from mount and reset flags to DB values
+                    me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_IMMUNE_TO_PC);
+                    me->GetMotionMaster()->Clear();
+                    if (Creature* mount = FindMyMount(me))
+                        me->GetMotionMaster()->MovePoint(POINT_REMOUNT, mount->GetPosition());
+                    break;
+                case EVENT_START_ATTACK_JOUST:
+                {
+                    // We're mounted and preparing to attack
+                    if (Creature* mount = FindMyMount(me))
+                    {
+                        me->ApplySpellImmune(SPELL_TRAMPLE_AURA, IMMUNITY_ID, SPELL_TRAMPLE_AURA, false);
+                        me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+                        DoCastPennant(me);
+                        EnterAggressiveMode(me);
+                        EnterAggressiveMode(mount);
+                        bool foundPlr = false;
+                        Map::PlayerList const& players = me->GetMap()->GetPlayers();
+                        for (Map::PlayerList::const_iterator itr = players.begin(); itr != players.end(); ++itr)
+                        {
+                            Player* player = itr->GetSource();
+                            if (player && !player->IsGameMaster() && player->IsAlive())
+                            {
+                                if (player->GetVehicleBase())
+                                    mount->AI()->AttackStart(player->GetVehicleBase());
+                                else
+                                    mount->AI()->AttackStart(player);
+                                foundPlr = true;
+                                break;
+                            }
+                        }
+                        if (!foundPlr)
+                            SetGrandChampionToEvadeMode(me);
+                    }
+                    break;
+                }
+                case EVENT_TRAMPLE:
+                    // Got trampled and continuing walking
+                    me->GetMotionMaster()->Clear();
+                    if (Creature* mount = FindMyMount(me))
+                        me->GetMotionMaster()->MovePoint(0, mount->GetPosition());
+                    break;
+                case EVENT_EVADE_MODE:
+                    // Entering to evade mode after jousting event is done
+                    bHome = true;
+                    EnterEvadeMode();
+                    break;
+                case EVENT_START_ATTACK_REAL:
+                    // Searches an enemy to attack after waited a while after jousting event
+                    AttackRandomPlayer();
+                    break;
+                case EVENT_DESPAWN:
+                    // Despawning
+                    _JustDied();
+                    me->RemoveAura(SPELL_KNEEL);
+                    instance->DoUpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_BE_SPELL_TARGET, SPELL_ACHIEVEMENT_CREDIT, 0, me);
+                    me->SetWalk(true);
+                    me->GetMotionMaster()->MovePoint(POINT_DESPAWN, bossExitPos);
+                    break;
+                default:
+                    break;
+            }
+            uiPhase = 0;
+        }
+
+        if (!MountedPhaseDone && GrandChampionsOutOfVehicles())
+        {
+            // Champions have been defeated in jousting event
+            MountedPhaseDone = true;
+            if (me->GetGUID() == instance->GetGuidData(DATA_GRAND_CHAMPION_1))
+                me->SetHomePosition(739.678f, 660.975f, 412.393f, 4.49f);
+            else if (me->GetGUID() == instance->GetGuidData(DATA_GRAND_CHAMPION_2))
+                me->SetHomePosition(746.71f, 661.02f, 411.69f, 4.6f);
+            else if (me->GetGUID() == instance->GetGuidData(DATA_GRAND_CHAMPION_3))
+                me->SetHomePosition(754.34f, 660.70f, 412.39f, 4.79f);
+
+            if (Creature* mount = FindMyMount(me))
+                mount->DisappearAndDie();
+
+            LookingForMount = false;
+            me->ApplySpellImmune(SPELL_TRAMPLE_AURA, IMMUNITY_ID, SPELL_TRAMPLE_AURA, false);
+            me->GetMotionMaster()->MoveIdle();
+            me->GetMotionMaster()->Clear();
+            me->setRegeneratingHealth(true);
+            instance->SetData(DATA_REMOVE_VEHICLES, 0);
+            me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+            uiPhase = 5;
+            events.ScheduleEvent(EVENT_EVADE_MODE, 2000); // minor delay before entering to evade mode to correct movement
+        }
+
+        if (!bDone && GrandChampionsDefeated())
+        {
+            // Grand Champions encounter is now over
+            bDone = true;
+            uiPhase = 6;
+            events.ScheduleEvent(EVENT_DESPAWN, 2000); // minor delay before giving loot chest
+        }
+    }
+};
 
 /*
-* Generic AI for vehicles used by npcs in ToC, it needs more improvements.  *
-* Script Complete: 25%.                                                     *
+* Generic AI for vehicles used by npcs in ToC.              *
+* Code requires cleanup and vehicles some improvement       *
+* Script Complete: 95%.                                     *
 */
 
 class generic_vehicleAI_toc5 : public CreatureScript
@@ -164,138 +705,370 @@ class generic_vehicleAI_toc5 : public CreatureScript
 
         void Initialize()
         {
-            uiChargeTimer = 5000;
-            uiShieldBreakerTimer = 8000;
-            uiBuffTimer = urand(30000, 60000);
+            castedPennant = false;
+            events.ScheduleEvent(EVENT_BUFF_FLAG, 2000);
+            events.ScheduleEvent(EVENT_BUFF_SHIELD, 5000);
+            events.ScheduleEvent(EVENT_MOUNT_CHARGE, 5000);
+            events.ScheduleEvent(EVENT_SHIELD_BREAKER, 8000);
         }
 
         InstanceScript* instance;
 
-        uint32 uiChargeTimer;
-        uint32 uiShieldBreakerTimer;
-        uint32 uiBuffTimer;
+        EventMap events;
 
+        bool castedPennant;
         uint32 uiWaypointPath;
 
         void Reset() override
         {
+            events.Reset();
             Initialize();
         }
 
-        void SetData(uint32 uiType, uint32 /*uiData*/) override
+        bool IsGrandChampionVehicle()
+        {
+            if (instance->GetGuidData(DATA_GRAND_CHAMPION_VEHICLE_1) == me->GetGUID() ||
+                instance->GetGuidData(DATA_GRAND_CHAMPION_VEHICLE_2) == me->GetGUID() ||
+                instance->GetGuidData(DATA_GRAND_CHAMPION_VEHICLE_3) == me->GetGUID())
+                return true;
+            return false;
+        }
+
+        bool IsLesserChampion()
+        {
+            switch (me->GetEntry())
+            {
+                case VEHICLE_DARNASSUS_CHAMPION:
+                case VEHICLE_EXODAR_CHAMPION:
+                case VEHICLE_STORMWIND_CHAMPION:
+                case VEHICLE_GNOMEREGAN_CHAMPION:
+                case VEHICLE_IRONFORGE_CHAMPION:
+                case VEHICLE_UNDERCITY_CHAMPION:
+                case VEHICLE_THUNDER_BLUFF_CHAMPION:
+                case VEHICLE_ORGRIMMAR_CHAMPION:
+                case VEHICLE_SILVERMOON_CHAMPION:
+                case VEHICLE_SENJIN_CHAMPION:
+                    return true;
+            }
+            return false;
+        }
+
+        void SetData(uint32 uiType, uint32 uiData) override
         {
             switch (uiType)
             {
-                case 1:
-                    AddWaypoint(0, 747.36f, 634.07f, 411.572f);
-                    AddWaypoint(1, 780.43f, 607.15f, 411.82f);
-                    AddWaypoint(2, 785.99f, 599.41f, 411.92f);
-                    AddWaypoint(3, 778.44f, 601.64f, 411.79f);
-                    uiWaypointPath = 1;
+                case DATA_GENERATE_WAYPOINTS_FOR_BOSS_1:
+                    if (uiData == HORDE)
+                    {
+                        AddWaypoint(0, 747.35f, 634.07f, 411.57f);
+                        AddWaypoint(1, 780.43f, 607.15f, 411.82f);
+                        AddWaypoint(2, 785.99f, 599.41f, 411.92f);
+                        AddWaypoint(3, GrandChampFinalLoc[3].GetPositionX(), GrandChampFinalLoc[3].GetPositionY(), GrandChampFinalLoc[3].GetPositionZ());
+                    }
+                    else if (uiData == ALLIANCE)
+                    {
+                        AddWaypoint(0, 747.35f, 634.07f, 411.57f);
+                        AddWaypoint(1, 700.39f, 618.73f, 412.39f);
+                        AddWaypoint(2, 703.59f, 618.48f, 411.92f);
+                        AddWaypoint(3, GrandChampFinalLoc[0].GetPositionX(), GrandChampFinalLoc[0].GetPositionY(), GrandChampFinalLoc[0].GetPositionZ());
+                    }
+                    uiWaypointPath = WAYPOINT_MAP_BOSS_1;
+                    break;
+                case DATA_GENERATE_WAYPOINTS_FOR_BOSS_2:
+                    if (uiData == HORDE)
+                    {
+                        AddWaypoint(0, 747.35f, 634.07f, 411.57f);
+                        AddWaypoint(1, 792.36f, 614.47f, 412.39f);
+                        AddWaypoint(2, GrandChampFinalLoc[4].GetPositionX(), GrandChampFinalLoc[4].GetPositionY(), GrandChampFinalLoc[4].GetPositionZ());
+                    }
+                    else if (uiData == ALLIANCE)
+                    {
+                        AddWaypoint(0, 747.35f, 634.07f, 411.57f);
+                        AddWaypoint(1, 708.31f, 635.07f, 411.93f);
+                        AddWaypoint(2, GrandChampFinalLoc[1].GetPositionX(), GrandChampFinalLoc[1].GetPositionY(), GrandChampFinalLoc[1].GetPositionZ());
+                    }
+                    uiWaypointPath = WAYPOINT_MAP_BOSS_2;
                     break;
-                case 2:
-                    AddWaypoint(0, 747.35f, 634.07f, 411.57f);
-                    AddWaypoint(1, 768.72f, 581.01f, 411.92f);
-                    AddWaypoint(2, 763.55f, 590.52f, 411.71f);
-                    uiWaypointPath = 2;
+                case DATA_GENERATE_WAYPOINTS_FOR_BOSS_3:
+                    if (uiData == HORDE)
+                    {
+                        AddWaypoint(0, 747.35f, 634.07f, 411.57f);
+                        AddWaypoint(1, 793.00f, 624.40f, 412.39f);
+                        AddWaypoint(2, GrandChampFinalLoc[5].GetPositionX(), GrandChampFinalLoc[5].GetPositionY(), GrandChampFinalLoc[5].GetPositionZ());
+                    }
+                    else if (uiData == ALLIANCE)
+                    {
+                        AddWaypoint(0, 747.35f, 634.07f, 411.57f);
+                        AddWaypoint(1, 716.67f, 651.1f, 411.93f);
+                        AddWaypoint(2, GrandChampFinalLoc[2].GetPositionX(), GrandChampFinalLoc[2].GetPositionY(), GrandChampFinalLoc[2].GetPositionZ());
+                    }
+                    uiWaypointPath = WAYPOINT_MAP_BOSS_3;
                     break;
-                case 3:
-                    AddWaypoint(0, 747.35f, 634.07f, 411.57f);
-                    AddWaypoint(1, 784.02f, 645.33f, 412.39f);
-                    AddWaypoint(2, 775.67f, 641.91f, 411.91f);
-                    uiWaypointPath = 3;
+                case DATA_GENERATE_WAYPOINTS_FOR_ADDS:
+                    me->SetWalk(true);
+                    me->GetMotionMaster()->MovePoint(1, LesserChampLoc[uiData]);
+                    uiWaypointPath = WAYPOINT_MAP_ADDS;
                     break;
             }
 
-            if (uiType <= 3)
-                Start(false, true);
+            if (uiType <= DATA_GENERATE_WAYPOINTS_FOR_BOSS_3)
+                Start(false, true); // Grand Champions run to their positions
         }
 
-        void WaypointReached(uint32 waypointId) override
+        void EnterEvadeMode(EvadeReason why = EVADE_REASON_OTHER) override
         {
-            switch (waypointId)
+            // Evade is handled in UpdateAI for Grand Champions' vehicles
+            // "Cosmetic" vehicles are no longer grand champions' vehicles when champions are
+            // already walking to new mount, therefore they enter into evade mode instead of despawning
+            if (IsGrandChampionVehicle() ||
+                me->GetEntry() == VEHICLE_ARGENT_BATTLEWORG_COSMETIC ||
+                me->GetEntry() == VEHICLE_ARGENT_WARHORSE_COSMETIC)
+                return;
+
+            npc_escortAI::EnterEvadeMode(why);
+        }
+
+        void WaypointReached(uint32 waypointId) override 
+        {
+            uint32 TeamInInstance = instance->GetData(DATA_TEAM_IN_INSTANCE);
+            // Grand Champions reached their final positions in the jousting event
+            // and Lesser Champions begin to correct their positions
+            if ((uiWaypointPath == WAYPOINT_MAP_BOSS_1 && waypointId == 3) || ((uiWaypointPath == WAYPOINT_MAP_BOSS_2 || uiWaypointPath == WAYPOINT_MAP_BOSS_3) && waypointId == 2))
             {
-                case 2:
-                    if (uiWaypointPath == 3 || uiWaypointPath == 2)
-                        instance->SetData(DATA_MOVEMENT_DONE, instance->GetData(DATA_MOVEMENT_DONE)+1);
-                    break;
-                case 3:
-                    instance->SetData(DATA_MOVEMENT_DONE, instance->GetData(DATA_MOVEMENT_DONE)+1);
-                    break;
+                if (Creature* herald = instance->GetCreature(DATA_ANNOUNCER))
+                {
+                    if (TeamInInstance == ALLIANCE)
+                        me->SetFacingTo(hordeOrientation);
+                    else
+                        me->SetFacingTo(allianceOrientation);
+                    me->SetHomePosition(me->GetPositionX(), me->GetPositionY(), me->GetPositionZ(), TeamInInstance == ALLIANCE ? hordeOrientation : allianceOrientation);
+                    if (me->GetVehicleKit() && me->GetVehicleKit()->GetPassenger(SEAT_ID_0) && me->GetVehicleKit()->GetPassenger(SEAT_ID_0)->ToCreature())
+                        me->GetVehicleKit()->GetPassenger(SEAT_ID_0)->ToCreature()->SetHomePosition(me->GetPosition());
+                    herald->AI()->SetData(DATA_LESSER_CHAMPIONS_PREPARE, uiWaypointPath);
+                }
             }
+            // Grand Champions run from gates into the arena and then walk towards their waiting positions
+            else if (uiWaypointPath < WAYPOINT_MAP_ADDS && waypointId == 0)
+                me->SetWalk(true);
         }
 
-        void EnterCombat(Unit* /*who*/) override
+        void MovementInform(uint32 type, uint32 pointId) override
         {
-            DoCastSpellShield();
+            npc_escortAI::MovementInform(type, pointId);
+
+            if (type != POINT_MOTION_TYPE)
+                return;
+
+            // Lesser Champions correct their orientation
+            if (pointId == 1 && uiWaypointPath == WAYPOINT_MAP_ADDS)
+            {
+                uint32 TeamInInstance = instance->GetData(DATA_TEAM_IN_INSTANCE);
+                if (TeamInInstance == ALLIANCE)
+                    me->SetFacingTo(hordeOrientation);
+                else
+                    me->SetFacingTo(allianceOrientation);
+                me->SetWalk(false);
+                me->SetHomePosition(me->GetPositionX(), me->GetPositionY(), me->GetPositionZ(), TeamInInstance == ALLIANCE ? hordeOrientation : allianceOrientation);
+            }
+
+            // Grand Champions' old mount will despawn when it has run to the center of arena
+            if (pointId == 1 && me->GetVehicleKit() && !me->GetVehicleKit()->GetPassenger(SEAT_ID_0))
+                me->DisappearAndDie();
         }
 
-        void DoCastSpellShield()
+        void JustDied(Unit* /*killer*/) override
         {
-            for (uint8 i = 0; i < 3; ++i)
-                DoCast(me, SPELL_SHIELD, true);
+            if (IsLesserChampion())
+            {
+                me->Dismount();
+                if (Creature* herald = instance->GetCreature(DATA_ANNOUNCER))
+                    herald->AI()->SetData(DATA_LESSER_CHAMPIONS_DEFEATED, 0);
+            }
         }
 
-        void UpdateAI(uint32 uiDiff) override
+        void DoCastShield()
         {
-            npc_escortAI::UpdateAI(uiDiff);
-
-            if (!UpdateVictim())
-                return;
+            if (IsGrandChampionVehicle())
+            {
+                if (me->GetVehicleKit())
+                    if (Unit *rider = me->GetVehicleKit()->GetPassenger(SEAT_ID_0))
+                        rider->CastSpell(rider, SPELL_SHIELD_GRAND_CHAMP, true);
+            }
+            else if (IsLesserChampion())
+                  DoCast(me, SPELL_SHIELD_LESSER_CHAMP, true);
+        }
 
-            if (uiBuffTimer <= uiDiff)
+        void AttackStart(Unit* target) override
+        {
+            if (IsGrandChampionVehicle())
             {
-                if (!me->HasAura(SPELL_SHIELD))
-                    DoCastSpellShield();
+                if (!(me->GetVehicleKit() && me->GetVehicleKit()->GetPassenger(SEAT_ID_0)))
+                    return;
 
-                uiBuffTimer = urand(30000, 45000);
-            }else uiBuffTimer -= uiDiff;
+                if (me->HasUnitState(UNIT_STATE_MELEE_ATTACKING))
+                    me->AttackStop();
+                
+                me->GetMotionMaster()->MoveFollow(target, 0, 0);
+            }
+            else if (IsLesserChampion())
+                ScriptedAI::AttackStart(target);
+        }
 
-            if (uiChargeTimer <= uiDiff)
+        // returns true if we are in combat and we have a victim
+        // returns false if we have no victim, and enters grand champion to evade mode
+        bool CheckCombat()
+        {
+            if (IsGrandChampionVehicle())
             {
-                Map::PlayerList const& players = me->GetMap()->GetPlayers();
-                if (!players.isEmpty())
+                if (!me->GetVehicleKit())
+                    return false;
+
+                Unit* rider = me->GetVehicleKit()->GetPassenger(SEAT_ID_0);
+                if (!rider)
+                    return false;
+
+                if (!rider->IsInCombat())
+                    return false;
+
+                if ((rider->ToCreature() && !rider->ToCreature()->HasReactState(REACT_PASSIVE)) && !me->HasReactState(REACT_PASSIVE))
                 {
-                    for (Map::PlayerList::const_iterator itr = players.begin(); itr != players.end(); ++itr)
+                    if (rider->GetVictim() == nullptr)
                     {
-                        Player* player = itr->GetSource();
-                        if (player && !player->IsGameMaster() && me->IsInRange(player, 8.0f, 25.0f, false))
-                        {
-                            DoResetThreat();
-                            me->AddThreat(player, 1.0f);
-                            DoCast(player, SPELL_CHARGE);
-                            break;
-                        }
+                        SetGrandChampionToEvadeMode(rider->ToCreature());
+                        return false;
                     }
                 }
-                uiChargeTimer = 5000;
-            }else uiChargeTimer -= uiDiff;
+                else if (rider->getThreatManager().isThreatListEmpty())
+                {
+                    SetGrandChampionToEvadeMode(rider->ToCreature());
+                    return false;
+                }
+            }
+            else if (!UpdateVictim())
+                return false;
+            return true;
+        }
 
-            //dosen't work at all
-            if (uiShieldBreakerTimer <= uiDiff)
-            {
-                Vehicle* pVehicle = me->GetVehicleKit();
-                if (!pVehicle)
-                    return;
+        void UpdateAI(uint32 uiDiff) override
+        {
+            npc_escortAI::UpdateAI(uiDiff);
+            events.Update(uiDiff);
 
-                if (Unit* pPassenger = pVehicle->GetPassenger(SEAT_ID_0))
+            while (uint32 eventId = events.ExecuteEvent())
+            {
+                switch (eventId)
                 {
-                    Map::PlayerList const& players = me->GetMap()->GetPlayers();
-                    if (!players.isEmpty())
+                    case EVENT_BUFF_SHIELD:
+                        DoCastShield();
+                        events.ScheduleEvent(EVENT_BUFF_SHIELD, 7000);
+                        break;
+                    case EVENT_BUFF_FLAG:
+                        if (IsGrandChampionVehicle())
+                        {
+                            if (!castedPennant)
+                            {
+                                if (me->GetVehicleKit() && me->GetVehicleKit()->GetPassenger(SEAT_ID_0) && me->GetVehicleKit()->GetPassenger(SEAT_ID_0)->ToCreature())
+                                    DoCastPennant(me->GetVehicleKit()->GetPassenger(SEAT_ID_0)->ToCreature());
+                                castedPennant = true;
+                            }
+                        }
+                        break;
+                    case EVENT_MOUNT_CHARGE:
                     {
-                        for (Map::PlayerList::const_iterator itr = players.begin(); itr != players.end(); ++itr)
+                        if (CheckCombat())
                         {
-                            Player* player = itr->GetSource();
-                            if (player && !player->IsGameMaster() && me->IsInRange(player, 10.0f, 30.0f, false))
+                            // Charge is casted on random player
+                            // Champions' threatlist is reseted when using charge
+                            Map::PlayerList const& pList = me->GetMap()->GetPlayers();
+                            // Player list is always in the same order so we must "randomize" it
+                            if (!pList.isEmpty())
                             {
-                                pPassenger->CastSpell(player, SPELL_SHIELD_BREAKER, true);
-                                break;
+                                uint32 rand = urand(0, pList.getSize() - 1);
+                                for (Map::PlayerList::const_iterator itr = pList.begin(); itr != pList.end(); ++itr)
+                                {
+                                    if (rand == 0)
+                                    {
+                                        Player* plr = itr->GetSource();
+                                        if (plr && !plr->IsGameMaster() && plr->IsAlive() && me->IsInRange(plr, 8.0f, 25.0f, false))
+                                        {
+                                            uint32 spell_charge = IsGrandChampionVehicle() ? SPELL_CHARGE_GRAND_CHAMP : SPELL_CHARGE_LESSER_CHAMP;
+                                            if (IsGrandChampionVehicle())
+                                            {
+                                                if (me->GetVehicleKit() && me->GetVehicleKit()->GetPassenger(SEAT_ID_0))
+                                                {
+                                                    if (Creature* rider = me->GetVehicleKit()->GetPassenger(SEAT_ID_0)->ToCreature())
+                                                    {
+                                                        // Grand Champion
+                                                        // Resetting rider's threat (DoResetThreat() cannot be used on external unit)
+                                                        rider->getThreatManager().resetAllAggro();
+                                                        // Setting gaze on the new player
+                                                        if (plr->GetVehicleBase())
+                                                            rider->AddThreat(plr->GetVehicleBase(), 100000.0f);
+                                                        else
+                                                            rider->AddThreat(plr, 100000.0f);
+                                                        // Casting actual charge
+                                                        if (plr->GetVehicleBase())
+                                                            rider->CastSpell(plr->GetVehicleBase(), spell_charge);
+                                                        else
+                                                            rider->CastSpell(plr, spell_charge);
+                                                        me->GetMotionMaster()->MoveCharge(plr->GetPositionX(), plr->GetPositionY(), plr->GetPositionZ());
+                                                    }
+                                                }
+                                            }
+                                            else
+                                            {
+                                                // Lesser Champion
+                                                // Resetting threat
+                                                DoResetThreat();
+                                                // Setting gaze on the new player
+                                                if (plr->GetVehicleBase())
+                                                    me->AddThreat(plr->GetVehicleBase(), 100000.0f);
+                                                else
+                                                    me->AddThreat(plr, 100000.0f);
+                                                // Casting actual charge
+                                                if (plr->GetVehicleBase())
+                                                    DoCast(plr->GetVehicleBase(), spell_charge);
+                                                else
+                                                    DoCast(plr, spell_charge);
+                                            }
+                                            break;
+                                        }
+                                        else
+                                            continue;
+                                    }
+                                    else
+                                        --rand;
+                                }
                             }
                         }
+                        events.ScheduleEvent(EVENT_MOUNT_CHARGE, 7000);
+                        break;
                     }
+                    case EVENT_SHIELD_BREAKER:
+                        // Lesser Champions don't use Shield Breaker
+                        if (IsGrandChampionVehicle() && me->GetVehicleKit())
+                        {
+                            if (CheckCombat())
+                            {
+                                if (Unit* rider = me->GetVehicleKit()->GetPassenger(SEAT_ID_0))
+                                {
+                                    if (Unit* victim = rider->GetVictim())
+                                    {
+                                        if (rider->IsInRange(victim, 5.0f, 30.0f, false))
+                                            rider->CastSpell(victim, SPELL_SHIELD_BREAKER);
+                                    }
+                                }
+                            }
+                            events.ScheduleEvent(EVENT_SHIELD_BREAKER, 4000);
+                        }
+                        break;
+                    default:
+                        break;
                 }
-                uiShieldBreakerTimer = 7000;
-            }else uiShieldBreakerTimer -= uiDiff;
+            }
+
+            if (!CheckCombat())
+                return;
 
             DoMeleeAttackIfReady();
         }
@@ -303,7 +1076,7 @@ class generic_vehicleAI_toc5 : public CreatureScript
 
     CreatureAI* GetAI(Creature* creature) const override
     {
-        return GetInstanceAI<generic_vehicleAI_toc5AI>(creature);
+        return GetTrialOfChampionAI<generic_vehicleAI_toc5AI>(creature);
     }
 };
 
@@ -313,134 +1086,102 @@ class boss_warrior_toc5 : public CreatureScript
     boss_warrior_toc5() : CreatureScript("boss_warrior_toc5") { }
 
     // Marshal Jacob Alerius && Mokra the Skullcrusher || Warrior
-    struct boss_warrior_toc5AI : public ScriptedAI
+    struct boss_warrior_toc5AI : public boss_grand_championAI
     {
-        boss_warrior_toc5AI(Creature* creature) : ScriptedAI(creature)
-        {
-            Initialize();
-            instance = creature->GetInstanceScript();
-
-            bDone = false;
-            bHome = false;
-
-            uiPhase = 0;
-            uiPhaseTimer = 0;
-
-            me->SetReactState(REACT_PASSIVE);
-            // THIS IS A HACK, SHOULD BE REMOVED WHEN THE EVENT IS FULL SCRIPTED
-            me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_IMMUNE_TO_PC);
-        }
-
-        void Initialize()
-        {
-            uiBladeStormTimer = urand(15000, 20000);
-            uiInterceptTimer = 7000;
-            uiMortalStrikeTimer = urand(8000, 12000);
-        }
-
-        InstanceScript* instance;
-
-        uint8 uiPhase;
-        uint32 uiPhaseTimer;
-
-        uint32 uiBladeStormTimer;
-        uint32 uiInterceptTimer;
-        uint32 uiMortalStrikeTimer;
-
-        bool bDone;
-        bool bHome;
+        boss_warrior_toc5AI(Creature* creature) : boss_grand_championAI(creature) { }
 
         void Reset() override
         {
-            Initialize();
+            boss_grand_championAI::Reset();
         }
 
-        void JustReachedHome() override
+        void EnterCombat(Unit* who) override
         {
-            ScriptedAI::JustReachedHome();
-
-            if (!bHome)
-                return;
-
-            uiPhaseTimer = 15000;
-            uiPhase = 1;
-
-            bHome = false;
+            events.ScheduleEvent(EVENT_BLADESTORM, urand(15000, 20000));
+            events.ScheduleEvent(EVENT_INTERCEPT, 7000);
+            events.ScheduleEvent(EVENT_MORTAL_STRIKE, urand(8000, 12000));
+            events.ScheduleEvent(EVENT_ROLLING_THROW, 30000);
+            boss_grand_championAI::EnterCombat(who);
         }
 
         void UpdateAI(uint32 uiDiff) override
         {
-            if (!bDone && GrandChampionsOutVehicle(me))
-            {
-                bDone = true;
+            boss_grand_championAI::UpdateAI(uiDiff);
 
-                if (me->GetGUID() == instance->GetGuidData(DATA_GRAND_CHAMPION_1))
-                    me->SetHomePosition(739.678f, 662.541f, 412.393f, 4.49f);
-                else if (me->GetGUID() == instance->GetGuidData(DATA_GRAND_CHAMPION_2))
-                    me->SetHomePosition(746.71f, 661.02f, 411.69f, 4.6f);
-                else if (me->GetGUID() == instance->GetGuidData(DATA_GRAND_CHAMPION_3))
-                    me->SetHomePosition(754.34f, 660.70f, 412.39f, 4.79f);
-
-                EnterEvadeMode();
-                bHome = true;
-            }
-
-            if (uiPhaseTimer <= uiDiff)
+            if (CanUseNormalAI())
             {
-                if (uiPhase == 1)
-                {
-                    AggroAllPlayers(me);
-                    uiPhase = 0;
-                }
-            }else uiPhaseTimer -= uiDiff;
+                if (UpdateVictim())
+                    DoMeleeAttackIfReady();
+                return;
+            }
 
-            if (!UpdateVictim() || me->HasUnitMovementFlag(MOVEMENTFLAG_ONTRANSPORT))
+            if (me->HasUnitState(UNIT_STATE_CASTING))
                 return;
 
-            if (uiInterceptTimer <= uiDiff)
+            while (uint32 eventId = events.ExecuteEvent())
             {
-                Map::PlayerList const& players = me->GetMap()->GetPlayers();
-                if (!players.isEmpty())
+                switch (eventId)
                 {
-                    for (Map::PlayerList::const_iterator itr = players.begin(); itr != players.end(); ++itr)
+                    case EVENT_INTERCEPT:
                     {
-                        Player* player = itr->GetSource();
-                        if (player && !player->IsGameMaster() && me->IsInRange(player, 8.0f, 25.0f, false))
+                        if (!me->HasAura(SPELL_BLADESTORM))
                         {
-                            DoResetThreat();
-                            me->AddThreat(player, 5.0f);
-                            DoCast(player, SPELL_INTERCEPT);
-                            break;
+                            Map::PlayerList const& pList = me->GetMap()->GetPlayers();
+                            // Player list is always in the same order so we must "randomize" it
+                            if (!pList.isEmpty())
+                            {
+                                uint32 rand = urand(0, pList.getSize() - 1);
+                                for (Map::PlayerList::const_iterator itr = pList.begin(); itr != pList.end(); ++itr)
+                                {
+                                    if (rand == 0)
+                                    {
+                                        Player* plr = itr->GetSource();
+                                        if (plr && !plr->IsGameMaster() && plr->IsAlive() && me->IsInRange(plr, 8.0f, 25.0f, false))
+                                        {
+                                            DoResetThreat();
+                                            DoCast(plr, SPELL_INTERCEPT);
+                                            me->AddThreat(plr, 5.0f);
+                                            break;
+                                        }
+                                        else
+                                            continue;
+                                    }
+                                    else
+                                        --rand;
+                                }
+                            }
                         }
+                        events.ScheduleEvent(EVENT_INTERCEPT, 7000);
+                        break;
                     }
+                    case EVENT_BLADESTORM:
+                        DoCastVictim(SPELL_BLADESTORM);
+                        events.ScheduleEvent(EVENT_BLADESTORM, urand(15000, 20000));
+                        break;
+                    case EVENT_MORTAL_STRIKE:
+                        if (!me->HasAura(SPELL_BLADESTORM))
+                            DoCastVictim(SPELL_MORTAL_STRIKE);
+                        events.ScheduleEvent(EVENT_MORTAL_STRIKE, urand(8000, 12000));
+                        break;
+                    case EVENT_ROLLING_THROW:
+                        // TODO: FIXME
+                        // currently hackfixed at Spell::EffectLeapBack in SpellEffects.cpp
+                        // without hackfix caster jumps forward, when caster should jump backwards and player jump forwards
+                        if (!me->HasAura(SPELL_BLADESTORM))
+                            DoCastVictim(SPELL_ROLLING_THROW);
+                        events.ScheduleEvent(EVENT_ROLLING_THROW, 30000);
+                        break;
+                    default:
+                        break;
                 }
-                uiInterceptTimer = 7000;
-            } else uiInterceptTimer -= uiDiff;
-
-            if (uiBladeStormTimer <= uiDiff)
-            {
-                DoCastVictim(SPELL_BLADESTORM);
-                uiBladeStormTimer = urand(15000, 20000);
-            } else uiBladeStormTimer -= uiDiff;
-
-            if (uiMortalStrikeTimer <= uiDiff)
-            {
-                DoCastVictim(SPELL_MORTAL_STRIKE);
-                uiMortalStrikeTimer = urand(8000, 12000);
-            } else uiMortalStrikeTimer -= uiDiff;
-
+            }
             DoMeleeAttackIfReady();
         }
-
-        void JustDied(Unit* /*killer*/) override
-        {
-            instance->SetData(BOSS_GRAND_CHAMPIONS, DONE);
-        }
     };
 
     CreatureAI* GetAI(Creature* creature) const override
     {
-        return GetInstanceAI<boss_warrior_toc5AI>(creature);
+        return GetTrialOfChampionAI<boss_warrior_toc5AI>(creature);
     }
 };
 
@@ -450,140 +1191,93 @@ class boss_mage_toc5 : public CreatureScript
     boss_mage_toc5() : CreatureScript("boss_mage_toc5") { }
 
     // Ambrose Boltspark && Eressea Dawnsinger || Mage
-    struct boss_mage_toc5AI : public ScriptedAI
+    struct boss_mage_toc5AI : public boss_grand_championAI
     {
-        boss_mage_toc5AI(Creature* creature) : ScriptedAI(creature)
-        {
-            Initialize();
-            instance = creature->GetInstanceScript();
-
-            bDone = false;
-            bHome = false;
-
-            uiPhase = 0;
-            uiPhaseTimer = 0;
-
-            me->SetReactState(REACT_PASSIVE);
-            // THIS IS A HACK, SHOULD BE REMOVED WHEN THE EVENT IS FULL SCRIPTED
-            me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_IMMUNE_TO_PC);
-        }
-
-        void Initialize()
-        {
-            uiFireBallTimer = 5000;
-            uiPolymorphTimer = 8000;
-            uiBlastWaveTimer = 12000;
-            uiHasteTimer = 22000;
-        }
-
-        InstanceScript* instance;
-
-        uint8 uiPhase;
-        uint32 uiPhaseTimer;
-
-        uint32 uiFireBallTimer;
-        uint32 uiBlastWaveTimer;
-        uint32 uiHasteTimer;
-        uint32 uiPolymorphTimer;
-
-        bool bDone;
-        bool bHome;
+        boss_mage_toc5AI(Creature* creature) : boss_grand_championAI(creature) { }
 
         void Reset() override
         {
-            Initialize();
+            boss_grand_championAI::Reset();
         }
 
-        void JustReachedHome() override
-        {
-            ScriptedAI::JustReachedHome();
-
-            if (!bHome)
-                return;
-
-            uiPhaseTimer = 15000;
-            uiPhase = 1;
+        void EnterCombat(Unit* who) override
+        {
+            events.ScheduleEvent(EVENT_FIREBALL, 2000);
+            events.ScheduleEvent(EVENT_POLYMORPH, 8000);
+            events.ScheduleEvent(EVENT_BLASTWAVE, 12000);
+            events.ScheduleEvent(EVENT_HASTE, 22000);
+            boss_grand_championAI::EnterCombat(who);
+        }
 
-            bHome = false;
+        void AttackStart(Unit* who) override
+        {
+            me->GetMotionMaster()->MoveChase(who, 20.0f);
+            boss_grand_championAI::AttackStart(who);
         }
 
         void UpdateAI(uint32 uiDiff) override
         {
-            if (!bDone && GrandChampionsOutVehicle(me))
-            {
-                bDone = true;
-
-                if (me->GetGUID() == instance->GetGuidData(DATA_GRAND_CHAMPION_1))
-                    me->SetHomePosition(739.678f, 662.541f, 412.393f, 4.49f);
-                else if (me->GetGUID() == instance->GetGuidData(DATA_GRAND_CHAMPION_2))
-                    me->SetHomePosition(746.71f, 661.02f, 411.69f, 4.6f);
-                else if (me->GetGUID() == instance->GetGuidData(DATA_GRAND_CHAMPION_3))
-                    me->SetHomePosition(754.34f, 660.70f, 412.39f, 4.79f);
+            boss_grand_championAI::UpdateAI(uiDiff);
 
-                instance->SetData(BOSS_GRAND_CHAMPIONS, IN_PROGRESS);
-
-                EnterEvadeMode();
-                bHome = true;
+            if (CanUseNormalAI())
+            {
+                if (UpdateVictim())
+                    DoMeleeAttackIfReady();
+                return;
             }
 
-            if (uiPhaseTimer <= uiDiff)
+            while (uint32 eventId = events.ExecuteEvent())
             {
-                if (uiPhase == 1)
+                switch (eventId)
                 {
-                    AggroAllPlayers(me);
-                    uiPhase = 0;
+                    case EVENT_POLYMORPH:
+                        if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 1, 30.0f, true))
+                        {
+                            DoCast(target, SPELL_POLYMORPH);
+                            if (me->HasAura(SPELL_HASTE))
+                                events.ScheduleEvent(EVENT_FIREBALL, 2000);
+                            else
+                                events.ScheduleEvent(EVENT_FIREBALL, 3000);
+                        }
+                        events.ScheduleEvent(EVENT_POLYMORPH, 8000);
+                        break;
+                    case EVENT_BLASTWAVE:
+                        if (Unit* target = SelectTarget(SELECT_TARGET_NEAREST, 0))
+                        {
+                            if (me->IsWithinDist(target, 5.0f, false))
+                            {
+                                me->InterruptNonMeleeSpells(true);
+                                DoCastAOE(SPELL_BLAST_WAVE);
+                                events.ScheduleEvent(EVENT_FIREBALL, 1500);
+                            }
+                        }
+                        events.ScheduleEvent(EVENT_BLASTWAVE, 13000);
+                        break;
+                    case EVENT_HASTE:
+                        me->InterruptNonMeleeSpells(true);
+                        DoCast(me, SPELL_HASTE);
+                        events.ScheduleEvent(EVENT_FIREBALL, 1500);
+                        events.ScheduleEvent(EVENT_HASTE, 22000);
+                        break;
+                    case EVENT_FIREBALL:
+                        DoCastVictim(SPELL_FIREBALL);
+                        if (me->HasAura(SPELL_HASTE))
+                            events.ScheduleEvent(EVENT_FIREBALL, 3000);
+                        else
+                            events.ScheduleEvent(EVENT_FIREBALL, 4000);
+                        break;
+                    default:
+                        break;
                 }
-            }else uiPhaseTimer -= uiDiff;
-
-            if (uiFireBallTimer <= uiDiff)
-            {
-                if (me->GetVictim())
-                    DoCastVictim(SPELL_FIREBALL);
-                uiFireBallTimer = 5000;
-            } else uiFireBallTimer -= uiDiff;
-
-            if (!UpdateVictim() || me->HasUnitMovementFlag(MOVEMENTFLAG_ONTRANSPORT))
-                return;
-
-            if (uiFireBallTimer <= uiDiff)
-            {
-                DoCastVictim(SPELL_FIREBALL);
-                uiFireBallTimer = 5000;
-            } else uiFireBallTimer -= uiDiff;
-
-            if (uiPolymorphTimer <= uiDiff)
-            {
-                if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 0))
-                    DoCast(target, SPELL_POLYMORPH);
-                uiPolymorphTimer = 8000;
-            } else uiPolymorphTimer -= uiDiff;
-
-            if (uiBlastWaveTimer <= uiDiff)
-            {
-                DoCastAOE(SPELL_BLAST_WAVE, false);
-                uiBlastWaveTimer = 13000;
-            } else uiBlastWaveTimer -= uiDiff;
-
-            if (uiHasteTimer <= uiDiff)
-            {
-                me->InterruptNonMeleeSpells(true);
-
-                DoCast(me, SPELL_HASTE);
-                uiHasteTimer = 22000;
-            } else uiHasteTimer -= uiDiff;
-
-            DoMeleeAttackIfReady();
-        }
-
-        void JustDied(Unit* /*killer*/) override
-        {
-            instance->SetData(BOSS_GRAND_CHAMPIONS, DONE);
+            }
+            if ((100.f * me->GetPower(POWER_MANA) / me->GetMaxPower(POWER_MANA)) <= 1)
+                DoMeleeAttackIfReady();
         }
     };
 
     CreatureAI* GetAI(Creature* creature) const override
     {
-        return GetInstanceAI<boss_mage_toc5AI>(creature);
+        return GetTrialOfChampionAI<boss_mage_toc5AI>(creature);
     }
 };
 
@@ -593,148 +1287,186 @@ class boss_shaman_toc5 : public CreatureScript
     boss_shaman_toc5() : CreatureScript("boss_shaman_toc5") { }
 
     // Colosos && Runok Wildmane || Shaman
-    struct boss_shaman_toc5AI : public ScriptedAI
+    struct boss_shaman_toc5AI : public boss_grand_championAI
     {
-        boss_shaman_toc5AI(Creature* creature) : ScriptedAI(creature)
+        boss_shaman_toc5AI(Creature* creature) : boss_grand_championAI(creature)
         {
             Initialize();
-            instance = creature->GetInstanceScript();
-
-            bDone = false;
-            bHome = false;
-
-            uiPhase = 0;
-            uiPhaseTimer = 0;
-
-            me->SetReactState(REACT_PASSIVE);
-            // THIS IS A HACK, SHOULD BE REMOVED WHEN THE EVENT IS FULL SCRIPTED
-            me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_IMMUNE_TO_PC);
         }
 
         void Initialize()
         {
-            uiChainLightningTimer = 16000;
-            uiHealingWaveTimer = 12000;
-            uiEartShieldTimer = urand(30000, 35000);
-            uiHexMendingTimer = urand(20000, 25000);
+            earthShieldTarget.Clear();
+            isDefensive = false;
         }
-
-        InstanceScript* instance;
-
-        uint8 uiPhase;
-        uint32 uiPhaseTimer;
-
-        uint32 uiChainLightningTimer;
-        uint32 uiEartShieldTimer;
-        uint32 uiHealingWaveTimer;
-        uint32 uiHexMendingTimer;
-
-        bool bDone;
-        bool bHome;
+        ObjectGuid earthShieldTarget;
+        // If shaman's friend or himself goes below 25% HP, he will go into defensive mode,
+        // casting healing spells only
+        bool isDefensive;
 
         void Reset() override
         {
             Initialize();
+            boss_grand_championAI::Reset();
         }
 
         void EnterCombat(Unit* who) override
         {
-            DoCast(me, SPELL_EARTH_SHIELD);
-            DoCast(who, SPELL_HEX_OF_MENDING);
-        };
+            events.ScheduleEvent(EVENT_DEF_CHECK, 5000);
+            events.ScheduleEvent(EVENT_CHAIN_LIGHTNING, 16000);
+            events.ScheduleEvent(EVENT_HEALING_WAVE, 12000);
+            events.ScheduleEvent(EVENT_EARTH_SHIELD, 5000);
+            events.ScheduleEvent(EVENT_HEX_MENDING, 7000);
+            boss_grand_championAI::EnterCombat(who);
+        }
 
-        void JustReachedHome() override
+        void EnterCombatMode(bool interrupt)
         {
-            ScriptedAI::JustReachedHome();
-
-            if (!bHome)
-                return;
-
-            uiPhaseTimer = 15000;
-            uiPhase = 1;
-
-            bHome = false;
+            if (interrupt)
+                me->InterruptNonMeleeSpells(true);
+            isDefensive = false;
+            events.ScheduleEvent(EVENT_CHAIN_LIGHTNING, 1000);
         }
 
-        void UpdateAI(uint32 uiDiff) override
+        void EnterDefensiveMode()
         {
-            if (!bDone && GrandChampionsOutVehicle(me))
-            {
-                bDone = true;
-
-                if (me->GetGUID() == instance->GetGuidData(DATA_GRAND_CHAMPION_1))
-                    me->SetHomePosition(739.678f, 662.541f, 412.393f, 4.49f);
-                else if (me->GetGUID() == instance->GetGuidData(DATA_GRAND_CHAMPION_2))
-                    me->SetHomePosition(746.71f, 661.02f, 411.69f, 4.6f);
-                else if (me->GetGUID() == instance->GetGuidData(DATA_GRAND_CHAMPION_3))
-                    me->SetHomePosition(754.34f, 660.70f, 412.39f, 4.79f);
-
-                instance->SetData(BOSS_GRAND_CHAMPIONS, IN_PROGRESS);
-
-                EnterEvadeMode();
-                bHome = true;
-            }
+            me->InterruptNonMeleeSpells(true);
+            isDefensive = true;
+            events.ScheduleEvent(EVENT_EARTH_SHIELD, 1000);
+            events.ScheduleEvent(EVENT_HEALING_WAVE, 1500);
+        }
 
-            if (uiPhaseTimer <= uiDiff)
+        Unit* FindChampionWithLowestHp(float range)
+        {
+            // DoSelectLowestHpFriendly does not work correctly in this fight
+            // We look for champion with the lowest percentage health left
+            // ignoring champions with full hp or with kneel state (= defeated)
+            // and champions who are more than 40 yards away from me (max range of healing spells)
+            Unit* lowChampion = nullptr;
+            Creature* pGrandChampion1 = ObjectAccessor::GetCreature(*me, instance->GetGuidData(DATA_GRAND_CHAMPION_1));
+            Creature* pGrandChampion2 = ObjectAccessor::GetCreature(*me, instance->GetGuidData(DATA_GRAND_CHAMPION_2));
+            Creature* pGrandChampion3 = ObjectAccessor::GetCreature(*me, instance->GetGuidData(DATA_GRAND_CHAMPION_3));
+            if (pGrandChampion1 && pGrandChampion2 && pGrandChampion3)
             {
-                if (uiPhase == 1)
+                if (!pGrandChampion1->HasAura(SPELL_KNEEL) && pGrandChampion1->GetHealthPct() < 100 && me->IsWithinDist(pGrandChampion1, range))
+                    lowChampion = pGrandChampion1;
+                if (!pGrandChampion2->HasAura(SPELL_KNEEL) && pGrandChampion2->GetHealthPct() < 100 && me->IsWithinDist(pGrandChampion2, range))
                 {
-                    AggroAllPlayers(me);
-                    uiPhase = 0;
+                    if (lowChampion)
+                    {
+                        if (lowChampion->GetHealthPct() > pGrandChampion2->GetHealthPct())
+                            lowChampion = pGrandChampion2;
+                    }
+                    else
+                        lowChampion = pGrandChampion2;
                 }
-            }else uiPhaseTimer -= uiDiff;
-
-            if (!UpdateVictim() || me->HasUnitMovementFlag(MOVEMENTFLAG_ONTRANSPORT))
-                return;
-
-            if (uiChainLightningTimer <= uiDiff)
-            {
-                if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 0))
-                    DoCast(target, SPELL_CHAIN_LIGHTNING);
-
-                uiChainLightningTimer = 16000;
-            } else uiChainLightningTimer -= uiDiff;
-
-            if (uiHealingWaveTimer <= uiDiff)
-            {
-                bool bChance = roll_chance_i(50);
-
-                if (!bChance)
+                if (!pGrandChampion3->HasAura(SPELL_KNEEL) && pGrandChampion3->GetHealthPct() < 100 && me->IsWithinDist(pGrandChampion3, range))
                 {
-                    if (Unit* pFriend = DoSelectLowestHpFriendly(40))
-                        DoCast(pFriend, SPELL_HEALING_WAVE);
-                } else
-                    DoCast(me, SPELL_HEALING_WAVE);
+                    if (lowChampion)
+                    {
+                        if (lowChampion->GetHealthPct() > pGrandChampion3->GetHealthPct())
+                            lowChampion = pGrandChampion3;
+                    }
+                    else
+                        lowChampion = pGrandChampion3;
+                }
+            }
+            // can return NULL if other champions are over 40 yards away and we're in full hp
+            // or if one champion has been defeated and two are in full hp
+            // or we are last man standing with full hp
+            return lowChampion;
+        }
 
-                uiHealingWaveTimer = 12000;
-            } else uiHealingWaveTimer -= uiDiff;
+        void UpdateAI(uint32 uiDiff) override
+        {
+            boss_grand_championAI::UpdateAI(uiDiff);
 
-            if (uiEartShieldTimer <= uiDiff)
+            if (CanUseNormalAI())
             {
-                DoCast(me, SPELL_EARTH_SHIELD);
-
-                uiEartShieldTimer = urand(30000, 35000);
-            } else uiEartShieldTimer -= uiDiff;
+                if (UpdateVictim())
+                    DoMeleeAttackIfReady();
+                return;
+            }
 
-            if (uiHexMendingTimer <= uiDiff)
+            while (uint32 eventId = events.ExecuteEvent())
             {
-                DoCastVictim(SPELL_HEX_OF_MENDING, true);
-
-                uiHexMendingTimer = urand(20000, 25000);
-            } else uiHexMendingTimer -= uiDiff;
-
-            DoMeleeAttackIfReady();
-        }
-
-        void JustDied(Unit* /*killer*/) override
-        {
-            instance->SetData(BOSS_GRAND_CHAMPIONS, DONE);
+                switch (eventId)
+                {
+                    case EVENT_DEF_CHECK:
+                        if (!isDefensive)
+                        {
+                            Unit* pFriend = FindChampionWithLowestHp(40.0f);
+                            if (pFriend && pFriend->GetHealthPct() <= 25)
+                                EnterDefensiveMode();
+                        }
+                        else
+                        {
+                            Unit* pFriend = FindChampionWithLowestHp(40.0f);
+                            if (pFriend && pFriend->GetHealthPct() > 25)
+                                EnterCombatMode(false);
+                            else
+                                EnterCombatMode(true);
+                        }
+                        events.ScheduleEvent(EVENT_DEF_CHECK, 5000);
+                        break;
+                    case EVENT_CHAIN_LIGHTNING:
+                        if (!isDefensive)
+                        {
+                            if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 0, 30.0f, true))
+                                DoCast(target, SPELL_CHAIN_LIGHTNING);
+                            events.ScheduleEvent(EVENT_CHAIN_LIGHTNING, 16000);
+                        }
+                        break;
+                    case EVENT_HEALING_WAVE:
+                        if (Unit* pFriend = FindChampionWithLowestHp(40.0f))
+                        {
+                            // double check to interrupt heal on defeated champion
+                            if (pFriend->HasAura(SPELL_KNEEL))
+                                EnterCombatMode(true);
+                            else
+                                DoCast(pFriend, SPELL_HEALING_WAVE);
+                        }
+                        if (isDefensive)
+                            events.ScheduleEvent(EVENT_HEALING_WAVE, 4000);
+                        else
+                            events.ScheduleEvent(EVENT_HEALING_WAVE, 12000);
+                        break;
+                    case EVENT_EARTH_SHIELD:
+                        if (Unit* pFriend = FindChampionWithLowestHp(40.0f))
+                        {
+                            // double check to interrupt shield on defeated champion
+                            if (pFriend->HasAura(SPELL_KNEEL))
+                                EnterCombatMode(true);
+                            else
+                            {
+                                // Earth Shield is single target spell, we must remove it from previous target
+                                if (Creature* target = ObjectAccessor::GetCreature(*me, earthShieldTarget))
+                                {
+                                    if (target->HasAura(SPELL_EARTH_SHIELD))
+                                        target->RemoveAura(SPELL_EARTH_SHIELD);
+                                }
+                                DoCast(pFriend, SPELL_EARTH_SHIELD);
+                                earthShieldTarget = pFriend->GetGUID();
+                            }
+                        }
+                        events.ScheduleEvent(EVENT_EARTH_SHIELD, urand(30000, 35000));
+                        break;
+                    case EVENT_HEX_MENDING:
+                        DoCastVictim(SPELL_HEX_OF_MENDING);
+                        events.ScheduleEvent(EVENT_HEX_MENDING, urand(20000, 25000));
+                        break;
+                    default:
+                        break;
+                }
+            }
+            if (!isDefensive)
+                DoMeleeAttackIfReady();
         }
     };
 
     CreatureAI* GetAI(Creature* creature) const override
     {
-        return GetInstanceAI<boss_shaman_toc5AI>(creature);
+        return GetTrialOfChampionAI<boss_shaman_toc5AI>(creature);
     }
 };
 
@@ -743,284 +1475,305 @@ class boss_hunter_toc5 : public CreatureScript
 public:
     boss_hunter_toc5() : CreatureScript("boss_hunter_toc5") { }
 
-        // Jaelyne Evensong && Zul'tore || Hunter
-    struct boss_hunter_toc5AI : public ScriptedAI
+    // Jaelyne Evensong && Zul'tore || Hunter
+    struct boss_hunter_toc5AI : public boss_grand_championAI
     {
-        boss_hunter_toc5AI(Creature* creature) : ScriptedAI(creature)
-        {
-            Initialize();
-            instance = creature->GetInstanceScript();
-
-            bDone = false;
-            bHome = false;
-
-            uiPhase = 0;
-            uiPhaseTimer = 0;
-
-            me->SetReactState(REACT_PASSIVE);
-            // THIS IS A HACK, SHOULD BE REMOVED WHEN THE EVENT IS FULL SCRIPTED
-            me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_IMMUNE_TO_PC);
-        }
+        boss_hunter_toc5AI(Creature* creature) : boss_grand_championAI(creature) { }
 
-        void Initialize()
+        void Reset() override
         {
-            uiShootTimer = 12000;
-            uiMultiShotTimer = 0;
-            uiLightningArrowsTimer = 7000;
-
-            uiTargetGUID.Clear();
-
-            bShoot = false;
+            boss_grand_championAI::Reset();
         }
 
-        InstanceScript* instance;
-
-        uint8 uiPhase;
-        uint32 uiPhaseTimer;
-
-        uint32 uiShootTimer;
-        uint32 uiMultiShotTimer;
-        uint32 uiLightningArrowsTimer;
-
-        ObjectGuid uiTargetGUID;
-
-        bool bShoot;
-        bool bDone;
-        bool bHome;
-
-        void Reset() override
+        void EnterCombat(Unit* who) override
         {
-            Initialize();
+            events.ScheduleEvent(EVENT_MULTI_SHOT, 7500);
+            events.ScheduleEvent(EVENT_LIGHTNING_ARROWS, 15000);
+            events.ScheduleEvent(EVENT_DISENGAGE, urand(25000, 35000));
+            boss_grand_championAI::EnterCombat(who);
         }
 
-        void JustReachedHome() override
+        void AttackStart(Unit* who) override
         {
-            ScriptedAI::JustReachedHome();
-
-            if (!bHome)
-                return;
-
-            uiPhaseTimer = 15000;
-            uiPhase = 1;
-
-            bHome = false;
+            me->GetMotionMaster()->MoveChase(who, 25.0f);
+            boss_grand_championAI::AttackStart(who);
         }
 
         void UpdateAI(uint32 uiDiff) override
         {
-            if (!bDone && GrandChampionsOutVehicle(me))
-            {
-                bDone = true;
-
-                if (me->GetGUID() == instance->GetGuidData(DATA_GRAND_CHAMPION_1))
-                    me->SetHomePosition(739.678f, 662.541f, 412.393f, 4.49f);
-                else if (me->GetGUID() == instance->GetGuidData(DATA_GRAND_CHAMPION_2))
-                    me->SetHomePosition(746.71f, 661.02f, 411.69f, 4.6f);
-                else if (me->GetGUID() == instance->GetGuidData(DATA_GRAND_CHAMPION_3))
-                    me->SetHomePosition(754.34f, 660.70f, 412.39f, 4.79f);
-
-                instance->SetData(BOSS_GRAND_CHAMPIONS, IN_PROGRESS);
+            boss_grand_championAI::UpdateAI(uiDiff);
 
-                EnterEvadeMode();
-                bHome = true;
-            }
-
-            if (uiPhaseTimer <= uiDiff)
+            if (CanUseNormalAI())
             {
-                if (uiPhase == 1)
-                {
-                    AggroAllPlayers(me);
-                    uiPhase = 0;
-                }
-            }else uiPhaseTimer -= uiDiff;
-
-            if (!UpdateVictim() || me->HasUnitMovementFlag(MOVEMENTFLAG_ONTRANSPORT))
+                if (UpdateVictim())
+                    DoMeleeAttackIfReady();
                 return;
+            }
 
-            if (uiLightningArrowsTimer <= uiDiff)
-            {
-                DoCastAOE(SPELL_LIGHTNING_ARROWS, false);
-                uiLightningArrowsTimer = 7000;
-            } else uiLightningArrowsTimer -= uiDiff;
-
-            if (uiShootTimer <= uiDiff)
-            {
-                if (Unit* target = SelectTarget(SELECT_TARGET_FARTHEST, 0, 30.0f))
-                {
-                    uiTargetGUID = target->GetGUID();
-                    DoCast(target, SPELL_SHOOT);
-                }
-                uiShootTimer = 12000;
-                uiMultiShotTimer = 3000;
-                bShoot = true;
-            } else uiShootTimer -= uiDiff;
-
-            if (bShoot && uiMultiShotTimer <= uiDiff)
+            while (uint32 eventId = events.ExecuteEvent())
             {
-                me->InterruptNonMeleeSpells(true);
-                Unit* target = ObjectAccessor::GetUnit(*me, uiTargetGUID);
-
-                if (target && me->IsInRange(target, 5.0f, 30.0f, false))
-                {
-                    DoCast(target, SPELL_MULTI_SHOT);
-                }
-                else
+                switch (eventId)
                 {
-                    Map::PlayerList const& players = me->GetMap()->GetPlayers();
-                    if (!players.isEmpty())
-                    {
-                        for (Map::PlayerList::const_iterator itr = players.begin(); itr != players.end(); ++itr)
+                    case EVENT_DISENGAGE:
+                        if (Unit* target = SelectTarget(SELECT_TARGET_NEAREST, 0))
                         {
-                            Player* player = itr->GetSource();
-                            if (player && !player->IsGameMaster() && me->IsInRange(player, 5.0f, 30.0f, false))
+                            if (me->IsWithinDist(target, 5.0f, false))
                             {
-                                DoCast(player, SPELL_MULTI_SHOT);
-                                break;
+                                me->InterruptNonMeleeSpells(true);
+                                DoCast(me, SPELL_DISENGAGE);
                             }
                         }
-                    }
+                        events.ScheduleEvent(EVENT_DISENGAGE, urand(25000, 35000));
+                        break;
+                    case EVENT_LIGHTNING_ARROWS:
+                        if (!me->HasAura(SPELL_LIGHTNING_ARROWS_AURA) && !me->IsWithinDist(me->GetVictim(), 2.0f))
+                        {
+                            me->InterruptNonMeleeSpells(true);
+                            DoCastAOE(SPELL_LIGHTNING_ARROWS);
+                        }
+                        events.ScheduleEvent(EVENT_LIGHTNING_ARROWS, urand(20000, 30000));
+                        break;
+                    case EVENT_MULTI_SHOT:
+                        if (me->IsInRange(me->GetVictim(), 5.0f, 30.0f, false) && !me->HasAura(SPELL_LIGHTNING_ARROWS))
+                        {
+                            me->InterruptNonMeleeSpells(true);
+                            DoCastVictim(SPELL_MULTI_SHOT);
+                        }
+                        events.ScheduleEvent(EVENT_MULTI_SHOT, 8000);
+                        break;
+                    default:
+                        break;
                 }
-                bShoot = false;
-            } else uiMultiShotTimer -= uiDiff;
-
-            DoMeleeAttackIfReady();
-        }
+            }
 
-        void JustDied(Unit* /*killer*/) override
-        {
-            instance->SetData(BOSS_GRAND_CHAMPIONS, DONE);
+            if (me->IsWithinDist(me->GetVictim(), 2.0f))
+                DoMeleeAttackIfReady();
+            else
+                DoSpellAttackIfReady(SPELL_SHOOT);
         }
     };
 
     CreatureAI* GetAI(Creature* creature) const override
     {
-        return GetInstanceAI<boss_hunter_toc5AI>(creature);
+        return GetTrialOfChampionAI<boss_hunter_toc5AI>(creature);
     }
 };
 
-class boss_rouge_toc5 : public CreatureScript
+class boss_rogue_toc5 : public CreatureScript
 {
 public:
-    boss_rouge_toc5() : CreatureScript("boss_rouge_toc5") { }
+    boss_rogue_toc5() : CreatureScript("boss_rouge_toc5") { }
 
-    // Lana Stouthammer Evensong && Deathstalker Visceri || Rouge
-    struct boss_rouge_toc5AI : public ScriptedAI
+    // Lana Stouthammer Evensong && Deathstalker Visceri || Rogue
+    struct boss_rogue_toc5AI : public boss_grand_championAI
     {
-        boss_rouge_toc5AI(Creature* creature) : ScriptedAI(creature)
-        {
-            Initialize();
-            instance = creature->GetInstanceScript();
-
-            bDone = false;
-            bHome = false;
-
-            uiPhase = 0;
-            uiPhaseTimer = 0;
-
-            me->SetReactState(REACT_PASSIVE);
-            // THIS IS A HACK, SHOULD BE REMOVED WHEN THE EVENT IS FULL SCRIPTED
-            me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_IMMUNE_TO_PC);
-        }
+        boss_rogue_toc5AI(Creature* creature) : boss_grand_championAI(creature) { }
 
-        void Initialize()
+        void Reset() override
         {
-            uiEviscerateTimer = 8000;
-            uiFanKivesTimer = 14000;
-            uiPosionBottleTimer = 19000;
+            boss_grand_championAI::Reset();
         }
 
-        InstanceScript* instance;
-
-        uint8 uiPhase;
-        uint32 uiPhaseTimer;
-        uint32 uiEviscerateTimer;
-        uint32 uiFanKivesTimer;
-        uint32 uiPosionBottleTimer;
-
-        bool bDone;
-        bool bHome;
-
-        void Reset() override
+        void EnterCombat(Unit* who) override
         {
-            Initialize();
+            events.ScheduleEvent(EVENT_DEADLY_POISON, 500);
+            events.ScheduleEvent(EVENT_EVISCERATE, 8000);
+            events.ScheduleEvent(EVENT_FAN_OF_KNIVES, 14000);
+            events.ScheduleEvent(EVENT_POISON_BOTTLE, 19000);
+            boss_grand_championAI::EnterCombat(who);
         }
 
-        void JustReachedHome() override
+        void UpdateAI(uint32 diff) override
         {
-            ScriptedAI::JustReachedHome();
+            boss_grand_championAI::UpdateAI(diff);
 
-            if (!bHome)
+            if (CanUseNormalAI())
+            {
+                if (UpdateVictim())
+                    DoMeleeAttackIfReady();
                 return;
+            }
 
-            uiPhaseTimer = 15000;
-            uiPhase = 1;
+            if (me->HasUnitState(UNIT_STATE_CASTING))
+                return;
 
-            bHome = false;
+            while (uint32 eventId = events.ExecuteEvent())
+            {
+                switch (eventId)
+                {
+                    case EVENT_DEADLY_POISON:
+                        if (!me->HasAura(SPELL_DEADLY_POISON))
+                            DoCast(me, SPELL_DEADLY_POISON);
+                        events.ScheduleEvent(EVENT_DEADLY_POISON, 30000);
+                    case EVENT_EVISCERATE:
+                        DoCastVictim(SPELL_EVISCERATE);
+                        events.ScheduleEvent(EVENT_EVISCERATE, 8000);
+                        break;
+                    case EVENT_FAN_OF_KNIVES:
+                        if (Unit* target = SelectTarget(SELECT_TARGET_NEAREST, 0))
+                        {
+                            if (me->IsWithinDist(target, 8.0f, false)) // 8 yards is minimum range
+                                DoCastAOE(SPELL_FAN_OF_KNIVES);
+                        }
+                        events.ScheduleEvent(EVENT_FAN_OF_KNIVES, 14000);
+                        break;
+                    case EVENT_POISON_BOTTLE:
+                        if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 0, 30.0f, true))
+                            DoCast(target, SPELL_POISON_BOTTLE);
+                        events.ScheduleEvent(EVENT_POISON_BOTTLE, 19000);
+                        break;
+                    default:
+                        break;
+                }
+            }
+            DoMeleeAttackIfReady();
         }
+    };
 
-        void UpdateAI(uint32 uiDiff) override
-        {
-            if (!bDone && GrandChampionsOutVehicle(me))
-            {
-                bDone = true;
+    CreatureAI* GetAI(Creature* creature) const override
+    {
+        return GetTrialOfChampionAI<boss_rogue_toc5AI>(creature);
+    }
+};
 
-                if (me->GetGUID() == instance->GetGuidData(DATA_GRAND_CHAMPION_1))
-                    me->SetHomePosition(739.678f, 662.541f, 412.393f, 4.49f);
-                else if (me->GetGUID() == instance->GetGuidData(DATA_GRAND_CHAMPION_2))
-                    me->SetHomePosition(746.71f, 661.02f, 411.69f, 4.6f);
-                else if (me->GetGUID() == instance->GetGuidData(DATA_GRAND_CHAMPION_3))
-                    me->SetHomePosition(754.34f, 660.70f, 412.39f, 4.79f);
+class spell_toc5_trample_aura : public SpellScriptLoader
+{
+    public:
+        spell_toc5_trample_aura() : SpellScriptLoader("spell_toc5_trample_aura") { }
 
-                instance->SetData(BOSS_GRAND_CHAMPIONS, IN_PROGRESS);
+        class spell_toc5_trample_aura_SpellScript : public SpellScript
+        {
+            PrepareSpellScript(spell_toc5_trample_aura_SpellScript);
 
-                EnterEvadeMode();
-                bHome = true;
+            void RemoveInvalidTargets(std::list<WorldObject*>& targets)
+            {
+                // The aura should not be applied if there is already a trample aura on target
+                targets.remove_if(Trinity::UnitAuraCheck(true, GetSpellInfo()->Id));
             }
 
-            if (uiPhaseTimer <= uiDiff)
+            void HandleStun()
             {
-                if (uiPhase == 1)
+                if (Unit* target = GetHitUnit())
                 {
-                    AggroAllPlayers(me);
-                    uiPhase = 0;
+                    // If target is mounted, do not apply
+                    if (target->GetVehicleKit() // Grand Champions
+                    || target->GetVehicleBase() // Players
+                    || target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_MOUNT)) // Lesser Champions
+                    {
+                        PreventHitEffect(EFFECT_0);
+                        _removed = true;
+                    }
                 }
-            } else uiPhaseTimer -= uiDiff;
+            }
 
-            if (!UpdateVictim() || me->HasUnitMovementFlag(MOVEMENTFLAG_ONTRANSPORT))
-                return;
+            void RemoveAura()
+            {
+                if (_removed)
+                    PreventHitAura();
+            }
+
+            void Register() override
+            {
+                OnObjectAreaTargetSelect += SpellObjectAreaTargetSelectFn(spell_toc5_trample_aura_SpellScript::RemoveInvalidTargets, EFFECT_0, TARGET_UNIT_SRC_AREA_ENEMY);
+                BeforeHit += SpellHitFn(spell_toc5_trample_aura_SpellScript::HandleStun);
+                AfterHit += SpellHitFn(spell_toc5_trample_aura_SpellScript::RemoveAura);
+            }
+
+            bool _removed = false;
+        };
+
+        SpellScript* GetSpellScript() const override
+        {
+            return new spell_toc5_trample_aura_SpellScript();
+        }
+};
+
+class spell_toc5_lightning_arrows : public SpellScriptLoader
+{
+    public:
+        spell_toc5_lightning_arrows() : SpellScriptLoader("spell_toc5_lightning_arrows") { }
+
+        class spell_toc5_lightning_arrows_AuraScript : public AuraScript
+        {
+            PrepareAuraScript(spell_toc5_lightning_arrows_AuraScript);
 
-            if (uiEviscerateTimer <= uiDiff)
+            bool Validate(SpellInfo const* /*spellInfo*/) override
             {
-                DoCastVictim(SPELL_EVISCERATE);
-                uiEviscerateTimer = 8000;
-            } else uiEviscerateTimer -= uiDiff;
+                if (!sSpellMgr->GetSpellInfo(SPELL_LIGHTNING_ARROWS_AURA))
+                    return false;
+                return true;
+            }
 
-            if (uiFanKivesTimer <= uiDiff)
+            void HandleScript(AuraEffect const* /*aurEff*/, AuraEffectHandleModes /*mode*/)
             {
-                DoCastAOE(SPELL_FAN_OF_KNIVES, false);
-                uiFanKivesTimer = 14000;
-            } else uiFanKivesTimer -= uiDiff;
+                GetCaster()->CastSpell(GetCaster(), SPELL_LIGHTNING_ARROWS_AURA, true);
+            }
 
-            if (uiPosionBottleTimer <= uiDiff)
+            void Register() override
             {
-                if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 0))
-                    DoCast(target, SPELL_POISON_BOTTLE);
-                uiPosionBottleTimer = 19000;
-            } else uiPosionBottleTimer -= uiDiff;
+                AfterEffectRemove += AuraEffectRemoveFn(spell_toc5_lightning_arrows_AuraScript::HandleScript, EFFECT_0, SPELL_AURA_PERIODIC_TRIGGER_SPELL, AURA_EFFECT_HANDLE_REAL);
+            }
+        };
 
-            DoMeleeAttackIfReady();
+        AuraScript* GetAuraScript() const override
+        {
+            return new spell_toc5_lightning_arrows_AuraScript();
+        }
+};
+
+enum CriteriaIds
+{
+    CRITERIA_WARRIOR    = 12538,
+    CRITERIA_HUNTER     = 12540,
+    CRITERIA_MAGE       = 12542,
+    CRITERIA_ROGUE      = 12544,
+    CRITERIA_SHAMAN     = 12546,
+    CRITERIA_WARRIOR_H  = 12539,
+    CRITERIA_HUNTER_H   = 12541,
+    CRITERIA_MAGE_H     = 12543,
+    CRITERIA_ROGUE_H    = 12545,
+    CRITERIA_SHAMAN_H   = 12547
+};
+
+// Statistics achievements "Victories over X champion" both normal and heroic
+class achievement_victories_over_champion : public AchievementCriteriaScript
+{
+    public:
+        achievement_victories_over_champion(char const* name, uint32 criteriaId) : AchievementCriteriaScript(name),
+            _criteriaId(criteriaId)
+        {
         }
 
-        void JustDied(Unit* /*killer*/) override
+        bool OnCheck(Player* /*player*/, Unit* target) override
         {
-            instance->SetData(BOSS_GRAND_CHAMPIONS, DONE);
+            if (target)
+            {
+                switch (_criteriaId)
+                {
+                    case CRITERIA_WARRIOR:
+                    case CRITERIA_WARRIOR_H:
+                        return target->GetEntry() == NPC_JACOB || target->GetEntry() == NPC_MOKRA;
+                    case CRITERIA_HUNTER:
+                    case CRITERIA_HUNTER_H:
+                        return target->GetEntry() == NPC_JAELYNE || target->GetEntry() == NPC_ZULTORE;
+                    case CRITERIA_MAGE:
+                    case CRITERIA_MAGE_H:
+                        return target->GetEntry() == NPC_AMBROSE || target->GetEntry() == NPC_ERESSEA;
+                    case CRITERIA_ROGUE:
+                    case CRITERIA_ROGUE_H:
+                        return target->GetEntry() == NPC_LANA || target->GetEntry() == NPC_VISCERI;
+                    case CRITERIA_SHAMAN:
+                    case CRITERIA_SHAMAN_H:
+                        return target->GetEntry() == NPC_COLOSOS || target->GetEntry() == NPC_RUNOK;
+                    default:
+                        break;
+                }
+            }
+            return false;
         }
-    };
 
-    CreatureAI* GetAI(Creature* creature) const override
-    {
-        return GetInstanceAI<boss_rouge_toc5AI>(creature);
-    }
+    private:
+        uint32 const _criteriaId;
 };
 
 void AddSC_boss_grand_champions()
@@ -1030,5 +1783,17 @@ void AddSC_boss_grand_champions()
     new boss_mage_toc5();
     new boss_shaman_toc5();
     new boss_hunter_toc5();
-    new boss_rouge_toc5();
+    new boss_rogue_toc5();
+    new spell_toc5_trample_aura();
+    new spell_toc5_lightning_arrows();
+    new achievement_victories_over_champion("achievement_victories_over_war_champion", CRITERIA_WARRIOR);
+    new achievement_victories_over_champion("achievement_victories_over_hun_champion", CRITERIA_HUNTER);
+    new achievement_victories_over_champion("achievement_victories_over_mag_champion", CRITERIA_MAGE);
+    new achievement_victories_over_champion("achievement_victories_over_rog_champion", CRITERIA_ROGUE);
+    new achievement_victories_over_champion("achievement_victories_over_sha_champion", CRITERIA_SHAMAN);
+    new achievement_victories_over_champion("achievement_victories_over_war_champion_h", CRITERIA_WARRIOR_H);
+    new achievement_victories_over_champion("achievement_victories_over_hun_champion_h", CRITERIA_HUNTER_H);
+    new achievement_victories_over_champion("achievement_victories_over_mag_champion_h", CRITERIA_MAGE_H);
+    new achievement_victories_over_champion("achievement_victories_over_rog_champion_h", CRITERIA_ROGUE_H);
+    new achievement_victories_over_champion("achievement_victories_over_sha_champion_h", CRITERIA_SHAMAN_H);
 }
diff --git a/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheChampion/instance_trial_of_the_champion.cpp b/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheChampion/instance_trial_of_the_champion.cpp
index 00900d4..0a5071b 100644
--- a/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheChampion/instance_trial_of_the_champion.cpp
+++ b/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheChampion/instance_trial_of_the_champion.cpp
@@ -17,311 +17,392 @@
 
 /* ScriptData
 SDName: Instance Trial of the Champion
-SDComment:
+SDComment: missing fireworks when boss encounter is set to done
 SDCategory: Trial Of the Champion
 EndScriptData */
 
-#include "ScriptMgr.h"
-#include "ScriptedCreature.h"
 #include "InstanceScript.h"
-#include "trial_of_the_champion.h"
 #include "Player.h"
+#include "ScriptedCreature.h"
+#include "ScriptMgr.h"
+#include "trial_of_the_champion.h"
+
+ObjectData const creatureData[] =
+{
+    { NPC_ARELAS,       DATA_ANNOUNCER        },
+    { NPC_JAEREN,       DATA_ANNOUNCER        },
+    { NPC_TIRION,       DATA_TIRION           },
+    { NPC_VARIAN,       DATA_VARIAN           },
+    { NPC_JAINA,        DATA_JAINA            },
+    { NPC_GARROSH,      DATA_GARROSH          },
+    { NPC_THRALL,       DATA_THRALL           },
+    { NPC_BLACK_KNIGHT, DATA_THE_BLACK_KNIGHT },
+    { 0,                0                     } // END
+};
 
-#define MAX_ENCOUNTER  4
+ObjectData const gameObjectData[] =
+{
+    { GO_MAIN_GATE,           DATA_MAIN_GATE         },
+    { GO_CHAMPION_S_CACHE,    DATA_CHAMPION_S_CACHE  },
+    { GO_CHAMPION_S_CACHE_H,  DATA_CHAMPION_S_CACHE  },
+    { GO_EADRIC_S_CACHE,      DATA_EADRIC_S_CACHE    },
+    { GO_EADRIC_S_CACHE_H,    DATA_EADRIC_S_CACHE    },
+    { GO_CONFESSOR_S_CACHE,   DATA_CONFESSOR_S_CACHE },
+    { GO_CONFESSOR_S_CACHE_H, DATA_CONFESSOR_S_CACHE },
+    { 0,                      0                      } // END
+};
 
 class instance_trial_of_the_champion : public InstanceMapScript
 {
 public:
-    instance_trial_of_the_champion() : InstanceMapScript("instance_trial_of_the_champion", 650) { }
-
-    InstanceScript* GetInstanceScript(InstanceMap* map) const override
-    {
-        return new instance_trial_of_the_champion_InstanceMapScript(map);
-    }
+    instance_trial_of_the_champion() : InstanceMapScript(ToCScriptName, 650) { }
 
     struct instance_trial_of_the_champion_InstanceMapScript : public InstanceScript
     {
         instance_trial_of_the_champion_InstanceMapScript(Map* map) : InstanceScript(map)
         {
             SetHeaders(DataHeader);
-            uiMovementDone = 0;
-            uiGrandChampionsDeaths = 0;
-            uiArgentSoldierDeaths = 0;
-
-            bDone = false;
+            SetBossNumber(EncounterCount);
+            LoadObjectData(creatureData, gameObjectData);
 
-            memset(&m_auiEncounter, 0, sizeof(m_auiEncounter));
+            TeamInInstance = 0;
+            uiArgentSoldierDeaths = 0;
         }
 
-        uint32 m_auiEncounter[MAX_ENCOUNTER];
-
-        uint16 uiMovementDone;
-        uint16 uiGrandChampionsDeaths;
-        uint8 uiArgentSoldierDeaths;
-
-        ObjectGuid uiAnnouncerGUID;
-        ObjectGuid uiMainGateGUID;
-        ObjectGuid uiGrandChampionVehicle1GUID;
-        ObjectGuid uiGrandChampionVehicle2GUID;
-        ObjectGuid uiGrandChampionVehicle3GUID;
-        ObjectGuid uiGrandChampion1GUID;
-        ObjectGuid uiGrandChampion2GUID;
-        ObjectGuid uiGrandChampion3GUID;
-        ObjectGuid uiChampionLootGUID;
-        ObjectGuid uiArgentChampionGUID;
-
-        GuidList VehicleList;
-
-        std::string str_data;
-
-        bool bDone;
-
-        bool IsEncounterInProgress() const override
+        uint32 GetCreatureEntry(uint32 /*guidLow*/, CreatureData const* data) override
         {
-            for (uint8 i = 0; i < MAX_ENCOUNTER; ++i)
+            if (!TeamInInstance)
+            {
+                Map::PlayerList const& players = instance->GetPlayers();
+                if (!players.isEmpty())
+                    if (Player* player = players.begin()->GetSource())
+                        TeamInInstance = player->GetTeam();
+            }
+
+            uint32 entry = data->id;
+            switch (entry)
             {
-                if (m_auiEncounter[i] == IN_PROGRESS)
-                    return true;
+                case VEHICLE_ARGENT_WARHORSE_COSMETIC:
+                    if (TeamInInstance == ALLIANCE)
+                        return VEHICLE_ARGENT_BATTLEWORG_COSMETIC;
+                    break;
+                case VEHICLE_ARGENT_WARHORSE:
+                    if (TeamInInstance == HORDE)
+                        return VEHICLE_ARGENT_BATTLEWORG;
+                    break;
+                case VEHICLE_ARGENT_BATTLEWORG:
+                    if (TeamInInstance == ALLIANCE)
+                        return VEHICLE_ARGENT_WARHORSE;
+                    break;
+                case VEHICLE_ARGENT_BATTLEWORG_COSMETIC:
+                    if (TeamInInstance == HORDE)
+                        return VEHICLE_ARGENT_WARHORSE_COSMETIC;
+                    break;
+                default:
+                    break;
             }
 
-            return false;
+            return entry;
         }
 
         void OnCreatureCreate(Creature* creature) override
         {
-            Map::PlayerList const &players = instance->GetPlayers();
-            uint32 TeamInInstance = 0;
-
-            if (!players.isEmpty())
+            if (!TeamInInstance)
             {
-                if (Player* player = players.begin()->GetSource())
-                    TeamInInstance = player->GetTeam();
+                Map::PlayerList const& players = instance->GetPlayers();
+                if (!players.isEmpty())
+                    if (Player* player = players.begin()->GetSource())
+                        TeamInInstance = player->GetTeam();
             }
 
             switch (creature->GetEntry())
             {
-                // Champions
-                case VEHICLE_MOKRA_SKILLCRUSHER_MOUNT:
-                    if (TeamInInstance == HORDE)
-                        creature->UpdateEntry(VEHICLE_MARSHAL_JACOB_ALERIUS_MOUNT);
-                    break;
-                case VEHICLE_ERESSEA_DAWNSINGER_MOUNT:
-                    if (TeamInInstance == HORDE)
-                        creature->UpdateEntry(VEHICLE_AMBROSE_BOLTSPARK_MOUNT);
-                    break;
-                case VEHICLE_RUNOK_WILDMANE_MOUNT:
-                    if (TeamInInstance == HORDE)
-                        creature->UpdateEntry(VEHICLE_COLOSOS_MOUNT);
-                    break;
-                case VEHICLE_ZUL_TORE_MOUNT:
-                    if (TeamInInstance == HORDE)
-                        creature->UpdateEntry(VEHICLE_EVENSONG_MOUNT);
-                    break;
-                case VEHICLE_DEATHSTALKER_VESCERI_MOUNT:
-                    if (TeamInInstance == HORDE)
-                        creature->UpdateEntry(VEHICLE_LANA_STOUTHAMMER_MOUNT);
+                case NPC_MOKRA:
+                case NPC_ERESSEA:
+                case NPC_RUNOK:
+                case NPC_ZULTORE:
+                case NPC_VISCERI:
+                case NPC_JACOB:
+                case NPC_AMBROSE:
+                case NPC_COLOSOS:
+                case NPC_JAELYNE:
+                case NPC_LANA:
+                    SetGrandChampionData(creature);
                     break;
                 // Coliseum Announcer || Just NPC_JAEREN must be spawned.
                 case NPC_JAEREN:
-                    uiAnnouncerGUID = creature->GetGUID();
                     if (TeamInInstance == ALLIANCE)
                         creature->UpdateEntry(NPC_ARELAS);
                     break;
+                case VEHICLE_ARGENT_WARHORSE_COSMETIC:
                 case VEHICLE_ARGENT_WARHORSE:
                 case VEHICLE_ARGENT_BATTLEWORG:
+                case VEHICLE_ARGENT_BATTLEWORG_COSMETIC:
                     VehicleList.push_back(creature->GetGUID());
                     break;
                 case NPC_EADRIC:
                 case NPC_PALETRESS:
                     uiArgentChampionGUID = creature->GetGUID();
                     break;
+                case VEHICLE_BLACK_KNIGHT:
+                    uiBlackKnightVehicleGUID = creature->GetGUID();
+                    break;
+                // Setting passive and unattackable flags to Lesser Champions and Grand Champions' vehicles
+                case VEHICLE_DARNASSUS_CHAMPION:
+                case VEHICLE_EXODAR_CHAMPION:
+                case VEHICLE_STORMWIND_CHAMPION:
+                case VEHICLE_GNOMEREGAN_CHAMPION:
+                case VEHICLE_IRONFORGE_CHAMPION:
+                case VEHICLE_UNDERCITY_CHAMPION:
+                case VEHICLE_THUNDER_BLUFF_CHAMPION:
+                case VEHICLE_ORGRIMMAR_CHAMPION:
+                case VEHICLE_SILVERMOON_CHAMPION:
+                case VEHICLE_SENJIN_CHAMPION:
+                case VEHICLE_AMBROSE_BOLTSPARK_MOUNT:
+                case VEHICLE_COLOSOS_MOUNT:
+                case VEHICLE_MARSHAL_JACOB_ALERIUS_MOUNT:
+                case VEHICLE_MOKRA_SKILLCRUSHER_MOUNT:
+                case VEHICLE_ERESSEA_DAWNSINGER_MOUNT:
+                case VEHICLE_RUNOK_WILDMANE_MOUNT:
+                case VEHICLE_ZUL_TORE_MOUNT:
+                case VEHICLE_EVENSONG_MOUNT:
+                case VEHICLE_DEATHSTALKER_VESCERI_MOUNT:
+                case VEHICLE_LANA_STOUTHAMMER_MOUNT:
+                    creature->SetReactState(REACT_PASSIVE);
+                    creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                    break;
+                default:
+                    break;
             }
+
+            InstanceScript::OnCreatureCreate(creature);
         }
 
-        void OnGameObjectCreate(GameObject* go) override
+        void SetGrandChampionData(Creature* cr)
         {
-            switch (go->GetEntry())
-            {
-                case GO_MAIN_GATE:
-                    uiMainGateGUID = go->GetGUID();
-                    break;
-                case GO_CHAMPIONS_LOOT:
-                case GO_CHAMPIONS_LOOT_H:
-                    uiChampionLootGUID = go->GetGUID();
-                    break;
-            }
+            if (!uiGrandChampion1GUID)
+                uiGrandChampion1GUID = cr->GetGUID();
+            else if (!uiGrandChampion2GUID)
+                uiGrandChampion2GUID = cr->GetGUID();
+            else if (!uiGrandChampion3GUID)
+                uiGrandChampion3GUID = cr->GetGUID();
         }
 
         void SetData(uint32 uiType, uint32 uiData) override
         {
             switch (uiType)
             {
-                case DATA_MOVEMENT_DONE:
-                    uiMovementDone = uiData;
-                    if (uiMovementDone == 3)
+                case DATA_REMOVE_VEHICLES:
+                {
+                    for (ObjectGuid const& guid : VehicleList)
+                        if (Creature* summon = instance->GetCreature(guid))
+                            summon->DespawnOrUnsummon();
+
+                    // We must remove defense spells from players
+                    Map::PlayerList const& players = instance->GetPlayers();
+                    for (Map::PlayerList::const_iterator itr = players.begin(); itr != players.end(); ++itr)
                     {
-                        if (Creature* pAnnouncer =  instance->GetCreature(uiAnnouncerGUID))
-                            pAnnouncer->AI()->SetData(DATA_IN_POSITION, 0);
+                        Player* plr = itr->GetSource();
+                        plr->RemoveAura(62552); // Actual defense spell
+                        plr->RemoveAura(63130); // Shield Level 1 (visual only)
+                        plr->RemoveAura(63131); // Shield Level 2 (visual only)
+                        plr->RemoveAura(63132); // Shield Level 3 (visual only)
                     }
                     break;
-                case BOSS_GRAND_CHAMPIONS:
-                    m_auiEncounter[0] = uiData;
-                    if (uiData == IN_PROGRESS)
+                }
+                case DATA_ARGENT_SOLDIER_DEFEATED:
+                    uiArgentSoldierDeaths = uiData;
+                    if (uiArgentSoldierDeaths == 9)
                     {
-                        for (GuidList::const_iterator itr = VehicleList.begin(); itr != VehicleList.end(); ++itr)
-                            if (Creature* summon = instance->GetCreature(*itr))
-                                summon->RemoveFromWorld();
-                    }else if (uiData == DONE)
+                        if (Creature* pBoss = instance->GetCreature(uiArgentChampionGUID))
+                        {
+                            pBoss->setFaction(16);
+                            pBoss->SetHomePosition(747.02f, 637.65f, 411.57f, centerOrientation);
+                            pBoss->GetMotionMaster()->MovePoint(1, pBoss->GetHomePosition());
+                        }
+                    }
+                    break;
+                default:
+                    break;
+            }
+        }
+
+        bool SetBossState(uint32 type, EncounterState state) override
+        {
+            if (!InstanceScript::SetBossState(type, state))
+                return false;
+
+            switch (type)
+            {
+                case DATA_GRAND_CHAMPIONS:
+                    if (state == DONE)
                     {
-                        ++uiGrandChampionsDeaths;
-                        if (uiGrandChampionsDeaths == 3)
+                        if (Creature* pAnnouncer = GetCreature(DATA_ANNOUNCER))
                         {
-                            if (Creature* pAnnouncer =  instance->GetCreature(uiAnnouncerGUID))
+                            // On heroic mode we must bind players to the instance
+                            if (instance->IsHeroic())
                             {
-                                pAnnouncer->GetMotionMaster()->MovePoint(0, 748.309f, 619.487f, 411.171f);
-                                pAnnouncer->SetFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP);
-                                pAnnouncer->SummonGameObject(instance->IsHeroic()? GO_CHAMPIONS_LOOT_H : GO_CHAMPIONS_LOOT, 746.59f, 618.49f, 411.09f, 1.42f, 0, 0, 0, 0, 90000);
+                                Map::PlayerList const &players = instance->GetPlayers();
+                                for (Map::PlayerList::const_iterator itr = players.begin(); itr != players.end(); ++itr)
+                                {
+                                    Player* plr = itr->GetSource();
+                                    if (!plr->IsGameMaster())
+                                    {
+                                        if (instance->ToInstanceMap())
+                                            instance->ToInstanceMap()->PermBindAllPlayers(plr);
+                                        break;
+                                    }
+                                }
+                            }
+                            pAnnouncer->GetMotionMaster()->MovePoint(1, announcerWaitPos);
+                            pAnnouncer->AI()->SetData(DATA_GRAND_CHAMPIONS_DONE, 0);
+                            if (GameObject* cache = GetGameObject(DATA_CHAMPION_S_CACHE))
+                            {
+                                cache->RemoveFlag(GAMEOBJECT_FLAGS, GO_FLAG_NOT_SELECTABLE);
+                                cache->SetRespawnTime(1 * DAY);
                             }
                         }
                     }
                     break;
-                case DATA_ARGENT_SOLDIER_DEFEATED:
-                    uiArgentSoldierDeaths = uiData;
-                    if (uiArgentSoldierDeaths == 9)
+                case DATA_EADRIC_THE_PURE:
+                case DATA_ARGENT_CONFESSOR_PALETRESS:
+                    if (state == SPECIAL)
                     {
-                        if (Creature* pBoss =  instance->GetCreature(uiArgentChampionGUID))
+                        if (Creature* pChampion = instance->GetCreature(uiArgentChampionGUID))
                         {
-                            pBoss->GetMotionMaster()->MovePoint(0, 746.88f, 618.74f, 411.06f);
-                            pBoss->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
-                            pBoss->SetReactState(REACT_AGGRESSIVE);
+                            pChampion->InterruptNonMeleeSpells(true);
+                            pChampion->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                            pChampion->SetReactState(REACT_PASSIVE);
+                            pChampion->SetHealth(1);
+                            pChampion->CombatStop(true);
+                            pChampion->setRegeneratingHealth(false);
+                            pChampion->SetUInt32Value(UNIT_NPC_EMOTESTATE, EMOTE_ONESHOT_NONE);
+                            pChampion->SetHomePosition(745.87f, 625.88f, 411.17f, pChampion->GetHomePosition().GetOrientation());
+                            pChampion->GetMotionMaster()->MoveTargetedHome();
                         }
                     }
-                    break;
-                case BOSS_ARGENT_CHALLENGE_E:
-                    m_auiEncounter[1] = uiData;
-                    if (Creature* pAnnouncer = instance->GetCreature(uiAnnouncerGUID))
+                    else if (state == DONE)
                     {
-                        pAnnouncer->GetMotionMaster()->MovePoint(0, 748.309f, 619.487f, 411.171f);
-                        pAnnouncer->SetFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP);
-                        pAnnouncer->SummonGameObject(instance->IsHeroic()? GO_EADRIC_LOOT_H : GO_EADRIC_LOOT, 746.59f, 618.49f, 411.09f, 1.42f, 0, 0, 0, 0, 90000);
+                        if (Creature* pAnnouncer = GetCreature(DATA_ANNOUNCER))
+                        {
+                            // On heroic mode we must bind players to the instance
+                            if (instance->IsHeroic())
+                            {
+                                Map::PlayerList const &players = instance->GetPlayers();
+                                for (Map::PlayerList::const_iterator itr = players.begin(); itr != players.end(); ++itr)
+                                {
+                                    Player* plr = itr->GetSource();
+                                    if (!plr->IsGameMaster())
+                                    {
+                                        if (instance->ToInstanceMap())
+                                            instance->ToInstanceMap()->PermBindAllPlayers(plr);
+                                        break;
+                                    }
+                                }
+                            }
+                            pAnnouncer->GetMotionMaster()->MovePoint(1, announcerWaitPos);
+                            if (type == DATA_EADRIC_THE_PURE)
+                            {
+                                if (GameObject* cache = GetGameObject(DATA_EADRIC_S_CACHE))
+                                {
+                                    cache->RemoveFlag(GAMEOBJECT_FLAGS, GO_FLAG_NOT_SELECTABLE);
+                                    cache->SetRespawnTime(1 * DAY);
+                                }
+                            }
+                            else
+                            {
+                                if (GameObject* cache = GetGameObject(DATA_CONFESSOR_S_CACHE))
+                                {
+                                    cache->RemoveFlag(GAMEOBJECT_FLAGS, GO_FLAG_NOT_SELECTABLE);
+                                    cache->SetRespawnTime(1 * DAY);
+                                }
+                            }
+                        }
                     }
                     break;
-                case BOSS_ARGENT_CHALLENGE_P:
-                    m_auiEncounter[2] = uiData;
-                    if (Creature* pAnnouncer = instance->GetCreature(uiAnnouncerGUID))
+                case DATA_THE_BLACK_KNIGHT:
+                    if (state == DONE)
                     {
-                        pAnnouncer->GetMotionMaster()->MovePoint(0, 748.309f, 619.487f, 411.171f);
-                        pAnnouncer->SetFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP);
-                        pAnnouncer->SummonGameObject(instance->IsHeroic()? GO_PALETRESS_LOOT_H : GO_PALETRESS_LOOT, 746.59f, 618.49f, 411.09f, 1.42f, 0, 0, 0, 0, 90000);
+                        if (Creature* pAnnouncer = GetCreature(DATA_ANNOUNCER))
+                            pAnnouncer->AI()->SetData(DATA_BLACK_KNIGHT_DONE, 0);
                     }
                     break;
+                default:
+                    break;
             }
-
-            if (uiData == DONE)
-                SaveToDB();
+            return true;
         }
 
-        uint32 GetData(uint32 uiData) const override
+        uint32 GetData(uint32 type) const override
         {
-            switch (uiData)
+            switch (type)
             {
-                case BOSS_GRAND_CHAMPIONS:  return m_auiEncounter[0];
-                case BOSS_ARGENT_CHALLENGE_E: return m_auiEncounter[1];
-                case BOSS_ARGENT_CHALLENGE_P: return m_auiEncounter[2];
-                case BOSS_BLACK_KNIGHT: return m_auiEncounter[3];
-
-                case DATA_MOVEMENT_DONE: return uiMovementDone;
-                case DATA_ARGENT_SOLDIER_DEFEATED: return uiArgentSoldierDeaths;
+                case DATA_TEAM_IN_INSTANCE:
+                    return TeamInInstance;
+                case DATA_ARGENT_SOLDIER_DEFEATED:
+                    return uiArgentSoldierDeaths;
+                default:
+                    break;
             }
-
             return 0;
         }
 
-        ObjectGuid GetGuidData(uint32 uiData) const override
+        ObjectGuid GetGuidData(uint32 type) const override
         {
-            switch (uiData)
+            switch (type)
             {
-                case DATA_ANNOUNCER: return uiAnnouncerGUID;
-                case DATA_MAIN_GATE: return uiMainGateGUID;
-
                 case DATA_GRAND_CHAMPION_1: return uiGrandChampion1GUID;
                 case DATA_GRAND_CHAMPION_2: return uiGrandChampion2GUID;
                 case DATA_GRAND_CHAMPION_3: return uiGrandChampion3GUID;
+
+                case DATA_GRAND_CHAMPION_VEHICLE_1: return uiGrandChampionVehicle1GUID;
+                case DATA_GRAND_CHAMPION_VEHICLE_2: return uiGrandChampionVehicle2GUID;
+                case DATA_GRAND_CHAMPION_VEHICLE_3: return uiGrandChampionVehicle3GUID;
+
+                case DATA_ARGENT_CHAMPION: return uiArgentChampionGUID;
+
+                case DATA_BLACK_KNIGHT_VEHICLE: return uiBlackKnightVehicleGUID;
             }
 
-            return ObjectGuid::Empty;
+            return GetObjectGuid(type);
         }
 
         void SetGuidData(uint32 uiType, ObjectGuid uiData) override
         {
             switch (uiType)
             {
-                case DATA_GRAND_CHAMPION_1:
-                    uiGrandChampion1GUID = uiData;
+                case DATA_GRAND_CHAMPION_VEHICLE_1:
+                    uiGrandChampionVehicle1GUID = uiData;
                     break;
-                case DATA_GRAND_CHAMPION_2:
-                    uiGrandChampion2GUID = uiData;
+                case DATA_GRAND_CHAMPION_VEHICLE_2:
+                    uiGrandChampionVehicle2GUID = uiData;
                     break;
-                case DATA_GRAND_CHAMPION_3:
-                    uiGrandChampion3GUID = uiData;
+                case DATA_GRAND_CHAMPION_VEHICLE_3:
+                    uiGrandChampionVehicle3GUID = uiData;
                     break;
             }
         }
 
-        std::string GetSaveData() override
-        {
-            OUT_SAVE_INST_DATA;
-
-            std::ostringstream saveStream;
-
-            saveStream << "T C " << m_auiEncounter[0]
-                << ' ' << m_auiEncounter[1]
-                << ' ' << m_auiEncounter[2]
-                << ' ' << m_auiEncounter[3]
-                << ' ' << uiGrandChampionsDeaths
-                << ' ' << uiMovementDone;
-
-            str_data = saveStream.str();
-
-            OUT_SAVE_INST_DATA_COMPLETE;
-            return str_data;
-        }
-
-        void Load(const char* in) override
-        {
-            if (!in)
-            {
-                OUT_LOAD_INST_DATA_FAIL;
-                return;
-            }
-
-            OUT_LOAD_INST_DATA(in);
-
-            char dataHead1, dataHead2;
-            uint16 data0, data1, data2, data3, data4, data5;
-
-            std::istringstream loadStream(in);
-            loadStream >> dataHead1 >> dataHead2 >> data0 >> data1 >> data2 >> data3 >> data4 >> data5;
-
-            if (dataHead1 == 'T' && dataHead2 == 'C')
-            {
-                m_auiEncounter[0] = data0;
-                m_auiEncounter[1] = data1;
-                m_auiEncounter[2] = data2;
-                m_auiEncounter[3] = data3;
-
-                for (uint8 i = 0; i < MAX_ENCOUNTER; ++i)
-                    if (m_auiEncounter[i] == IN_PROGRESS)
-                        m_auiEncounter[i] = NOT_STARTED;
+    private:
+        ObjectGuid uiGrandChampionVehicle1GUID;
+        ObjectGuid uiGrandChampionVehicle2GUID;
+        ObjectGuid uiGrandChampionVehicle3GUID;
+        ObjectGuid uiGrandChampion1GUID;
+        ObjectGuid uiGrandChampion2GUID;
+        ObjectGuid uiGrandChampion3GUID;
+        ObjectGuid uiArgentChampionGUID;
+        ObjectGuid uiBlackKnightVehicleGUID;
 
-                uiGrandChampionsDeaths = data4;
-                uiMovementDone = data5;
-            } else OUT_LOAD_INST_DATA_FAIL;
+        GuidList VehicleList;
 
-            OUT_LOAD_INST_DATA_COMPLETE;
-        }
+        uint32 TeamInInstance;
+        uint8 uiArgentSoldierDeaths;
     };
 
+    InstanceScript* GetInstanceScript(InstanceMap* map) const override
+    {
+        return new instance_trial_of_the_champion_InstanceMapScript(map);
+    }
 };
 
 void AddSC_instance_trial_of_the_champion()
diff --git a/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheChampion/trial_of_the_champion.cpp b/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheChampion/trial_of_the_champion.cpp
index 4ee8dcf..6a28895 100644
--- a/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheChampion/trial_of_the_champion.cpp
+++ b/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheChampion/trial_of_the_champion.cpp
@@ -15,17 +15,6 @@
  * with this program. If not, see <http://www.gnu.org/licenses/>.
  */
 
-/* ScriptData
-SDName: Trial Of the Champion
-SD%Complete:
-SDComment:
-SDCategory: trial_of_the_champion
-EndScriptData */
-
-/* ContentData
-npc_announcer_toc5
-EndContentData */
-
 #include "ScriptMgr.h"
 #include "ScriptedCreature.h"
 #include "ScriptedGossip.h"
@@ -33,28 +22,250 @@ EndContentData */
 #include "Vehicle.h"
 #include "Player.h"
 
-enum Yells
+#define GOSSIP_START_EVENT1     "I am ready."
+#define GOSSIP_START_EVENT2     "I am ready for the next challenge."
+#define GOSSIP_START_EVENT_SKIP "I am ready. However I'd like to skip the pageantry."
+
+enum Texts
+{
+    // Used by announcers
+    SAY_INTRO_2_E               = 0,
+    SAY_INTRO_2_P               = 1,
+    SAY_INTRO_1                 = 2,
+    SAY_INTRO_SHAM_A            = 3,
+    SAY_INTRO_MAGE_H            = 3,
+    SAY_INTRO_HUN               = 4,
+    SAY_INTRO_MAGE_A            = 5,
+    SAY_INTRO_WARR_H            = 5,
+    SAY_INTRO_WARR_A            = 6,
+    SAY_INTRO_ROG_H             = 6,
+    SAY_INTRO_ROG_A             = 7,
+    SAY_INTRO_SHAM_H            = 7,
+    SAY_INTRO_3                 = 8,
+    SAY_INTRODUCE_PLR_0         = 9,
+    SAY_INTRODUCE_PLR_1         = 10,
+    SAY_INTRODUCE_PLR_2         = 11,
+    SAY_INTRODUCE_PLR_3         = 12,
+    SAY_INTRODUCE_PLR_4         = 13,
+
+    // Used by Tirion
+    SAY_TIRION_INTRO_1          = 50,
+    SAY_TIRION_INTRO_2          = 51,
+    SAY_TIRION_INTRO_3          = 52,
+    SAY_TIRION_OUTRO_1          = 53,
+    SAY_TIRION_INTRO_4          = 54,
+    SAY_TIRION_INTRO_5          = 55,
+    SAY_TIRION_INTRO_6          = 56,
+    SAY_TIRION_OUTRO_2          = 57,
+    SAY_TIRION_OUTRO_3          = 58,
+
+    // Used by Varian
+    SAY_VARIAN_INTRO_1          = 50,
+    SAY_VARIAN_INTRO_2          = 52,
+    SAY_VARIAN_INTRO_3          = 51,
+    SAY_VARIAN_OUTRO_1          = 53,
+
+    // Used by Garrosh
+    SAY_GARROSH_INTRO_1         = 50,
+    SAY_GARROSH_INTRO_2         = 52,
+    SAY_GARROSH_INTRO_3         = 51,
+
+    // Used by Jaina
+    SAY_JAINA_INTRO_1           = 0,
+    SAY_JAINA_INTRO_2           = 1,
+
+    // Used by Thrall
+    SAY_THRALL_INTRO_1          = 0,
+    SAY_THRALL_INTRO_2          = 2,
+    SAY_THRALL_OUTRO_1          = 1,
+
+    // Used by Argent Confessor Paletress
+    SAY_PALETRESS_INTRO_1       = 0,
+    SAY_PALETRESS_INTRO_2       = 1,
+
+    // Used by Eadric the Pure
+    SAY_EADRIC_INTRO_1          = 0,
+
+    // Used by The Black Knight
+    SAY_KNIGHT_INTRO_1          = 0,
+    SAY_KNIGHT_INTRO_2          = 1,
+    SAY_KNIGHT_INTRO_3          = 2,
+
+    // Used by spectators (same id for every spectator)
+    EMOTE_SPECTATOR_CHEER       = 0
+};
+
+enum BossData
+{
+    BOSS_WARRIOR,
+    BOSS_MAGE,
+    BOSS_SHAMAN,
+    BOSS_HUNTER,
+    BOSS_ROGUE,
+    BOSS_EADRIC,
+    BOSS_PALETRESS
+};
+
+enum GossipTexts
 {
-    SAY_INTRO_1         = 0,
-    SAY_INTRO_2         = 1,
-    SAY_INTRO_3         = 2,
-    SAY_AGGRO           = 3,
-    SAY_PHASE_2         = 4,
-    SAY_PHASE_3         = 5,
-    SAY_KILL_PLAYER     = 6,
-    SAY_DEATH           = 7
+    GOSSIP_TEXT_UNMOUNTED_A     = 14757,
+    GOSSIP_TEXT_UNMOUNTED_H     = 15043,
+    GOSSIP_TEXT_FIRST_BOSS      = 14688,
+    GOSSIP_TEXT_SECOND_BOSS     = 14737,
+    GOSSIP_TEXT_THIRD_BOSS      = 14738
 };
 
-#define GOSSIP_START_EVENT1     "I'm ready to start challenge."
-#define GOSSIP_START_EVENT2     "I'm ready for the next challenge."
+enum Events
+{
+    EVENT_CHEER_RND             = 1,
+    // Grand Champion - roleplaying intro
+    EVENT_INTRODUCE,
+    EVENT_CHAT_1,
+    EVENT_CHAT_2,
+    EVENT_CHAT_3,
+    EVENT_CHAT_4,
+    EVENT_CHAT_5,
+    EVENT_CHAT_6,
+    EVENT_SUMMON_1,
+    EVENT_OPEN_DOOR_1,
+    EVENT_INTRODUCE_BOSS_1,
+    EVENT_CLOSE_DOOR_1,
+    EVENT_SUMMON_2,
+    EVENT_OPEN_DOOR_2,
+    EVENT_INTRODUCE_BOSS_2,
+    EVENT_CLOSE_DOOR_2,
+    EVENT_SUMMON_3,
+    EVENT_OPEN_DOOR_3,
+    EVENT_INTRODUCE_BOSS_3,
+    EVENT_CLOSE_DOOR_3,
+    EVENT_WAIT_1,
+    EVENT_FACING,
+    EVENT_CHAT_7,
+    EVENT_AGGRO_1,
+    EVENT_CHAT_8,
+    // Grand Champion - roleplaying skipped
+    EVENT_CHAT_9                = 30,
+    EVENT_SUMMON_1_SKIP,
+    EVENT_SUMMON_2_SKIP,
+    EVENT_SUMMON_3_SKIP,
+    // Argent Champion
+    EVENT_MOVE_MIDDLE           = 40,
+    EVENT_SPAWN_ALL,
+    EVENT_OPEN_DOOR_4,
+    EVENT_INTRODUCE_BOSS_4,
+    EVENT_ARGENT_BOSS_WALK,
+    EVENT_GO_TO_ARGENT_BOSS,
+    EVENT_CHAT_10,
+    EVENT_CHAT_11,
+    EVENT_WAIT_2,
+    EVENT_CHAT_12,
+    // The Black Knight
+    EVENT_STEP_FORWARD          = 50,
+    EVENT_CHAT_13,
+    EVENT_FACING_1,
+    EVENT_CHAT_14,
+    EVENT_START_PATH,
+    EVENT_CHAT_15,
+    EVENT_FACING_2,
+    EVENT_STUN_ANNOUNCER,
+    EVENT_CHAT_16,
+    EVENT_KNOCK_ANNOUNCER,
+    EVENT_CHAT_17,
+    EVENT_CHAT_18,
+    EVENT_AGGRO_2,
+    EVENT_CHAT_19,
+    EVENT_CHAT_20,
+    EVENT_CHAT_21,
+    EVENT_CHAT_22
+};
 
-#define ORIENTATION             4.714f
+enum Spells
+{
+    // Both casted by The Black Knight to announcer
+    SPELL_DEATHS_RESPITE        = 66798,
+    SPELL_DEATHS_PUSH           = 66797
+};
+
+enum PointMovement
+{
+    POINT_ENCOUNTER_1_WAIT      = 0,
+    POINT_RETURN_TO_CENTER,
+    POINT_START_ARGENT_CHAMP,
+    POINT_ENCOUNTER_2_WAIT_1,
+    POINT_ENCOUNTER_2_WAIT_2,
+    POINT_ENCOUNTER_3_WAIT
+};
 
 /*######
 ## npc_announcer_toc5
 ######*/
 
-const Position SpawnPosition = {746.261f, 657.401f, 411.681f, 4.65f};
+const Position SpawnPosition = {746.261f, 687.0f, 412.374f, 4.65f};
+uint32 const IntroducePlrTxt[5] = { SAY_INTRODUCE_PLR_0, SAY_INTRODUCE_PLR_1, SAY_INTRODUCE_PLR_2, SAY_INTRODUCE_PLR_3, SAY_INTRODUCE_PLR_4 };
+uint32 const SpectatorData[12] =
+{
+    0,
+    NPC_SPECTATOR_HUMAN,
+    NPC_SPECTATOR_ORC,
+    NPC_SPECTATOR_DWARF,
+    NPC_SPECTATOR_NELF,
+    NPC_SPECTATOR_UNDEAD,
+    NPC_SPECTATOR_TAUREN,
+    NPC_SPECTATOR_GNOME,
+    NPC_SPECTATOR_TROLL,
+    0,
+    NPC_SPECTATOR_BELF,
+    NPC_SPECTATOR_DRAENEI
+};
+
+// Bases mostly on Joshiwald's work (big thanks)
+struct GrandChampionInfo
+{
+    uint32 GrandChampionEntry[2];
+    uint32 FactionChampionEntry[2];
+    uint8 AnnounceText[2];
+    uint32 GrandChampionRealEntry[2]; // used only for cheering at correct champion if event is skipped
+    uint32 SpecatatorEntry[2];
+};
+
+GrandChampionInfo const GrandChampionData[5] =
+{
+    {
+        { VEHICLE_MOKRA_SKILLCRUSHER_MOUNT,     VEHICLE_MARSHAL_JACOB_ALERIUS_MOUNT },
+        { VEHICLE_ORGRIMMAR_CHAMPION,           VEHICLE_STORMWIND_CHAMPION          },
+        { SAY_INTRO_WARR_H,                     SAY_INTRO_WARR_A                    },
+        { NPC_MOKRA,                            NPC_JACOB                           },
+        { SpectatorData[RACE_ORC],              SpectatorData[RACE_HUMAN]           },
+    },
+    {
+        { VEHICLE_ERESSEA_DAWNSINGER_MOUNT,     VEHICLE_AMBROSE_BOLTSPARK_MOUNT     },
+        { VEHICLE_SILVERMOON_CHAMPION,          VEHICLE_GNOMEREGAN_CHAMPION         },
+        { SAY_INTRO_MAGE_H,                     SAY_INTRO_MAGE_A                    },
+        { NPC_ERESSEA,                          NPC_AMBROSE                         },
+        { SpectatorData[RACE_BLOODELF],         SpectatorData[RACE_GNOME]           },
+    },
+    {
+        { VEHICLE_RUNOK_WILDMANE_MOUNT,         VEHICLE_COLOSOS_MOUNT               },
+        { VEHICLE_THUNDER_BLUFF_CHAMPION,       VEHICLE_EXODAR_CHAMPION             },
+        { SAY_INTRO_SHAM_H,                     SAY_INTRO_SHAM_A                    },
+        { NPC_RUNOK,                            NPC_COLOSOS                         },
+        { SpectatorData[RACE_TAUREN],           SpectatorData[RACE_DRAENEI]         },
+    },
+    {
+        { VEHICLE_ZUL_TORE_MOUNT,               VEHICLE_EVENSONG_MOUNT              },
+        { VEHICLE_SENJIN_CHAMPION,              VEHICLE_DARNASSUS_CHAMPION          },
+        { SAY_INTRO_HUN,                        SAY_INTRO_HUN                       },
+        { NPC_ZULTORE,                          NPC_JAELYNE                         },
+        { SpectatorData[RACE_TROLL],            SpectatorData[RACE_NIGHTELF]        },
+    },
+    {
+        { VEHICLE_DEATHSTALKER_VESCERI_MOUNT,   VEHICLE_LANA_STOUTHAMMER_MOUNT      },
+        { VEHICLE_UNDERCITY_CHAMPION,           VEHICLE_IRONFORGE_CHAMPION          },
+        { SAY_INTRO_ROG_H,                      SAY_INTRO_ROG_A                     },
+        { NPC_VISCERI,                          NPC_LANA                            },
+        { SpectatorData[RACE_UNDEAD_PLAYER],    SpectatorData[RACE_DWARF]           },
+    }
+};
 
 class npc_announcer_toc5 : public CreatureScript
 {
@@ -68,21 +279,19 @@ class npc_announcer_toc5 : public CreatureScript
             instance = creature->GetInstanceScript();
 
             uiSummonTimes = 0;
-            uiPosition = 0;
             uiLesserChampions = 0;
 
             uiFirstBoss = 0;
             uiSecondBoss = 0;
             uiThirdBoss = 0;
-
             uiArgentChampion = 0;
 
-            uiPhase = 0;
-            uiTimer = 0;
+            SetCombatMovement(false);
 
             me->SetReactState(REACT_PASSIVE);
             me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
             me->SetFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP);
+            me->SetWalk(true);
 
             SetGrandChampionsForEncounter();
             SetArgentChampion();
@@ -91,49 +300,88 @@ class npc_announcer_toc5 : public CreatureScript
         InstanceScript* instance;
 
         uint8 uiSummonTimes;
-        uint8 uiPosition;
         uint8 uiLesserChampions;
 
-        uint32 uiArgentChampion;
-
         uint32 uiFirstBoss;
         uint32 uiSecondBoss;
         uint32 uiThirdBoss;
+        uint32 uiArgentChampion;
 
-        uint32 uiPhase;
-        uint32 uiTimer;
-
-        ObjectGuid uiVehicle1GUID;
-        ObjectGuid uiVehicle2GUID;
-        ObjectGuid uiVehicle3GUID;
+        EventMap events;
 
         GuidList Champion1List;
         GuidList Champion2List;
         GuidList Champion3List;
+        GuidList PlayerEventList;
 
-        void NextStep(uint32 uiTimerStep, bool bNextStep = true, uint8 uiPhaseStep = 0)
+        void NextStep(uint32 uiTimerStep, uint32 currentEvent, bool bNextStep = true, uint8 uiPhaseStep = 0)
         {
-            uiTimer = uiTimerStep;
             if (bNextStep)
-                ++uiPhase;
+                events.ScheduleEvent(currentEvent + 1, uiTimerStep);
             else
-                uiPhase = uiPhaseStep;
+            {
+                if (uiPhaseStep > 0)
+                    events.ScheduleEvent(uiPhaseStep, uiTimerStep);
+            }
         }
 
-        void SetData(uint32 uiType, uint32 /*uiData*/) override
+        void Reset() override
+        {
+            events.Reset();
+            events.ScheduleEvent(EVENT_CHEER_RND, 120000);
+        }
+
+        void SetData(uint32 uiType, uint32 uiData) override
         {
             switch (uiType)
             {
                 case DATA_START:
-                    DoSummonGrandChampion(uiFirstBoss);
-                    NextStep(10000, false, 1);
+                    if (Creature* tirion = instance->GetCreature(DATA_TIRION))
+                        tirion->AI()->Talk(SAY_TIRION_INTRO_1);
+                    me->GetMotionMaster()->MovePoint(POINT_ENCOUNTER_1_WAIT, announcerEncounterPos);
+                    NextStep(6000, 0, false, EVENT_CHAT_9);
                     break;
-                case DATA_IN_POSITION: //movement done.
-                    me->GetMotionMaster()->MovePoint(1, 735.81f, 661.92f, 412.39f);
-                    if (GameObject* go = ObjectAccessor::GetGameObject(*me, instance->GetGuidData(DATA_MAIN_GATE)))
-                        instance->HandleGameObject(go->GetGUID(), false);
-                    NextStep(10000, false, 3);
+                case DATA_LESSER_CHAMPIONS_PREPARE:
+                {
+                    // Moving lesser champions to right position
+                    uint32 TeamInInstance = instance->GetData(DATA_TEAM_IN_INSTANCE);
+                    GuidList* TempList = nullptr;
+                    uint8 x = 0;
+                    switch (uiData)
+                    {
+                        case WAYPOINT_MAP_BOSS_1:
+                            TempList = &Champion1List;
+                            if (TeamInInstance == HORDE)
+                                x = 9;
+                            else
+                                x = 0;
+                            break;
+                        case WAYPOINT_MAP_BOSS_2:
+                            TempList = &Champion2List;
+                            if (TeamInInstance == HORDE)
+                                x = 12;
+                            else
+                                x = 3;
+                            break;
+                        case WAYPOINT_MAP_BOSS_3:
+                            TempList = &Champion3List;
+                            if (TeamInInstance == HORDE)
+                                x = 15;
+                            else
+                                x = 6;
+                            break;
+                        default:
+                            break;
+                    }
+
+                    for (ObjectGuid const& guid : *TempList)
+                    {
+                        if (Creature* add = ObjectAccessor::GetCreature(*me, guid))
+                            add->AI()->SetData(DATA_GENERATE_WAYPOINTS_FOR_ADDS, x);
+                        x++;
+                    }
                     break;
+                }
                 case DATA_LESSER_CHAMPIONS_DEFEATED:
                 {
                     ++uiLesserChampions;
@@ -152,26 +400,42 @@ class npc_announcer_toc5 : public CreatureScript
 
                         for (GuidList::const_iterator itr = TempList.begin(); itr != TempList.end(); ++itr)
                             if (Creature* summon = ObjectAccessor::GetCreature(*me, *itr))
-                                AggroAllPlayers(summon);
+                                EnterAggressiveMode(summon);
                     }else if (uiLesserChampions == 9)
                         StartGrandChampionsAttack();
 
                     break;
                 }
+                case DATA_GRAND_CHAMPIONS_DONE:
+                    NextStep(3000, 0, false, EVENT_CHAT_8);
+                    break;
+                case DATA_ARGENT_CHAMPION_PREPARE:
+                    NextStep(500, 0, false, EVENT_GO_TO_ARGENT_BOSS);
+                    break;
+                case DATA_BLACK_KNIGHT_PREPARE:
+                    NextStep(2000, 0, false, EVENT_CHAT_15);
+                    break;
+                case DATA_BLACK_KNIGHT_PRECAST:
+                    NextStep(500, 0, false, EVENT_FACING_2);
+                    break;
+                case DATA_BLACK_KNIGHT_DONE:
+                    NextStep(7000, 0, false, EVENT_CHAT_20);
+                    break;
+                default:
+                    break;
             }
         }
 
         void StartGrandChampionsAttack()
         {
-            Creature* pGrandChampion1 = ObjectAccessor::GetCreature(*me, uiVehicle1GUID);
-            Creature* pGrandChampion2 = ObjectAccessor::GetCreature(*me, uiVehicle2GUID);
-            Creature* pGrandChampion3 = ObjectAccessor::GetCreature(*me, uiVehicle3GUID);
-
+            Creature* pGrandChampion1 = ObjectAccessor::GetCreature(*me, instance->GetGuidData(DATA_GRAND_CHAMPION_VEHICLE_1));
+            Creature* pGrandChampion2 = ObjectAccessor::GetCreature(*me, instance->GetGuidData(DATA_GRAND_CHAMPION_VEHICLE_2));
+            Creature* pGrandChampion3 = ObjectAccessor::GetCreature(*me, instance->GetGuidData(DATA_GRAND_CHAMPION_VEHICLE_3));
             if (pGrandChampion1 && pGrandChampion2 && pGrandChampion3)
             {
-                AggroAllPlayers(pGrandChampion1);
-                AggroAllPlayers(pGrandChampion2);
-                AggroAllPlayers(pGrandChampion3);
+                EnterAggressiveMode(pGrandChampion1, true);
+                EnterAggressiveMode(pGrandChampion2, true);
+                EnterAggressiveMode(pGrandChampion3, true);
             }
         }
 
@@ -180,88 +444,98 @@ class npc_announcer_toc5 : public CreatureScript
             if (uiType != POINT_MOTION_TYPE)
                 return;
 
-            if (uiPointId == 1)
-                me->SetFacingTo(ORIENTATION);
+            switch (uiPointId)
+            {
+                case POINT_ENCOUNTER_1_WAIT:
+                    NextStep(500, 0, false, EVENT_WAIT_1);
+                    break;
+                case POINT_RETURN_TO_CENTER:
+                    me->SetFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP);
+                    break;
+                case POINT_START_ARGENT_CHAMP:
+                    me->SetFacingTo(me->GetHomePosition().GetOrientation());
+                    NextStep(500, 0, false, EVENT_SPAWN_ALL);
+                    break;
+                case POINT_ENCOUNTER_2_WAIT_1:
+                    NextStep(500, 0, false, EVENT_WAIT_2);
+                    break;
+                case POINT_ENCOUNTER_2_WAIT_2:
+                    me->SetFacingTo(centerOrientation);
+                    NextStep(1000, 0, false, EVENT_CHAT_12);
+                    break;
+                case POINT_ENCOUNTER_3_WAIT:
+                    me->SetFacingTo(centerOrientation);
+                    NextStep(1000, 0, false, EVENT_CHAT_13);
+                    break;
+                default:
+                    break;
+            }
         }
 
-        void DoSummonGrandChampion(uint32 uiBoss)
+        void DoSummonNextGrandChampion(bool skipEvent = false)
         {
             ++uiSummonTimes;
-            uint32 VEHICLE_TO_SUMMON1 = 0;
-            uint32 VEHICLE_TO_SUMMON2 = 0;
-            switch (uiBoss)
+            uint32 bossId;
+            switch (uiSummonTimes)
             {
-                case 0:
-                    VEHICLE_TO_SUMMON1 = VEHICLE_MOKRA_SKILLCRUSHER_MOUNT;
-                    VEHICLE_TO_SUMMON2 = VEHICLE_ORGRIMMAR_WOLF;
-                    break;
                 case 1:
-                    VEHICLE_TO_SUMMON1 = VEHICLE_ERESSEA_DAWNSINGER_MOUNT;
-                    VEHICLE_TO_SUMMON2 = VEHICLE_SILVERMOON_HAWKSTRIDER;
+                    bossId = uiFirstBoss;
                     break;
                 case 2:
-                    VEHICLE_TO_SUMMON1 = VEHICLE_RUNOK_WILDMANE_MOUNT;
-                    VEHICLE_TO_SUMMON2 = VEHICLE_THUNDER_BLUFF_KODO;
+                    bossId = uiSecondBoss;
                     break;
                 case 3:
-                    VEHICLE_TO_SUMMON1 = VEHICLE_ZUL_TORE_MOUNT;
-                    VEHICLE_TO_SUMMON2 = VEHICLE_DARKSPEAR_RAPTOR;
-                    break;
-                case 4:
-                    VEHICLE_TO_SUMMON1 = VEHICLE_DEATHSTALKER_VESCERI_MOUNT;
-                    VEHICLE_TO_SUMMON2 = VEHICLE_FORSAKE_WARHORSE;
+                    bossId = uiThirdBoss;
                     break;
                 default:
                     return;
             }
 
-            if (Creature* pBoss = me->SummonCreature(VEHICLE_TO_SUMMON1, SpawnPosition))
+            if (bossId >= 5)
+                return;
+
+            GrandChampionInfo const* info = &GrandChampionData[bossId];
+            uint32 TeamInInstance = instance->GetData(DATA_TEAM_IN_INSTANCE);
+            uint32 teamIndex = TeamInInstance == HORDE ? 1 : 0;
+
+            // Calculating spawn position for grand champion if event is skipped
+            int x = uiSummonTimes - 1;
+            if (TeamInInstance == HORDE)
+                x += 3;
+
+            // Grand Champions
+            Position const spawnPos = skipEvent ? GrandChampFinalLoc[x] : SpawnPosition;
+            if (Creature* pBoss = me->SummonCreature(info->GrandChampionEntry[teamIndex], spawnPos))
             {
-                switch (uiSummonTimes)
+                instance->SetGuidData(DATA_GRAND_CHAMPION_VEHICLE_1 + uiSummonTimes - 1, pBoss->GetGUID());
+
+                if (!skipEvent)
+                    pBoss->AI()->SetData(uiSummonTimes, TeamInInstance);
+                else
                 {
-                    case 1:
+                    if (TeamInInstance == ALLIANCE)
+                        pBoss->SetFacingTo(hordeOrientation);
+                    else
+                        pBoss->SetFacingTo(allianceOrientation);
+                    pBoss->SetHomePosition(pBoss->GetPositionX(), pBoss->GetPositionY(), pBoss->GetPositionZ(), TeamInInstance == ALLIANCE ? hordeOrientation : allianceOrientation);
+
+                    // Specatators cheer for champions even if event is skipped
+                    if (Creature* spectator = me->FindNearestCreature(info->SpecatatorEntry[teamIndex], 200.0f))
                     {
-                        uiVehicle1GUID = pBoss->GetGUID();
-                        ObjectGuid uiGrandChampionBoss1;
-                        if (Vehicle* pVehicle = pBoss->GetVehicleKit())
-                            if (Unit* unit = pVehicle->GetPassenger(0))
-                                uiGrandChampionBoss1 = unit->GetGUID();
-                        instance->SetGuidData(DATA_GRAND_CHAMPION_VEHICLE_1, uiVehicle1GUID);
-                        instance->SetGuidData(DATA_GRAND_CHAMPION_1, uiGrandChampionBoss1);
-                        pBoss->AI()->SetData(1, 0);
-                        break;
+                        if (Creature* rider = me->FindNearestCreature(info->GrandChampionRealEntry[teamIndex], 200.0f))
+                            spectator->AI()->Talk(EMOTE_SPECTATOR_CHEER, rider);
                     }
-                    case 2:
-                    {
-                        uiVehicle2GUID = pBoss->GetGUID();
-                        ObjectGuid uiGrandChampionBoss2;
-                        if (Vehicle* pVehicle = pBoss->GetVehicleKit())
-                            if (Unit* unit = pVehicle->GetPassenger(0))
-                                uiGrandChampionBoss2 = unit->GetGUID();
-                        instance->SetGuidData(DATA_GRAND_CHAMPION_VEHICLE_2, uiVehicle2GUID);
-                        instance->SetGuidData(DATA_GRAND_CHAMPION_2, uiGrandChampionBoss2);
-                        pBoss->AI()->SetData(2, 0);
-                        break;
-                    }
-                    case 3:
-                    {
-                        uiVehicle3GUID = pBoss->GetGUID();
-                        ObjectGuid uiGrandChampionBoss3;
-                        if (Vehicle* pVehicle = pBoss->GetVehicleKit())
-                            if (Unit* unit = pVehicle->GetPassenger(0))
-                                uiGrandChampionBoss3 = unit->GetGUID();
-                        instance->SetGuidData(DATA_GRAND_CHAMPION_VEHICLE_3, uiVehicle3GUID);
-                        instance->SetGuidData(DATA_GRAND_CHAMPION_3, uiGrandChampionBoss3);
-                        pBoss->AI()->SetData(3, 0);
-                        break;
-                    }
-                    default:
-                        return;
                 }
 
+                // Lesser Champions
                 for (uint8 i = 0; i < 3; ++i)
                 {
-                    if (Creature* pAdd = me->SummonCreature(VEHICLE_TO_SUMMON2, SpawnPosition, TEMPSUMMON_CORPSE_DESPAWN))
+                    // Calculating waiting positions for lesser champions if event is skipped
+                    int m = (uiSummonTimes - 1) * 3 + i;
+                    if (TeamInInstance == HORDE)
+                        m += 9;
+
+                    if (Creature* pAdd = me->SummonCreature(info->FactionChampionEntry[teamIndex], spawnPos, TEMPSUMMON_DEAD_DESPAWN))
                     {
                         switch (uiSummonTimes)
                         {
@@ -274,177 +548,708 @@ class npc_announcer_toc5 : public CreatureScript
                             case 3:
                                 Champion3List.push_back(pAdd->GetGUID());
                                 break;
+                            default:
+                                break;
                         }
 
-                        switch (i)
+                        if (!skipEvent)
                         {
-                            case 0:
-                                pAdd->GetMotionMaster()->MoveFollow(pBoss, 2.0f, float(M_PI));
-                                break;
-                            case 1:
-                                pAdd->GetMotionMaster()->MoveFollow(pBoss, 2.0f, float(M_PI) / 2);
-                                break;
-                            case 2:
-                                pAdd->GetMotionMaster()->MoveFollow(pBoss, 2.0f, float(M_PI) / 2 + float(M_PI));
-                                break;
+                            // Following grand champion
+                            switch (i)
+                            {
+                                case 0:
+                                    pAdd->GetMotionMaster()->MoveFollow(pBoss, 2.0f, float(M_PI));
+                                    break;
+                                case 1:
+                                    pAdd->GetMotionMaster()->MoveFollow(pBoss, 2.0f, float(M_PI) / 2);
+                                    break;
+                                case 2:
+                                    pAdd->GetMotionMaster()->MoveFollow(pBoss, 2.0f, float(M_PI) / 2 + float(M_PI));
+                                    break;
+                                default:
+                                    break;
+                            }
                         }
+                        else
+                            // Lesser Champions walk to their final positions
+                            pAdd->AI()->SetData(DATA_GENERATE_WAYPOINTS_FOR_ADDS, m);
                     }
-
                 }
             }
         }
 
         void DoStartArgentChampionEncounter()
         {
-            me->GetMotionMaster()->MovePoint(1, 735.81f, 661.92f, 412.39f);
+            // Removing vehicles (if not already been removed)
+            instance->SetData(DATA_REMOVE_VEHICLES, 0);
+            // Cleaning chest from arena
+            if (GameObject* cache = instance->GetGameObject(DATA_CHAMPION_S_CACHE))
+                cache->Delete();
+            NextStep(1000, 0, false, EVENT_MOVE_MIDDLE);
+        }
 
-            if (me->SummonCreature(uiArgentChampion, SpawnPosition))
+        void DoStartBlackKnight()
+        {
+            // Removing vehicles (if not already been removed)
+            instance->SetData(DATA_REMOVE_VEHICLES, 0);
+            // Cleaning chest from arena
+            if (instance->GetBossState(DATA_EADRIC_THE_PURE) == DONE)
             {
-                for (uint8 i = 0; i < 3; ++i)
-                {
-                    if (Creature* pTrash = me->SummonCreature(NPC_ARGENT_LIGHWIELDER, SpawnPosition))
-                        pTrash->AI()->SetData(i, 0);
-                    if (Creature* pTrash = me->SummonCreature(NPC_ARGENT_MONK, SpawnPosition))
-                        pTrash->AI()->SetData(i, 0);
-                    if (Creature* pTrash = me->SummonCreature(NPC_PRIESTESS, SpawnPosition))
-                        pTrash->AI()->SetData(i, 0);
-                }
+                if (GameObject* cache = instance->GetGameObject(DATA_EADRIC_S_CACHE))
+                    cache->Delete();
+            }
+            else if (instance->GetBossState(DATA_ARGENT_CONFESSOR_PALETRESS) == DONE)
+            {
+                if (GameObject* cache = instance->GetGameObject(DATA_CONFESSOR_S_CACHE))
+                    cache->Delete();
             }
+            NextStep(1000, 0, false, EVENT_STEP_FORWARD);
         }
 
         void SetGrandChampionsForEncounter()
         {
-            uiFirstBoss = urand(0, 4);
-
+            uiFirstBoss = urand(BOSS_WARRIOR, BOSS_ROGUE);
             while (uiSecondBoss == uiFirstBoss || uiThirdBoss == uiFirstBoss || uiThirdBoss == uiSecondBoss)
             {
-                uiSecondBoss = urand(0, 4);
-                uiThirdBoss = urand(0, 4);
+                uiSecondBoss = urand(BOSS_WARRIOR, BOSS_ROGUE);
+                uiThirdBoss = urand(BOSS_WARRIOR, BOSS_ROGUE);
             }
         }
 
         void SetArgentChampion()
         {
-           uint8 uiTempBoss = urand(0, 1);
-
-           switch (uiTempBoss)
+           switch (RAND(BOSS_EADRIC, BOSS_PALETRESS))
            {
-                case 0:
+                case BOSS_EADRIC:
                     uiArgentChampion = NPC_EADRIC;
                     break;
-                case 1:
+                case BOSS_PALETRESS:
                     uiArgentChampion = NPC_PALETRESS;
                     break;
+                default:
+                    break;
            }
         }
 
-        void StartEncounter()
+        void StartEncounter(bool startRp = false)
         {
             me->RemoveFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP);
-
-            if (instance->GetData(BOSS_BLACK_KNIGHT) == NOT_STARTED)
+            /// @todo: fix this ugly code
+            if (instance->GetBossState(DATA_THE_BLACK_KNIGHT) == NOT_STARTED || instance->GetBossState(DATA_THE_BLACK_KNIGHT) == TO_BE_DECIDED)
             {
-                if (instance->GetData(BOSS_ARGENT_CHALLENGE_E) == NOT_STARTED && instance->GetData(BOSS_ARGENT_CHALLENGE_P) == NOT_STARTED)
+                if ((instance->GetBossState(DATA_EADRIC_THE_PURE) == NOT_STARTED || instance->GetBossState(DATA_EADRIC_THE_PURE) == TO_BE_DECIDED)
+                    && (instance->GetBossState(DATA_ARGENT_CONFESSOR_PALETRESS) == NOT_STARTED || instance->GetBossState(DATA_ARGENT_CONFESSOR_PALETRESS) == TO_BE_DECIDED))
                 {
-                    if (instance->GetData(BOSS_GRAND_CHAMPIONS) == NOT_STARTED)
+                    // Starting Grand Champion event (with roleplaying)
+                    if (startRp && (instance->GetBossState(DATA_GRAND_CHAMPIONS) == NOT_STARTED || instance->GetBossState(DATA_GRAND_CHAMPIONS) == TO_BE_DECIDED))
+                    {
+                        Talk(SAY_INTRO_1);
+                        NextStep(7000, 0, false, EVENT_INTRODUCE);
+                    }
+
+                    // Starting Grand Champion event (skipped roleplaying)
+                    if (!startRp && (instance->GetBossState(DATA_GRAND_CHAMPIONS) == NOT_STARTED || instance->GetBossState(DATA_GRAND_CHAMPIONS) == TO_BE_DECIDED))
                         SetData(DATA_START, 0);
 
-                    if (instance->GetData(BOSS_GRAND_CHAMPIONS) == DONE)
+                    // Starting Argent Champion event
+                    if (instance->GetBossState(DATA_GRAND_CHAMPIONS) == DONE)
                         DoStartArgentChampionEncounter();
                 }
 
-               if ((instance->GetData(BOSS_GRAND_CHAMPIONS) == DONE &&
-                   instance->GetData(BOSS_ARGENT_CHALLENGE_E) == DONE) ||
-                   instance->GetData(BOSS_ARGENT_CHALLENGE_P) == DONE)
-                    me->SummonCreature(VEHICLE_BLACK_KNIGHT, 769.834f, 651.915f, 447.035f, 0);
+                // Starting Black Knight event
+                if (((instance->GetBossState(DATA_GRAND_CHAMPIONS) == DONE) &&
+                    ((instance->GetBossState(DATA_EADRIC_THE_PURE) == DONE) ||
+                    (instance->GetBossState(DATA_ARGENT_CONFESSOR_PALETRESS) == DONE))))
+                    DoStartBlackKnight();
             }
         }
 
-        void AggroAllPlayers(Creature* temp)
+        void IntroduceChampion()
         {
-            Map::PlayerList const &PlList = me->GetMap()->GetPlayers();
+            uint32 bossId;
+            switch (uiSummonTimes)
+            {
+                case 1:
+                    bossId = uiFirstBoss;
+                    break;
+                case 2:
+                    bossId = uiSecondBoss;
+                    break;
+                case 3:
+                    bossId = uiThirdBoss;
+                    break;
+                default:
+                    return;
+            }
 
-            if (PlList.isEmpty())
+            if (bossId >= 5)
                 return;
 
-            for (Map::PlayerList::const_iterator i = PlList.begin(); i != PlList.end(); ++i)
+            GrandChampionInfo const* info = &GrandChampionData[bossId];
+            uint32 teamIndex = instance->GetData(DATA_TEAM_IN_INSTANCE) == HORDE ? 1 : 0;
+
+            // Introduces champion
+            Talk(info->AnnounceText[teamIndex]);
+            // Spectators cheer for the champion
+            if (Creature* spectator = me->FindNearestCreature(info->SpecatatorEntry[teamIndex], 200.0f))
             {
-                if (Player* player = i->GetSource())
-                {
-                    if (player->IsGameMaster())
-                        continue;
+                if (Creature* boss = ObjectAccessor::GetCreature(*me, instance->GetGuidData(DATA_GRAND_CHAMPION_1 + uiSummonTimes - 1)))
+                    spectator->AI()->Talk(EMOTE_SPECTATOR_CHEER, boss);
+            }
+        }
 
-                    if (player->IsAlive())
+        void EnterAggressiveMode(Creature* temp, bool riderAlso = false)
+        {
+            temp->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_IMMUNE_TO_PC);
+            temp->SetReactState(REACT_AGGRESSIVE);
+            temp->SetWalk(false);
+            Map::PlayerList const& players = me->GetMap()->GetPlayers();
+            for (Map::PlayerList::const_iterator itr = players.begin(); itr != players.end(); ++itr)
+            {
+                Player* player = itr->GetSource();
+                if (player && !player->IsGameMaster() && player->IsAlive())
+                {
+                    if (player->GetVehicleBase())
                     {
-                        temp->SetHomePosition(me->GetPositionX(), me->GetPositionY(), me->GetPositionZ(), me->GetOrientation());
-                        temp->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
-                        temp->SetReactState(REACT_AGGRESSIVE);
-                        temp->SetInCombatWith(player);
-                        player->SetInCombatWith(temp);
-                        temp->AddThreat(player, 0.0f);
+                        temp->AddThreat(player->GetVehicleBase(), 1.0f);
+                        temp->AI()->AttackStart(player->GetVehicleBase());
                     }
+                    else
+                    {
+                        temp->AddThreat(player, 1.0f);
+                        temp->AI()->AttackStart(player);
+                    }
+                    break;
                 }
             }
+            if (riderAlso)
+            {
+                if (temp->GetVehicleKit() && temp->GetVehicleKit()->GetPassenger(SEAT_ID_0))
+                {
+                    if (Creature* rider = temp->GetVehicleKit()->GetPassenger(SEAT_ID_0)->ToCreature())
+                    {
+                        rider->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_IMMUNE_TO_PC);
+                        rider->SetWalk(false);
+                        rider->SetReactState(REACT_AGGRESSIVE);
+                    }
+                }
+            }
+        }
+
+        void AttackStart(Unit* who) override
+        {
+            ScriptedAI::AttackStart(who);
+            if (me->HasUnitState(UNIT_STATE_MELEE_ATTACKING))
+            {
+                me->ClearUnitState(UNIT_STATE_MELEE_ATTACKING);
+                me->SendMeleeAttackStop(who);
+            }
         }
 
        void UpdateAI(uint32 uiDiff) override
         {
             ScriptedAI::UpdateAI(uiDiff);
+            events.Update(uiDiff);
 
-            if (uiTimer <= uiDiff)
+            while (uint32 eventId = events.ExecuteEvent())
             {
-                switch (uiPhase)
+                switch (eventId)
                 {
-                    case 1:
-                        DoSummonGrandChampion(uiSecondBoss);
-                        NextStep(10000, true);
+                    case EVENT_CHEER_RND:
+                        if (events.GetNextEventTime() == 0 && !me->HasFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP) && !me->isMoving() && !me->HasAura(66804))
+                        {
+                            // Every 2 minutes a random player is being cheered by his/her race's spectators
+                            // cheer should only occur during fights
+                            Map::PlayerList const &pList = me->GetMap()->GetPlayers();
+                            // Player list is always in the same order so we must "randomize" it
+                            if (!pList.isEmpty())
+                            {
+                                uint32 rand = urand(0, pList.getSize() - 1);
+                                for (Map::PlayerList::const_iterator itr = pList.begin(); itr != pList.end(); ++itr)
+                                {
+                                    if (rand == 0)
+                                    {
+                                        Player* plr = itr->GetSource();
+                                        if (plr && !plr->IsGameMaster() && plr->IsAlive())
+                                        {
+                                            // 50% chance for race cheering at you or faction cheering at you
+                                            uint32 spectatorEntry = RAND(SpectatorData[plr->getRace()], uint32(instance->GetData(DATA_TEAM_IN_INSTANCE) == ALLIANCE ? NPC_SPECTATOR_ALLIANCE : NPC_SPECTATOR_HORDE));
+
+                                            if (Creature* spectator = me->FindNearestCreature(spectatorEntry, 200.0f))
+                                                spectator->AI()->Talk(EMOTE_SPECTATOR_CHEER, plr);
+                                            break;
+                                        }
+                                        else
+                                            continue;
+                                    }
+                                    else
+                                        --rand;
+                                }
+                            }
+                        }
+                        events.ScheduleEvent(EVENT_CHEER_RND, 120000);
+                        break;
+                    // Phases below happen in Grand Champions encounter
+                    case EVENT_INTRODUCE:
+                    {
+                        // Introducing players to spectators
+                        bool foundPlr = false;
+                        Map::PlayerList const& players = me->GetMap()->GetPlayers();
+                        for (Map::PlayerList::const_iterator itr = players.begin(); itr != players.end(); ++itr)
+                        {
+                            Player* player = itr->GetSource();
+
+                            if (player->IsGameMaster() || !player->IsAlive())
+                                continue;
+
+                            GuidList::iterator i = std::find(PlayerEventList.begin(), PlayerEventList.end(), player->GetGUID());
+                            if (i != PlayerEventList.end())
+                                continue;
+
+                            // player has not been yet introduced
+                            uint32 x = PlayerEventList.size();
+                            if (IntroducePlrTxt[x])
+                                Talk(IntroducePlrTxt[x], player);
+                            else
+                                continue; // no text found, too many players?
+
+                            if (Creature* spectator = me->FindNearestCreature(SpectatorData[player->getRace()], 200.0f))
+                                spectator->AI()->Talk(EMOTE_SPECTATOR_CHEER, player);
+
+                            foundPlr = true;
+                            PlayerEventList.push_back(player->GetGUID());
+                            NextStep(7000, 0, false, EVENT_INTRODUCE);
+                            break;
+                        }
+                        // All players introduced, moving on
+                        if (!foundPlr)
+                            NextStep(16000, eventId);
+                        break;
+                    }
+                    case EVENT_CHAT_1:
+                        if (Creature* tirion = instance->GetCreature(DATA_TIRION))
+                            tirion->AI()->Talk(SAY_TIRION_INTRO_1);
+                        NextStep(8000, eventId);
+                        break;
+                    case EVENT_CHAT_2:
+                        // Tirion gets interrupted by Varian Wrynn or Garrosh Hellscream
+                        if (instance->GetData(DATA_TEAM_IN_INSTANCE) == ALLIANCE)
+                        {
+                            if (Creature* varian = instance->GetCreature(DATA_VARIAN))
+                                varian->AI()->Talk(SAY_VARIAN_INTRO_1);
+                        }
+                        else
+                        {
+                            if (Creature* garrosh = instance->GetCreature(DATA_GARROSH))
+                                garrosh->AI()->Talk(SAY_GARROSH_INTRO_1);
+                        }
+                        NextStep(6000, eventId);
+                        break;
+                    case EVENT_CHAT_3:
+                        if (instance->GetData(DATA_TEAM_IN_INSTANCE) == ALLIANCE)
+                        {
+                            if (Creature* jaina = instance->GetCreature(DATA_JAINA))
+                                jaina->AI()->Talk(SAY_JAINA_INTRO_1);
+                        }
+                        else
+                        {
+                            if (Creature* thrall = instance->GetCreature(DATA_THRALL))
+                                thrall->AI()->Talk(SAY_THRALL_INTRO_1);
+                        }
+                        NextStep(5000, eventId);
+                        break;
+                    case EVENT_CHAT_4:
+                        if (instance->GetData(DATA_TEAM_IN_INSTANCE) == ALLIANCE)
+                        {
+                            if (Creature* garrosh = instance->GetCreature(DATA_GARROSH))
+                                garrosh->AI()->Talk(SAY_GARROSH_INTRO_2);
+                        }
+                        else
+                        {
+                            if (Creature* varian = instance->GetCreature(DATA_VARIAN))
+                                varian->AI()->Talk(SAY_VARIAN_INTRO_2);
+                        }
+                        NextStep(8000, eventId);
+                        break;
+                    case EVENT_CHAT_5:
+                        if (instance->GetData(DATA_TEAM_IN_INSTANCE) == ALLIANCE)
+                        {
+                            if (Creature* thrall = instance->GetCreature(DATA_THRALL))
+                                thrall->AI()->Talk(SAY_THRALL_INTRO_2);
+                        }
+                        else
+                        {
+                            if (Creature* jaina = instance->GetCreature(DATA_JAINA))
+                                jaina->AI()->Talk(SAY_JAINA_INTRO_2);
+                        }
+                        NextStep(5000, eventId);
+                        break;
+                    case EVENT_CHAT_6:
+                        if (Creature* tirion = instance->GetCreature(DATA_TIRION))
+                            tirion->AI()->Talk(SAY_TIRION_INTRO_2);
+                        NextStep(6000, eventId);
+                        break;
+                    case EVENT_SUMMON_1:
+                        // Summoning first champion
+                        DoSummonNextGrandChampion();
+                        me->SetFacingTo(gateOrientation);
+                        NextStep(2000, eventId);
+                        break;
+                    case EVENT_OPEN_DOOR_1:
+                        // Opening doors
+                        instance->HandleGameObject(instance->GetGuidData(DATA_MAIN_GATE), true);
+                        NextStep(500, eventId);
+                        break;
+                    case EVENT_INTRODUCE_BOSS_1:
+                        // Introducing first champion
+                        IntroduceChampion();
+                        NextStep(7500, eventId);
+                        break;
+                    case EVENT_CLOSE_DOOR_1:
+                        // Closing door
+                        instance->HandleGameObject(instance->GetGuidData(DATA_MAIN_GATE), false);
+                        NextStep(8000, eventId);
+                        break;
+                    case EVENT_SUMMON_2:
+                        // Summoning second champion
+                        DoSummonNextGrandChampion();
+                        NextStep(2000, eventId);
+                        break;
+                    case EVENT_OPEN_DOOR_2:
+                        // Opening doors
+                        instance->HandleGameObject(instance->GetGuidData(DATA_MAIN_GATE), true);
+                        NextStep(500, eventId);
+                        break;
+                    case EVENT_INTRODUCE_BOSS_2:
+                        // Introducing second champion
+                        IntroduceChampion();
+                        NextStep(7500, eventId);
+                        break;
+                    case EVENT_CLOSE_DOOR_2:
+                        // Closing door
+                        instance->HandleGameObject(instance->GetGuidData(DATA_MAIN_GATE), false);
+                        NextStep(8000, eventId);
+                        break;
+                    case EVENT_SUMMON_3:
+                        // Summoning third and final champion
+                        DoSummonNextGrandChampion();
+                        NextStep(2000, eventId);
+                        break;
+                    case EVENT_OPEN_DOOR_3:
+                        // Opening doors
+                        instance->HandleGameObject(instance->GetGuidData(DATA_MAIN_GATE), true);
+                        NextStep(500, eventId);
                         break;
-                    case 2:
-                        DoSummonGrandChampion(uiThirdBoss);
-                        NextStep(0, false);
+                    case EVENT_INTRODUCE_BOSS_3:
+                        // Introducing third champion
+                        IntroduceChampion();
+                        NextStep(9500, eventId);
                         break;
-                    case 3:
-                        if (!Champion1List.empty())
+                    case EVENT_CLOSE_DOOR_3:
+                        // Closing door and announcer walks to the gate
+                        instance->HandleGameObject(instance->GetGuidData(DATA_MAIN_GATE), false);
+                        me->GetMotionMaster()->MovePoint(POINT_ENCOUNTER_1_WAIT, announcerEncounterPos);
+                        NextStep(0, 0, false); // MovementInform continues from this
+                        break;
+                    case EVENT_WAIT_1:
+                        // Lesser champions are moving to their respective positions
+                        NextStep(500, eventId);
+                        break;
+                    case EVENT_FACING:
+                        // Correcting facing
+                        me->SetFacingTo(centerOrientation);
+                        NextStep(5000, eventId);
+                        break;
+                    case EVENT_CHAT_7:
+                        if (Creature* tirion = instance->GetCreature(DATA_TIRION))
+                            tirion->AI()->Talk(SAY_TIRION_INTRO_3);
+                        NextStep(2000, eventId);
+                        break;
+                    case EVENT_AGGRO_1:
+                        // First wave of lesser champions aggroes
+                        for (GuidList::const_iterator itr = Champion1List.begin(); itr != Champion1List.end(); ++itr)
+                        {
+                            if (Creature* summon = ObjectAccessor::GetCreature(*me, *itr))
+                                EnterAggressiveMode(summon);
+                        }
+                        NextStep(0, 0, false);
+                        break;
+                    case EVENT_CHAT_8:
+                        // Tirion congratulates players
+                        if (Creature* tirion = instance->GetCreature(DATA_TIRION))
+                            tirion->AI()->Talk(SAY_TIRION_OUTRO_1);
+                        NextStep(0, 0, false);
+                        break;
+                    // Phases below happen only if roleplaying event is skipped
+                    case EVENT_CHAT_9:
+                        if (Creature* tirion = instance->GetCreature(DATA_TIRION))
+                            tirion->AI()->Talk(SAY_TIRION_INTRO_2);
+                        NextStep(3000, eventId);
+                        break;
+                    case EVENT_SUMMON_1_SKIP:
+                        // Summoning first champion
+                        DoSummonNextGrandChampion(true);
+                        NextStep(2000, eventId);
+                        break;
+                    case EVENT_SUMMON_2_SKIP:
+                        // Summoning second champion
+                        DoSummonNextGrandChampion(true);
+                        NextStep(2000, eventId);
+                        break;
+                    case EVENT_SUMMON_3_SKIP:
+                        // Summoning third champion
+                        DoSummonNextGrandChampion(true);
+                        NextStep(0, 0, false); // MovementInform continues from this
+                        break;
+                    // Phases below happen in Argent Champion encounter
+                    case EVENT_MOVE_MIDDLE:
+                        // Moves into middle of arena
+                        me->GetMotionMaster()->MovePoint(POINT_START_ARGENT_CHAMP, me->GetHomePosition());
+                        NextStep(0, 0, false); // MovementInform continues from this
+                        break;
+                    case EVENT_SPAWN_ALL:
+                        // Spawns 9 adds and boss
+                        // Generating final positions for monks and other 2 adds follow the monk
+                        // when monk is in final position, then final positions are generated for other adds
+                        if (me->SummonCreature(uiArgentChampion, SpawnPosition))
+                        {
+                            for (uint8 i = 0; i < 3; ++i)
+                            {
+                                if (Creature* pMonk = me->SummonCreature(NPC_ARGENT_MONK, SpawnPosition))
+                                {
+                                    pMonk->AI()->SetData(i, 0);
+                                    if (Creature* pLightwielder = me->SummonCreature(NPC_ARGENT_LIGHWIELDER, SpawnPosition))
+                                    {
+                                        pLightwielder->AI()->SetData(i, 0);
+                                        pLightwielder->GetMotionMaster()->MoveFollow(pMonk, 2.0f, float(M_PI));
+                                    }
+                                    if (Creature* pPriestess = me->SummonCreature(NPC_PRIESTESS, SpawnPosition))
+                                    {
+                                        pPriestess->AI()->SetData(i, 0);
+                                        pPriestess->GetMotionMaster()->MoveFollow(pMonk, 2.0f, float(M_PI) / 2);
+                                    }
+                                }
+                            }
+                        }
+                        NextStep(2000, eventId);
+                        break;
+                    case EVENT_OPEN_DOOR_4:
+                        // Opening doors
+                        instance->HandleGameObject(instance->GetGuidData(DATA_MAIN_GATE), true);
+                        NextStep(2000, eventId);
+                        break;
+                    case EVENT_INTRODUCE_BOSS_4:
+                        // Introducing Argent Champion to spectators
+                        // Horde and alliance spectators cheer for Argent Champion
+                        if (Creature* pBoss = ObjectAccessor::GetCreature(*me, instance->GetGuidData(DATA_ARGENT_CHAMPION)))
                         {
-                            for (GuidList::const_iterator itr = Champion1List.begin(); itr != Champion1List.end(); ++itr)
-                                if (Creature* summon = ObjectAccessor::GetCreature(*me, *itr))
-                                    AggroAllPlayers(summon);
-                            NextStep(0, false);
+                            if (pBoss->GetEntry() == NPC_EADRIC)
+                                Talk(SAY_INTRO_2_E, pBoss);
+                            else
+                                Talk(SAY_INTRO_2_P, pBoss);
+                            if (Creature* aSpectator = me->FindNearestCreature(NPC_SPECTATOR_ALLIANCE, 200.0f))
+                                aSpectator->AI()->Talk(EMOTE_SPECTATOR_CHEER, pBoss);
+                            if (Creature* hSpectator = me->FindNearestCreature(NPC_SPECTATOR_HORDE, 200.0f))
+                                hSpectator->AI()->Talk(EMOTE_SPECTATOR_CHEER, pBoss);
                         }
+                        NextStep(10000, eventId);
+                        break;
+                    case EVENT_ARGENT_BOSS_WALK:
+                        // Argent Champion starts walking to arena
+                        if (Creature* pBoss = ObjectAccessor::GetCreature(*me, instance->GetGuidData(DATA_ARGENT_CHAMPION)))
+                        {
+                            pBoss->SetWalk(true);
+                            pBoss->GetMotionMaster()->MovePoint(0, 746.71f, 661.4f, 411.7f);
+                        }
+                        NextStep(0, 0, false);
+                        break;
+                    case EVENT_GO_TO_ARGENT_BOSS:
+                        // Announcer starts walking to Argent Champion
+                        instance->HandleGameObject(instance->GetGuidData(DATA_MAIN_GATE), false);
+                        me->GetMotionMaster()->MovePoint(POINT_ENCOUNTER_2_WAIT_1, 746.73f, 653.93f, 411.6f);
+                        NextStep(2000, eventId);
+                        break;
+                    case EVENT_CHAT_10:
+                        // Argent Champion talks
+                        if (Creature* pBoss = ObjectAccessor::GetCreature(*me, instance->GetGuidData(DATA_ARGENT_CHAMPION)))
+                        {
+                            if (pBoss->GetEntry() == NPC_EADRIC)
+                            {
+                                pBoss->AI()->Talk(SAY_EADRIC_INTRO_1, me);
+                                NextStep(0, 0, false);
+                            }
+                            else
+                            {
+                                pBoss->AI()->Talk(SAY_PALETRESS_INTRO_1, me);
+                                NextStep(6000, eventId);
+                            }
+                        }
+                        break;
+                    case EVENT_CHAT_11:
+                        // Paletress talks twice
+                        if (Creature* pBoss = ObjectAccessor::GetCreature(*me, instance->GetGuidData(DATA_ARGENT_CHAMPION)))
+                        {
+                            if (pBoss->GetEntry() == NPC_PALETRESS)
+                                pBoss->AI()->Talk(SAY_PALETRESS_INTRO_2, me);
+                            NextStep(0, 0, false);
+                        }
+                        break;
+                    case EVENT_WAIT_2:
+                        // After announcer reached position in front of Champion,
+                        // he goes to encounter position
+                        me->GetMotionMaster()->MovePoint(POINT_ENCOUNTER_2_WAIT_2, announcerEncounterPos);
+                        NextStep(0, 0, false);
+                        break;
+                    case EVENT_CHAT_12:
+                        if (Creature* tirion = instance->GetCreature(DATA_TIRION))
+                            tirion->AI()->Talk(SAY_TIRION_INTRO_4);
+                        NextStep(0, 0, false);
+                        break;
+                    // Phases below happen in The Black Knight encounter
+                    case EVENT_STEP_FORWARD:
+                        // Stepping forward
+                        me->GetMotionMaster()->MovePoint(POINT_ENCOUNTER_3_WAIT, 743.65f, 627.6f, 411.17f);
+                        NextStep(0, 0, false);
+                        break;
+                    case EVENT_CHAT_13:
+                        // Tirion congratulates champions and meanwhile Black Knight appears
+                        if (Creature* tirion = instance->GetCreature(DATA_TIRION))
+                            tirion->AI()->Talk(SAY_TIRION_INTRO_5);
+                        me->SummonCreature(VEHICLE_BLACK_KNIGHT, 780.69f, 669.61f, 463.66f, 3.77f);
+                        NextStep(6000, eventId);
+                        break;
+                    case EVENT_FACING_1:
+                        // Announcer turns towards Black Knight
+                        if (Creature* knight = instance->GetCreature(DATA_THE_BLACK_KNIGHT))
+                            me->SetFacingToObject(knight);
+                        NextStep(2000, eventId);
+                        break;
+                    case EVENT_CHAT_14:
+                        // Announcer notifies everyone that something is near the rafters
+                        if (Creature* knight = instance->GetCreature(DATA_THE_BLACK_KNIGHT))
+                            Talk(SAY_INTRO_3, knight);
+                        NextStep(1000, eventId);
+                        break;
+                    case EVENT_START_PATH:
+                        // Black Knight starts to fly down
+                        if (Creature* knightVehicle = ObjectAccessor::GetCreature(*me, instance->GetGuidData(DATA_BLACK_KNIGHT_VEHICLE)))
+                        {
+                            knightVehicle->AI()->SetData(1, 0);
+                            // We start attacking Black Knight without combat movement
+                            // so we keep facing him all the time
+                            if (knightVehicle->GetVehicleKit() && knightVehicle->GetVehicleKit()->GetPassenger(SEAT_ID_0))
+                                AttackStart(knightVehicle->GetVehicleKit()->GetPassenger(SEAT_ID_0));
+                        }
+                        NextStep(0, 0, false);
+                        break;
+                    case EVENT_CHAT_15:
+                        // Black Knight exits his vehicle and talks
+                        if (Creature* knight = instance->GetCreature(DATA_THE_BLACK_KNIGHT))
+                        {
+                            knight->AI()->Talk(SAY_KNIGHT_INTRO_1, me);
+                            knight->ExitVehicle();
+                            knight->SetWalk(true);
+                            knight->GetMotionMaster()->MovePoint(0, 747.79f, 632.49f, 411.41f);
+                        }
+                        NextStep(0, 0, false);
+                        break;
+                    case EVENT_FACING_2:
+                        // Black Knight corrects facing and we're stopping attacking
+                        if (Creature* knight = instance->GetCreature(DATA_THE_BLACK_KNIGHT))
+                            knight->SetFacingToObject(me);
+                        me->AttackStop();
+                        me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                        NextStep(1500, eventId);
+                        break;
+                    case EVENT_STUN_ANNOUNCER:
+                        // Announcer gets strangulated
+                        if (Creature* knight = instance->GetCreature(DATA_THE_BLACK_KNIGHT))
+                            knight->CastSpell(me, SPELL_DEATHS_RESPITE);
+                        NextStep(3000, eventId);
+                        break;
+                    case EVENT_CHAT_16:
+                        if (Creature* tirion = instance->GetCreature(DATA_TIRION))
+                            tirion->AI()->Talk(SAY_TIRION_INTRO_6, me);
+                        NextStep(1000, eventId);
+                        break;
+                    case EVENT_KNOCK_ANNOUNCER:
+                        // Announcer gets pushed to death and Black Knight's vehicle flies away
+                        if (Creature* knight = instance->GetCreature(DATA_THE_BLACK_KNIGHT))
+                            knight->CastSpell(me, SPELL_DEATHS_PUSH);
+                        if (Creature* knightVehicle = ObjectAccessor::GetCreature(*me, instance->GetGuidData(DATA_BLACK_KNIGHT_VEHICLE)))
+                            knightVehicle->AI()->SetData(2, 0);
+                        NextStep(3000, eventId);
+                        break;
+                    case EVENT_CHAT_17:
+                        // Black Knight moves to center
+                        me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                        if (Creature* knight = instance->GetCreature(DATA_THE_BLACK_KNIGHT))
+                        {
+                            knight->AI()->Talk(SAY_KNIGHT_INTRO_2, me);
+                            knight->GetMotionMaster()->MovePoint(1, 747.21f, 622.75f, 411.42f);
+                        }
+                        NextStep(14000, eventId);
+                        break;
+                    case EVENT_CHAT_18:
+                        if (Creature* knight = instance->GetCreature(DATA_THE_BLACK_KNIGHT))
+                            knight->AI()->Talk(SAY_KNIGHT_INTRO_3, me);
+                        NextStep(3000, eventId);
+                        break;
+                    case EVENT_AGGRO_2:
+                        // Entering aggressive
+                        if (Creature* knight = instance->GetCreature(DATA_THE_BLACK_KNIGHT))
+                        {
+                            knight->SetWalk(false);
+                            knight->SetHomePosition(knight->GetPosition());
+                            knight->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_IMMUNE_TO_PC);
+                            knight->SetReactState(REACT_AGGRESSIVE);
+                        }
+                        NextStep(1000, eventId);
+                        break;
+                    case EVENT_CHAT_19:
+                        // Varian or Garrosh tells players to kill him
+                        if (instance->GetData(DATA_TEAM_IN_INSTANCE) == ALLIANCE)
+                        {
+                            if (Creature* varian = instance->GetCreature(DATA_VARIAN))
+                                varian->AI()->Talk(SAY_VARIAN_INTRO_3, me);
+                        }
+                        else
+                        {
+                            if (Creature* garrosh = instance->GetCreature(DATA_GARROSH))
+                                garrosh->AI()->Talk(SAY_GARROSH_INTRO_3, me);
+                        }
+                        NextStep(0, 0, false);
+                        break;
+                    case EVENT_CHAT_20:
+                        // After Black Knight is dead, a small outro event happens
+                        if (Creature* tirion = instance->GetCreature(DATA_TIRION))
+                            tirion->AI()->Talk(SAY_TIRION_OUTRO_2, me);
+                        NextStep(6000, eventId);
+                        break;
+                    case EVENT_CHAT_21:
+                        if (Creature* tirion = instance->GetCreature(DATA_TIRION))
+                            tirion->AI()->Talk(SAY_TIRION_OUTRO_3, me);
+                        NextStep(7000, eventId);
+                        break;
+                    case EVENT_CHAT_22:
+                        if (instance->GetData(DATA_TEAM_IN_INSTANCE) == ALLIANCE)
+                        {
+                            if (Creature* varian = instance->GetCreature(DATA_VARIAN))
+                                varian->AI()->Talk(SAY_VARIAN_OUTRO_1, me);
+                        }
+                        else
+                        {
+                            if (Creature* thrall = instance->GetCreature(DATA_THRALL))
+                                thrall->AI()->Talk(SAY_THRALL_OUTRO_1, me);
+                        }
+                        NextStep(0, 0, false);
+                        break;
+                    default:
                         break;
                 }
-            } else uiTimer -= uiDiff;
-
-            if (!UpdateVictim())
-                return;
-        }
-
-        void JustSummoned(Creature* summon) override
-        {
-            if (instance->GetData(BOSS_GRAND_CHAMPIONS) == NOT_STARTED)
-            {
-                summon->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
-                summon->SetReactState(REACT_PASSIVE);
             }
-        }
 
-        void SummonedCreatureDespawn(Creature* summon) override
-        {
-            switch (summon->GetEntry())
-            {
-                case VEHICLE_DARNASSIA_NIGHTSABER:
-                case VEHICLE_EXODAR_ELEKK:
-                case VEHICLE_STORMWIND_STEED:
-                case VEHICLE_GNOMEREGAN_MECHANOSTRIDER:
-                case VEHICLE_IRONFORGE_RAM:
-                case VEHICLE_FORSAKE_WARHORSE:
-                case VEHICLE_THUNDER_BLUFF_KODO:
-                case VEHICLE_ORGRIMMAR_WOLF:
-                case VEHICLE_SILVERMOON_HAWKSTRIDER:
-                case VEHICLE_DARKSPEAR_RAPTOR:
-                    SetData(DATA_LESSER_CHAMPIONS_DEFEATED, 0);
-                    break;
-            }
+            UpdateVictim();
         }
     };
 
@@ -453,40 +1258,123 @@ class npc_announcer_toc5 : public CreatureScript
         return GetInstanceAI<npc_announcer_toc5AI>(creature);
     }
 
-    bool OnGossipHello(Player* player, Creature* creature) override
+    bool HasAllSeenEvent(Player* player)
     {
-        InstanceScript* instance = creature->GetInstanceScript();
-
-        if (instance &&
-            ((instance->GetData(BOSS_GRAND_CHAMPIONS) == DONE &&
-            instance->GetData(BOSS_BLACK_KNIGHT) == DONE &&
-            instance->GetData(BOSS_ARGENT_CHALLENGE_E) == DONE) ||
-            instance->GetData(BOSS_ARGENT_CHALLENGE_P) == DONE))
+        if (!player)
             return false;
 
-        if (instance &&
-            instance->GetData(BOSS_GRAND_CHAMPIONS) == NOT_STARTED &&
-            instance->GetData(BOSS_ARGENT_CHALLENGE_E) == NOT_STARTED &&
-            instance->GetData(BOSS_ARGENT_CHALLENGE_P) == NOT_STARTED &&
-            instance->GetData(BOSS_BLACK_KNIGHT) == NOT_STARTED)
-            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_START_EVENT1, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+1);
-        else if (instance)
-            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_START_EVENT2, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+1);
+        if (player->IsGameMaster())
+            return true;
 
-        player->SEND_GOSSIP_MENU(player->GetGossipTextId(creature), creature->GetGUID());
+        bool seen = true;
+        Map::PlayerList const& players = player->GetMap()->GetPlayers();
+        for (Map::PlayerList::const_iterator itr = players.begin(); itr != players.end(); ++itr)
+        {
+            if (Player const *plr = itr->GetSource())
+            {
+                // if everyone from your group have completed one of the Trial of the Champion achievements, you have option to skip the event
+                // maybe not the correct way to do it but I couldn't figure out better
+                if (!plr->HasAchieved(4298) /* Heroic ToC (alliance) */ && !plr->HasAchieved(3778) /* Normal ToC (horde) */ && !plr->HasAchieved(4297) /* Heroic ToC (horde) */ && !plr->HasAchieved(4296) /* Normal ToC (alliance) */)
+                {
+                    seen = false;
+                    break;
+                }
+            }
+        }
+        return seen;
+    }
 
+    bool OnGossipHello(Player* player, Creature* creature) override
+    {
+        InstanceScript* instance = creature->GetInstanceScript();
+        if (instance)
+        {
+            /// @todo: fix this ugly code
+            if (player->IsGameMaster())
+            {
+                // Gamemaster mode on you can choose which encounter you start
+                // you can't though do Grand Champions encounter more than once per instance ID
+                // other encounters you can do as many times as you like
+                if ((instance->GetBossState(DATA_GRAND_CHAMPIONS) == NOT_STARTED || instance->GetBossState(DATA_GRAND_CHAMPIONS) == TO_BE_DECIDED) &&
+                    (instance->GetBossState(DATA_EADRIC_THE_PURE) == NOT_STARTED || instance->GetBossState(DATA_EADRIC_THE_PURE) == TO_BE_DECIDED) &&
+                    (instance->GetBossState(DATA_ARGENT_CONFESSOR_PALETRESS) == NOT_STARTED || instance->GetBossState(DATA_ARGENT_CONFESSOR_PALETRESS) == TO_BE_DECIDED) &&
+                    (instance->GetBossState(DATA_THE_BLACK_KNIGHT) == NOT_STARTED || instance->GetBossState(DATA_THE_BLACK_KNIGHT) == TO_BE_DECIDED))
+                {
+                    player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "[GM] Start Grand Champions encounter, unskipped roleplaying", GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF + 2);
+                    player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "[GM] Start Grand Champions encounter, skipped roleplaying", GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF + 1);
+                }
+                if ((instance->GetBossState(DATA_EADRIC_THE_PURE) == NOT_STARTED || instance->GetBossState(DATA_EADRIC_THE_PURE) == TO_BE_DECIDED) &&
+                    (instance->GetBossState(DATA_ARGENT_CONFESSOR_PALETRESS) == NOT_STARTED || instance->GetBossState(DATA_ARGENT_CONFESSOR_PALETRESS) == TO_BE_DECIDED))
+                {
+                    player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "[GM] Start Eadric the Pure encounter", GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF + 3);
+                    player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "[GM] Start Argent Confessor Paletress encounter", GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF + 4);
+                }
+                if (instance->GetBossState(DATA_THE_BLACK_KNIGHT) == NOT_STARTED || instance->GetBossState(DATA_THE_BLACK_KNIGHT) == TO_BE_DECIDED)
+                    player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "[GM] Start The Black Knight encounter", GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF + 5);
+                player->SEND_GOSSIP_MENU(1, creature->GetGUID());
+            }
+            else if ((instance->GetBossState(DATA_GRAND_CHAMPIONS) == NOT_STARTED || instance->GetBossState(DATA_GRAND_CHAMPIONS) == TO_BE_DECIDED) && player->GetVehicleBase())
+            {
+                // If Grand Champions encounter hasn't been started and the player is mounted
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_START_EVENT1, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF + 2);
+                // Patch 3.2.2: "There is now an option in the herald's dialogue to skip the introductory scripted scene if everyone in the party has already seen it."
+                if (HasAllSeenEvent(player))
+                    player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_START_EVENT_SKIP, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF + 1);
+                player->SEND_GOSSIP_MENU(GOSSIP_TEXT_FIRST_BOSS, creature->GetGUID());
+            }
+            else if ((instance->GetBossState(DATA_GRAND_CHAMPIONS) == NOT_STARTED || instance->GetBossState(DATA_GRAND_CHAMPIONS) == TO_BE_DECIDED) && !player->GetVehicleBase())
+            {
+                // If Grand Champions encounter hasn't been started and the player is not mounted
+                if (player->GetTeam() == HORDE)
+                    player->SEND_GOSSIP_MENU(GOSSIP_TEXT_UNMOUNTED_H, creature->GetGUID());
+                else
+                    player->SEND_GOSSIP_MENU(GOSSIP_TEXT_UNMOUNTED_A, creature->GetGUID());
+            }
+            else if (instance->GetBossState(DATA_GRAND_CHAMPIONS) == DONE && (instance->GetBossState(DATA_EADRIC_THE_PURE) == NOT_STARTED || instance->GetBossState(DATA_EADRIC_THE_PURE) == TO_BE_DECIDED) && (instance->GetBossState(DATA_ARGENT_CONFESSOR_PALETRESS) == NOT_STARTED || instance->GetBossState(DATA_ARGENT_CONFESSOR_PALETRESS) == TO_BE_DECIDED))
+            {
+                // If Grand Champions encounter is done and Eadric the Pure nor Argent Confessor Paletress encounters have been started
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_START_EVENT2, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF + 1);
+                player->SEND_GOSSIP_MENU(GOSSIP_TEXT_SECOND_BOSS, creature->GetGUID());
+            }
+            else if ((instance->GetBossState(DATA_EADRIC_THE_PURE) == DONE || instance->GetBossState(DATA_ARGENT_CONFESSOR_PALETRESS) == DONE) && (instance->GetBossState(DATA_THE_BLACK_KNIGHT) == NOT_STARTED || instance->GetBossState(DATA_THE_BLACK_KNIGHT) == TO_BE_DECIDED))
+            {
+                // If Grand Champions, Eadric the Pure and Argent Confessor Paletress encounters are all done but Black Knight encounter has not been started
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_START_EVENT1, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF + 1);
+                player->SEND_GOSSIP_MENU(GOSSIP_TEXT_THIRD_BOSS, creature->GetGUID());
+            }
+        }
         return true;
     }
 
     bool OnGossipSelect(Player* player, Creature* creature, uint32 /*sender*/, uint32 action) override
     {
         player->PlayerTalkClass->ClearMenus();
-        if (action == GOSSIP_ACTION_INFO_DEF+1)
+        player->CLOSE_GOSSIP_MENU();
+        switch (action)
         {
-            player->CLOSE_GOSSIP_MENU();
-            ENSURE_AI(npc_announcer_toc5::npc_announcer_toc5AI, creature->AI())->StartEncounter();
+            case GOSSIP_ACTION_INFO_DEF + 1:
+                ENSURE_AI(npc_announcer_toc5::npc_announcer_toc5AI, creature->AI())->StartEncounter();
+                break;
+            case GOSSIP_ACTION_INFO_DEF + 2:
+                ENSURE_AI(npc_announcer_toc5::npc_announcer_toc5AI, creature->AI())->StartEncounter(true);
+                break;
+            case GOSSIP_ACTION_INFO_DEF + 3:
+                creature->RemoveFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP);
+                ENSURE_AI(npc_announcer_toc5::npc_announcer_toc5AI, creature->AI())->uiArgentChampion = NPC_EADRIC;
+                ENSURE_AI(npc_announcer_toc5::npc_announcer_toc5AI, creature->AI())->DoStartArgentChampionEncounter();
+                break;
+            case GOSSIP_ACTION_INFO_DEF + 4:
+                creature->RemoveFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP);
+                ENSURE_AI(npc_announcer_toc5::npc_announcer_toc5AI, creature->AI())->uiArgentChampion = NPC_PALETRESS;
+                ENSURE_AI(npc_announcer_toc5::npc_announcer_toc5AI, creature->AI())->DoStartArgentChampionEncounter();
+                break;
+            case GOSSIP_ACTION_INFO_DEF + 5:
+                creature->RemoveFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP);
+                ENSURE_AI(npc_announcer_toc5::npc_announcer_toc5AI, creature->AI())->DoStartBlackKnight();
+                break;
+            default:
+                break;
         }
-
         return true;
     }
 };
diff --git a/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheChampion/trial_of_the_champion.h b/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheChampion/trial_of_the_champion.h
index 980da30..6635fd2 100644
--- a/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheChampion/trial_of_the_champion.h
+++ b/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheChampion/trial_of_the_champion.h
@@ -16,28 +16,92 @@
  * with this program. If not, see <http://www.gnu.org/licenses/>.
  */
 
-#ifndef DEF_TOC_H
-#define DEF_TOC_H
+#ifndef TRIAL_OF_CHAMPION_H_
+#define TRIAL_OF_CHAMPION_H_
 
+#define ToCScriptName "instance_trial_of_the_champion"
 #define DataHeader "TC"
 
-enum Data
+uint32 const EncounterCount = 4;
+
+Position const LesserChampLoc[18] =
 {
-    BOSS_GRAND_CHAMPIONS,
-    BOSS_ARGENT_CHALLENGE_E,
-    BOSS_ARGENT_CHALLENGE_P,
-    BOSS_BLACK_KNIGHT,
-    DATA_MOVEMENT_DONE,
-    DATA_LESSER_CHAMPIONS_DEFEATED,
-    DATA_START,
-    DATA_IN_POSITION,
-    DATA_ARGENT_SOLDIER_DEFEATED
+    // Horde Lesser Champions
+    { 715.12f, 612.69f, 411.77f },
+    { 715.97f, 618.20f, 411.56f },
+    { 716.55f, 623.53f, 411.79f },
+    { 717.10f, 627.32f, 411.83f },
+    { 717.91f, 632.39f, 411.87f },
+    { 718.54f, 636.32f, 411.89f },
+    { 718.82f, 641.95f, 411.90f },
+    { 719.28f, 645.82f, 411.91f },
+    { 719.86f, 650.74f, 411.92f },
+    // Alliance Lesser Champions
+    { 774.66f, 600.71f, 411.71f },
+    { 775.31f, 604.16f, 411.75f },
+    { 775.96f, 607.60f, 411.76f },
+    { 776.95f, 612.87f, 411.76f },
+    { 777.60f, 616.31f, 411.76f },
+    { 778.22f, 619.64f, 411.71f },
+    { 779.11f, 624.34f, 411.83f },
+    { 779.69f, 627.44f, 411.87f },
+    { 780.34f, 630.89f, 411.89f }
+};
+
+Position const GrandChampFinalLoc[6] =
+{
+    // Horde Grand Champions
+    { 706.49f, 618.48f, 411.88f },
+    { 709.00f, 633.73f, 411.92f },
+    { 709.17f, 646.25f, 412.39f },
+    // Alliance Grand Champions
+    { 780.96f, 603.13f, 411.84f },
+    { 783.76f, 615.98f, 411.84f },
+    { 785.75f, 625.89f, 411.89f }
 };
 
-enum Data64
+Position const announcerEncounterPos = { 732.5243f, 663.007f, 412.3932f };
+Position const announcerWaitPos = { 742.7739f, 629.849f, 411.1722f };
+Position const bossExitPos = { 746.776f, 665.221f, 411.743f, 4.82f };
+
+float const hordeOrientation = 6.175f; // Facing towards alliance spectators
+float const allianceOrientation = 3.114f; // Facing towards horde spectators
+float const gateOrientation = 1.582f; // Facing towards main gate
+float const centerOrientation = 4.714f; // Facing towards the center of arena
+
+enum DataTypes
 {
+    // Encounter States/Boss GUIDs
+    DATA_GRAND_CHAMPIONS            = 0,
+    DATA_EADRIC_THE_PURE            = 1,
+    DATA_ARGENT_CONFESSOR_PALETRESS = 2,
+    DATA_THE_BLACK_KNIGHT           = 3,
+
+    // Additional Data
     DATA_ANNOUNCER,
     DATA_MAIN_GATE,
+    DATA_TIRION,
+    DATA_VARIAN,
+    DATA_JAINA,
+    DATA_GARROSH,
+    DATA_THRALL,
+
+    DATA_CHAMPION_S_CACHE,
+    DATA_EADRIC_S_CACHE,
+    DATA_CONFESSOR_S_CACHE,
+
+    DATA_TEAM_IN_INSTANCE,
+
+    DATA_LESSER_CHAMPIONS_PREPARE,
+    DATA_LESSER_CHAMPIONS_DEFEATED,
+    DATA_START,
+    DATA_REMOVE_VEHICLES,
+    DATA_GRAND_CHAMPIONS_DONE,
+    DATA_ARGENT_CHAMPION_PREPARE,
+    DATA_ARGENT_SOLDIER_DEFEATED,
+    DATA_BLACK_KNIGHT_PREPARE,
+    DATA_BLACK_KNIGHT_PRECAST,
+    DATA_BLACK_KNIGHT_DONE,
 
     DATA_GRAND_CHAMPION_VEHICLE_1,
     DATA_GRAND_CHAMPION_VEHICLE_2,
@@ -45,86 +109,156 @@ enum Data64
 
     DATA_GRAND_CHAMPION_1,
     DATA_GRAND_CHAMPION_2,
-    DATA_GRAND_CHAMPION_3
+    DATA_GRAND_CHAMPION_3,
+
+    DATA_ARGENT_CHAMPION,
+
+    DATA_BLACK_KNIGHT_VEHICLE
 };
 
-enum CreatureIds
+enum Creatures
 {
     // Horde Champions
-    NPC_MOKRA                   = 35572,
-    NPC_ERESSEA                 = 35569,
-    NPC_RUNOK                   = 35571,
-    NPC_ZULTORE                 = 35570,
-    NPC_VISCERI                 = 35617,
+    NPC_MOKRA                                       = 35572,
+    NPC_ERESSEA                                     = 35569,
+    NPC_RUNOK                                       = 35571,
+    NPC_ZULTORE                                     = 35570,
+    NPC_VISCERI                                     = 35617,
 
     // Alliance Champions
-    NPC_JACOB                   = 34705,
-    NPC_AMBROSE                 = 34702,
-    NPC_COLOSOS                 = 34701,
-    NPC_JAELYNE                 = 34657,
-    NPC_LANA                    = 34703,
+    NPC_JACOB                                       = 34705,
+    NPC_AMBROSE                                     = 34702,
+    NPC_COLOSOS                                     = 34701,
+    NPC_JAELYNE                                     = 34657,
+    NPC_LANA                                        = 34703,
 
-    NPC_EADRIC                  = 35119,
-    NPC_PALETRESS               = 34928,
+    // Argent Champions
+    NPC_EADRIC                                      = 35119,
+    NPC_PALETRESS                                   = 34928,
 
-    NPC_ARGENT_LIGHWIELDER      = 35309,
-    NPC_ARGENT_MONK             = 35305,
-    NPC_PRIESTESS               = 35307,
+    NPC_ARGENT_LIGHWIELDER                          = 35309,
+    NPC_ARGENT_MONK                                 = 35305,
+    NPC_PRIESTESS                                   = 35307,
 
-    NPC_BLACK_KNIGHT            = 35451,
+    // The Black Knight
+    NPC_BLACK_KNIGHT                                = 35451,
 
-    NPC_RISEN_JAEREN            = 35545,
-    NPC_RISEN_ARELAS            = 35564,
+    NPC_RISEN_JAEREN                                = 35545,
+    NPC_RISEN_ARELAS                                = 35564,
+    NPC_DESECRATION_STALKER                         = 35614,
 
-    NPC_JAEREN                  = 35004,
-    NPC_ARELAS                  = 35005
+    // Announcers
+    NPC_JAEREN                                      = 35004,
+    NPC_ARELAS                                      = 35005,
+
+    // Spectators
+    NPC_TIRION                                      = 34996,
+    NPC_JAINA                                       = 34992,
+    NPC_VARIAN                                      = 34990,
+    NPC_THRALL                                      = 34994,
+    NPC_GARROSH                                     = 34995,
+    NPC_SPECTATOR_HORDE                             = 34883,
+    NPC_SPECTATOR_ALLIANCE                          = 34887,
+    NPC_SPECTATOR_HUMAN                             = 34900,
+    NPC_SPECTATOR_ORC                               = 34901,
+    NPC_SPECTATOR_TROLL                             = 34902,
+    NPC_SPECTATOR_TAUREN                            = 34903,
+    NPC_SPECTATOR_BELF                              = 34904,
+    NPC_SPECTATOR_UNDEAD                            = 34905,
+    NPC_SPECTATOR_DWARF                             = 34906,
+    NPC_SPECTATOR_DRAENEI                           = 34908,
+    NPC_SPECTATOR_NELF                              = 34909,
+    NPC_SPECTATOR_GNOME                             = 34910
 };
 
 enum GameObjects
 {
-    GO_MAIN_GATE                = 195647,
+    GO_MAIN_GATE                                    = 195647,
 
-    GO_CHAMPIONS_LOOT           = 195709,
-    GO_CHAMPIONS_LOOT_H            = 195710,
+    GO_CHAMPION_S_CACHE                             = 195709,
+    GO_CHAMPION_S_CACHE_H                           = 195710,
 
-    GO_EADRIC_LOOT              = 195374,
-    GO_EADRIC_LOOT_H            = 195375,
+    GO_EADRIC_S_CACHE                               = 195374,
+    GO_EADRIC_S_CACHE_H                             = 195375,
 
-    GO_PALETRESS_LOOT           = 195323,
-    GO_PALETRESS_LOOT_H            = 195324
+    GO_CONFESSOR_S_CACHE                            = 195323,
+    GO_CONFESSOR_S_CACHE_H                          = 195324
 };
 
 enum Vehicles
 {
-    //Grand Champions Alliance Vehicles
+    // Grand Champions Alliance Vehicles
     VEHICLE_MARSHAL_JACOB_ALERIUS_MOUNT             = 35637,
     VEHICLE_AMBROSE_BOLTSPARK_MOUNT                 = 35633,
     VEHICLE_COLOSOS_MOUNT                           = 35768,
     VEHICLE_EVENSONG_MOUNT                          = 34658,
     VEHICLE_LANA_STOUTHAMMER_MOUNT                  = 35636,
-    //Faction Champions (ALLIANCE)
-    VEHICLE_DARNASSIA_NIGHTSABER                    = 33319,
-    VEHICLE_EXODAR_ELEKK                            = 33318,
-    VEHICLE_STORMWIND_STEED                         = 33217,
-    VEHICLE_GNOMEREGAN_MECHANOSTRIDER               = 33317,
-    VEHICLE_IRONFORGE_RAM                           = 33316,
-    //Grand Champions Horde Vehicles
+    // Faction Champions (Alliance)
+    VEHICLE_DARNASSUS_CHAMPION                      = 35332,
+    VEHICLE_EXODAR_CHAMPION                         = 35330,
+    VEHICLE_STORMWIND_CHAMPION                      = 35328,
+    VEHICLE_GNOMEREGAN_CHAMPION                     = 35331,
+    VEHICLE_IRONFORGE_CHAMPION                      = 35329,
+    // Grand Champions Horde Vehicles
     VEHICLE_MOKRA_SKILLCRUSHER_MOUNT                = 35638,
     VEHICLE_ERESSEA_DAWNSINGER_MOUNT                = 35635,
     VEHICLE_RUNOK_WILDMANE_MOUNT                    = 35640,
     VEHICLE_ZUL_TORE_MOUNT                          = 35641,
     VEHICLE_DEATHSTALKER_VESCERI_MOUNT              = 35634,
-    //Faction Champions (HORDE)
-    VEHICLE_FORSAKE_WARHORSE                        = 33324,
-    VEHICLE_THUNDER_BLUFF_KODO                      = 33322,
-    VEHICLE_ORGRIMMAR_WOLF                          = 33320,
-    VEHICLE_SILVERMOON_HAWKSTRIDER                  = 33323,
-    VEHICLE_DARKSPEAR_RAPTOR                        = 33321,
-
-    VEHICLE_ARGENT_WARHORSE                         = 35644,
+    // Faction Champions (Horde)
+    VEHICLE_UNDERCITY_CHAMPION                      = 35327,
+    VEHICLE_THUNDER_BLUFF_CHAMPION                  = 35325,
+    VEHICLE_ORGRIMMAR_CHAMPION                      = 35314,
+    VEHICLE_SILVERMOON_CHAMPION                     = 35326,
+    VEHICLE_SENJIN_CHAMPION                         = 35323,
+    // Player vehicles
+    VEHICLE_ARGENT_WARHORSE_COSMETIC                = 35644,
+    VEHICLE_ARGENT_WARHORSE                         = 36557,
     VEHICLE_ARGENT_BATTLEWORG                       = 36558,
-
+    VEHICLE_ARGENT_BATTLEWORG_COSMETIC              = 36559,
+    // The Black Knight's vehicle
     VEHICLE_BLACK_KNIGHT                            = 35491
 };
 
-#endif
+enum WaypointData
+{
+    DATA_GENERATE_WAYPOINTS_FOR_BOSS_1              = 1,
+    DATA_GENERATE_WAYPOINTS_FOR_BOSS_2,
+    DATA_GENERATE_WAYPOINTS_FOR_BOSS_3,
+    DATA_GENERATE_WAYPOINTS_FOR_ADDS
+};
+
+enum WaypointPaths
+{
+    WAYPOINT_MAP_BOSS_1                             = 1,
+    WAYPOINT_MAP_BOSS_2,
+    WAYPOINT_MAP_BOSS_3,
+    WAYPOINT_MAP_ADDS
+};
+
+enum Seats
+{
+    SEAT_ID_0                                       = 0
+};
+
+enum FlagSpells
+{
+    SPELL_FLAG_DARNASSUS                            = 63406,
+    SPELL_FLAG_EXODAR                               = 63423,
+    SPELL_FLAG_GNOMEREGAN                           = 63396,
+    SPELL_FLAG_IRONFORGE                            = 63427,
+    SPELL_FLAG_ORGRIMMAR                            = 63433,
+    SPELL_FLAG_SENJIN                               = 63399,
+    SPELL_FLAG_SILVERMOON                           = 63403,
+    SPELL_FLAG_STORMWIND                            = 62594,
+    SPELL_FLAG_THUNDER_BLUFF                        = 63436,
+    SPELL_FLAG_UNDERCITY                            = 63430
+};
+
+template<class AI>
+AI* GetTrialOfChampionAI(Creature* creature)
+{
+    return GetInstanceAI<AI>(creature, ToCScriptName);
+}
+
+#endif // TRIAL_OF_CHAMPION_H_